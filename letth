import { HttpClient } from '@angular/common/http';
import { Component, ElementRef, EventEmitter, Inject, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { catchError, debounceTime, distinctUntilChanged, firstValueFrom, map, Observable, of, startWith, Subject, switchMap, takeUntil, tap } from 'rxjs';
import { StoreFilter, FilterOptions, GetGridDataFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-filter-sidebar',
  templateUrl: './filter-sidebar.component.html',
  styleUrls: ['./filter-sidebar.component.css']
})
export class FilterSidebarComponent implements OnInit, OnDestroy {
  @Output() filtersChanged = new EventEmitter<GetGridDataFilter>();
  @Output() clearFilters = new EventEmitter<void>();
 private allAvailableColumns = {
    base: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'zip', label: 'Zip', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    current: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'position_number', label: 'Position Number', required: false },
      { key: 'bdf', label: 'BDF', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      // { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    future: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'position_number', label: 'Position Number', required: false },
      { key: 'bdf', label: 'BDF', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'avg_cost', label: 'Avg Cost', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    previous: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
       { key: 'position_number', label: 'Position Number', required: false },
      { key: 'bdf', label: 'BDF', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      // { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'wk1_costs', label: 'WK1 Costs', required: false },
      { key: 'wk1_travel', label: 'WK1 Travel Cost', required: false },
      { key: 'wk1_ovg_travel', label: 'WK1 ovg Travel Cost', required: false },     
      { key: 'wk2_costs', label: 'WK2 Costs', required: false },
      { key: 'wk2_travel', label: 'WK2 Travel Cost', required: false },
      { key: 'wk2_ovg_travel', label: 'WK2 ovg Travel Cost', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ]
  };

  currentWeekType: 'current' | 'future' | 'previous' = 'current';
  availableColumns: any[] = [];
  selectedColumns: string[] = [];

  @Output() columnsChanged = new EventEmitter<string[]>();
  filterForm!: FormGroup;
  showAdvancedFilters = false;
  showSpinner = false;
   private formInitialized = false;
  private dataLoaded = {
    iriWeek: false,
    territory: false,
    employee: false
  };
  // Data arrays
  employeedata: any[] = [];
  iriWeeks: any[] = [];
  territories: any[] = [];
  filteredStores: any[] = [];
  filteredState: any[] = [];
  filteredCity: any[] = [];
  filteredCluster: any[] = [];
  filteredTask: any[] = [];
  filteredFSR: any[] = [];
  fsrHourOperators = [
    { value: 'NA', label: 'NA' },
    { value: '>', label: '>' },
    { value: '=', label: '=' },
    { value: '<', label: '<' }
  ];
  // Selected values
  selectedStoreNumber = '';
  selectedState = '';
  selectedCity = '';
  selectedCluster = '';
  selectedTask = '';
  selectedFsrId = '';
  areaNBRctrl = new FormControl();
  private unsubscribe$ = new Subject<void>();
  private loggeduser: string;

  constructor(
    private fb: FormBuilder,
    private commonService: CommonService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
  ) {
    this.initializeForm();
    this.loggeduser = localStorage.getItem("loggedUserId") || '';
  }

  async ngOnInit(): Promise<void> {
 this.commonService.weekType$
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe(weekType => {
        this.currentWeekType = weekType;
        this.updateAvailableColumns();
        this.resetSelectedColumnsForWeekType();
      });

    try {
       this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
        this.dataLoaded.employee = true;
      await this.getIriWeek();
      this.dataLoaded.iriWeek = true;
      await this.getTerritory();  
      this.dataLoaded.territory = true;
      
      // Setup form subscriptions after data is loaded
      this.setupFormSubscriptions();
      
      // Mark form as initialized
      this.formInitialized = true;
      
      // NOW apply default filters after everything is ready
      this.applyDefaultFilters();
    } catch (error) {
      console.error('Error initializing filter component:', error);
    }
  }

  private initializeForm(): void {
    this.filterForm = this.fb.group({
      iriWeek: [''],
      territory: [''],
      store: [''],
      state: [''],
      city: [''],
      cluster: [''],
      task: [''],
      fsr: [''],
      fsrHour: [''],
      fsrHourOperator: ['NA'], 
      storeAssignment: ['all'],
      sampleType: ['all'],
      multiFsrStore: [false]
    });
  }

    private async getIriWeek(): Promise<void> {
    try {
      const response = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')
      );
      
      this.iriWeeks = response;
      
      // Set default value
      if (this.iriWeeks.length > 0) {
        this.filterForm.get('iriWeek')?.setValue(
          this.iriWeeks?.[0]?.['iri_week'], 
          { emitEvent: false }
        );
      }
    } catch (error) {
      console.error('Error fetching IRI weeks:', error);
      throw error;
    }
  }

  private async getTerritory(): Promise<void> {
    try {
      this.showSpinner = true;
      const response = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      );
      
      this.territories = response;
      
      // Set default territory
      const defaultTerritory = this.getDefaultTerritory();
      this.filterForm.get('territory')?.setValue(defaultTerritory, { emitEvent: false });
      
      if (this.territories.length > 0) {
        this.areaNBRctrl.setValue(this.territories['area']);
      }
      
    } catch (error) {
      console.error('Error fetching territories:', error);
      throw error;
    } finally {
      this.showSpinner = false;
    }
  }

  private getDefaultTerritory(): string {
    if (!this.employeedata) return '';
    
    return this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'];
  }

  private setupFormSubscriptions(): void {
    // Store autocomplete
    this.filterForm.get('store')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getStore(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(stores => {
      this.filteredStores = stores || [];
      this.showSpinner = false;
    });

    // State autocomplete
    this.filterForm.get('state')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getState(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(states => {
      this.filteredState = states || [];
      this.showSpinner = false;
    });

    // City autocomplete
    this.filterForm.get('city')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCity(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(cities => {
      this.filteredCity = cities || [];
      this.showSpinner = false;
    });

    // Cluster autocomplete
    this.filterForm.get('cluster')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCluster(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(clusters => {
      this.filteredCluster = clusters || [];
      this.showSpinner = false;
    });

    // Task autocomplete
    this.filterForm.get('task')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getTask(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(tasks => {
      this.filteredTask = tasks || [];
    });

    // FSR autocomplete
    this.filterForm.get('fsr')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getFsr(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(fsrs => {
      this.filteredFSR = fsrs || [];
    });
  }

 
  getStore(searchText: string) {
    if (!searchText || searchText.length < 3) {
      return of([]);
    }

    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetStore', payload)
      .pipe(catchError(() => of([])));
  }

  getState(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetState', payload)
      .pipe(catchError(() => of([])));
  }

  getCity(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCity', payload)
      .pipe(catchError(() => of([])));
  }

  getCluster(searchText: string) {
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCluster', payload)
      .pipe(catchError(() => of([])));
  }

  getTask(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetTask', payload)
      .pipe(catchError(() => of([])));
  }

  getFsr(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsr', payload)
      .pipe(catchError(() => of([])));
  }

  // Event handlers for IRI Week and Territory changes
  onIriWeekChange(): void {
    // Clear dependent fields when IRI week changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  onTerritoryChange(): void {
    // this.areaNBRctrl.setValue(ter.area)
    // Clear dependent fields when territory changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  // Selection event handlers
  onStoreSelected(event: any) {
    const selectedStore = this.filteredStores.find(store => store.store_name === event.option.value);
    this.selectedStoreNumber = selectedStore?.store_number || '';
  }

  onStateSelected(event: any) {
    const selectedState = this.filteredState.find(state => state.state === event.option.value);
    this.selectedState = selectedState?.state || '';
  }

  onCitySelected(event: any) {
    const selectedCity = this.filteredCity.find(city => city.city === event.option.value);
    this.selectedCity = selectedCity?.city || '';
  }

  onClusterSelected(event: any) {
    const selectedCluster = this.filteredCluster.find(cluster => cluster.position_name === event.option.value);
    this.selectedCluster = selectedCluster?.position_number || '';
  }

  onTaskSelected(event: any) {
    const selectedTask = this.filteredTask.find(task => task.task_name === event.option.value);
    this.selectedTask = selectedTask?.task_number || '';
  }

  onFsrSelected(event: any) {
    const selectedFsr = this.filteredFSR.find(fsr => fsr.emp_name === event.option.value);
    this.selectedFsrId = selectedFsr?.emp_id || '';
  }

  // Control methods
  toggleAdvancedFilters(): void {
    this.showAdvancedFilters = !this.showAdvancedFilters;
  }


  onApplyFilters(): void {
    this.commonService.show('apply-filters');
     if (!this.formInitialized) {
        this.commonService.hide('apply-filters');     
      return;
    }

    const currentCountry = this.commonService.getCurrentCountry();
    if (!currentCountry) {
      // console.log('Please select a country first');
      // return;
    }

    // Validate required fields
    const formValue = this.filterForm.value;
    if (!formValue.iriWeek || !formValue.territory) {
        this.commonService.hide('apply-filters');    
      return;
    }
    const filters = new GetGridDataFilter();
    filters.countryId = currentCountry||'1';
    filters.lanId = this.loggeduser;
    filters.iriWeek = formValue.iriWeek || '';
    filters.territoryId = formValue.territory || '';
    filters.area = this.areaNBRctrl.value || '23';
    filters.storeNumber = this.selectedStoreNumber;
    filters.storeName = formValue.store || '';
    filters.state = this.selectedState;
    filters.city = this.selectedCity;
    filters.positionNumber = this.selectedCluster;
    filters.taskNumber = this.selectedTask;
    filters.empId = this.selectedFsrId;
    filters.fsrHour = formValue.fsrHour || '';
    filters.fsrHourOperator = formValue.fsrHourOperator || 'NA'; 
    filters.fsrOver25hrs = 'false';
    filters.fsrOver6hrs = 'false';
    filters.temporary = 'false';
    filters.vacation = 'false';
    // Handle radio button selections
    if (formValue.storeAssignment === 'assigned') {
      filters.assignedStores = 'true';
      filters.unassignedStores = 'false';
    } else if (formValue.storeAssignment === 'unassigned') {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'true';
    } else {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'false';
    }

    if (formValue.sampleType === 'sample') {
      filters.sample = 'true';
      filters.nonSample = 'false';
    } else if (formValue.sampleType === 'nonSample') {
      filters.sample = 'false';
      filters.nonSample = 'true';
    } else {
      filters.sample = 'false';
      filters.nonSample = 'false';
    }

    filters.multiFsrStore = formValue.multiFsrStore ? 'true' : 'false';
  setTimeout(() => this.commonService.hide('apply-filters'), 100);
    this.filtersChanged.emit(filters);
  }

  // MISSING FUNCTION: Clear Filters
  onClearFilters(): void {
    this.filterForm.reset({
      iriWeek: this.iriWeeks.length > 1 ? this.iriWeeks?.[0]?.['iri_week'] : '',
      territory: this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'],
        storeAssignment: 'all',
      sampleType: 'all',
      multiFsrStore: false,
      fsrHourOperator: 'NA'
    });
    this.clearSelectedValues();
    this.clearFilters.emit();
  }

  // Apply Default Filters on Load
  private applyDefaultFilters(): void {
    if (!this.formInitialized || !this.allDataLoaded()) {
      console.log('Form not ready for default filters');
      return;
    }

    console.log('Applying default filters - all data loaded');
    setTimeout(() => {
      this.onApplyFilters();
    }, 500);
  }

  private allDataLoaded(): boolean {
    return this.dataLoaded.iriWeek && 
           this.dataLoaded.territory && 
           this.dataLoaded.employee;
  }

  private clearSelectedValues(): void {
    this.selectedStoreNumber = '';
    this.selectedState = '';
    this.selectedCity = '';
    this.selectedCluster = '';
    this.selectedTask = '';
    this.selectedFsrId = '';
  }

  // Clear individual controls
  clearStrCtrl() { 
    this.filterForm.get('store')?.reset(); 
    this.selectedStoreNumber = '';
  }
  clearStaCtrl() { 
    this.filterForm.get('state')?.reset(); 
    this.selectedState = '';
  }
  clearcityCtrl() { 
    this.filterForm.get('city')?.reset(); 
    this.selectedCity = '';
  }
  clearTaskCtrl() { 
    this.filterForm.get('task')?.reset(); 
    this.selectedTask = '';
  }
  clearFsrCtrl() { 
    this.filterForm.get('fsr')?.reset(); 
    this.selectedFsrId = '';
  }

   onFsrHourOperatorChange(): void {
    const operator = this.filterForm.get('fsrHourOperator')?.value;
    const fsrHourControl = this.filterForm.get('fsrHour');
    
    if (operator === 'NA') {
      fsrHourControl?.setValue('');
      fsrHourControl?.disable();
    } else {
      fsrHourControl?.enable();
    }
  }

  onFsrHourChange(): void {
    const fsrHour = this.filterForm.get('fsrHour')?.value;
    if (fsrHour && fsrHour.trim() !== '') {
      // Reset multi FSR store if user enters FSR hours
      this.filterForm.get('multiFsrStore')?.setValue(false);
    }
  }
  onMultiFsrStoreChange(): void {
    const multiFsrStore = this.filterForm.get('multiFsrStore')?.value;
    if (multiFsrStore) {
      this.filterForm.get('fsrHourOperator')?.setValue('NA');
      this.filterForm.get('fsrHour')?.setValue('');
      this.filterForm.get('fsrHour')?.disable();
    }
  }


   private async loadAllData(): Promise<void> {
    try {
      this.showSpinner = true;
      
      // Load all data in parallel
      const [iriWeeks, territories, employeeData] = await Promise.all([
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')),
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')),
        firstValueFrom(this.commonService.getEmployee(this.loggeduser))
      ]);

      this.iriWeeks = iriWeeks;
      this.territories = territories;
      this.employeedata = employeeData;
      
      this.applyDefaultFilters();
      this.setupFormSubscriptions();
      
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      this.showSpinner = false;
    }
  }

  // Generic autocomplete method
  private setupAutocomplete<T>(controlName: string, apiEndpoint: string): void {
    this.filterForm.get(controlName)?.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() => this.showSpinner = true),
      switchMap(searchText => this.genericSearch<T>(apiEndpoint, searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(results => {
      this[`filtered${controlName.charAt(0).toUpperCase() + controlName.slice(1)}`] = results;
      this.showSpinner = false;
    });
  }

  // Generic search method
  private genericSearch<T>(endpoint: string, searchText: string): Observable<T[]> {
    if (!searchText || searchText.length < 2) return of([]);
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<T[]>(this.baseUrl + endpoint, payload)
      .pipe(catchError(() => of([])));
  }

  private updateAvailableColumns(): void {
    switch (this.currentWeekType) {
      case 'current':
        this.availableColumns = this.allAvailableColumns.current;
        break;
      case 'future':
        this.availableColumns = this.allAvailableColumns.future;
        break;
      case 'previous':
        this.availableColumns = this.allAvailableColumns.previous;
        break;
      default:
        this.availableColumns = this.allAvailableColumns.base;
    }
  }

 //Reset selected columns when week type changes
  private resetSelectedColumnsForWeekType(): void {
    this.selectedColumns = this.availableColumns
      .filter(col => col.required || this.getDefaultVisibleColumns().includes(col.key))
      .map(col => col.key);
    this.columnsChanged.emit(this.selectedColumns);
  }

 //Get default visible columns based on week type
  private getDefaultVisibleColumns(): string[] {
    const common = ['addr_line1', 'city'];
    
    switch (this.currentWeekType) {
      case 'current':
        return [...common, 'task_completed','position_number','bdf', 'outlet'];
      case 'future':
        return [...common, 'avg_cost','guaranteed_miles','position_number','bdf', 'outlet'];
      case 'previous':
        return [...common, 'task_completed', 'wk1_costs','wk1_travel', 'wk1_ovg_travel','wk2_costs', 'wk2_travel','wk2_ovg_travel'];
      default:
        return common;
    }
  }

 //Column selection change with week type awareness
  onColumnSelectionChange(): void {
    const requiredColumns = this.availableColumns
      .filter(col => col.required)
      .map(col => col.key);
      
    this.selectedColumns = [...new Set([...this.selectedColumns, ...requiredColumns])];
    this.columnsChanged.emit(this.selectedColumns);
  }

  isColumnRequired(columnKey: string): boolean {
    return this.availableColumns.find(col => col.key === columnKey)?.required || false;
  }


  ngOnDestroy(): void {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}
<div class="filter-topbar">
  <div class="filter-container">
    <form [formGroup]="filterForm" class="filter-form">
      
      <!-- ROW 1: Primary Filters -->
      <div class="filter-row primary-row">
        
        <!-- IRI Week -->
        <div class="filter-field">
          <label class="form-label">IRI Week</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="iriWeek" (selectionChange)="onIriWeekChange()">
              <mat-option *ngFor="let week of iriWeeks" [value]="week.iri_week">
                {{week.iri_week_viewOnly}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Territory -->
        <div class="filter-field">
          <label class="form-label">Territory</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
              <mat-option [value]="'-1'">ALL</mat-option>
              <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
                {{territory.territory_name}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Store -->
        <div class="filter-field">
          <label class="form-label">Store</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="storeAuto" formControlName="store" placeholder="Search stores...">
            <button mat-button *ngIf="filterForm.get('store')?.value" matSuffix mat-icon-button (click)="clearStrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #storeAuto="matAutocomplete" (optionSelected)="onStoreSelected($event)">
              <mat-option *ngFor="let store of filteredStores" [value]="store.store_name" [matTooltip]="store.store_name">
                {{store.store_name}} ({{store.store_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- FSR -->
        <div class="filter-field">
          <label class="form-label">FSR</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="fsrAuto" formControlName="fsr" placeholder="Search FSR...">
            <button mat-button *ngIf="filterForm.get('fsr')?.value" matSuffix mat-icon-button (click)="clearFsrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #fsrAuto="matAutocomplete" (optionSelected)="onFsrSelected($event)">
              <mat-option *ngFor="let fsr of filteredFSR" [value]="fsr.emp_name" [matTooltip]="fsr.emp_name">
                {{fsr.emp_name}} ({{fsr.emp_id}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Store Assignment (Changed from radio to dropdown) -->
        <div class="filter-field">
          <label class="form-label">Store Assignment</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="storeAssignment">
              <mat-option value="all">All Stores</mat-option>
              <mat-option value="assigned">Assigned Stores</mat-option>
              <mat-option value="unassigned">Unassigned Stores</mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Sample Type (Changed from radio to dropdown) -->
        <div class="filter-field">
          <label class="form-label">Sample Type</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="sampleType">
              <mat-option value="all">All Types</mat-option>
              <mat-option value="sample">Sample</mat-option>
              <mat-option value="nonSample">Non-Sample</mat-option>
            </mat-select>
          </mat-form-field>
        </div>

         <!-- Action Buttons -->
        <div class="action-buttons">
          <button mat-raised-button color="primary" (click)="onApplyFilters()">
            Apply Filters
          </button>
          <button mat-stroked-button (click)="onClearFilters()">
            Clear Filters
          </button>
        </div>
      </div>

      <!-- ROW 2: Secondary Filters -->
      <div class="filter-row secondary-row">
        
        <!-- State -->
        <div class="filter-field">
          <label class="form-label">State</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="stateAuto" formControlName="state">
            <button mat-button *ngIf="filterForm.get('state')?.value" matSuffix mat-icon-button (click)="clearStaCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #stateAuto="matAutocomplete" (optionSelected)="onStateSelected($event)">
              <mat-option *ngFor="let state of filteredState" [value]="state.state">
                {{state.state}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- City -->
        <div class="filter-field">
          <label class="form-label">City</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="cityAuto" formControlName="city">
            <button mat-button *ngIf="filterForm.get('city')?.value" matSuffix mat-icon-button (click)="clearcityCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #cityAuto="matAutocomplete" (optionSelected)="onCitySelected($event)">
              <mat-option *ngFor="let city of filteredCity" [value]="city.city">
                {{city.city}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Cluster -->
        <div class="filter-field">
          <label class="form-label">Cluster</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="clusterAuto" formControlName="cluster">
            <mat-autocomplete #clusterAuto="matAutocomplete" (optionSelected)="onClusterSelected($event)">
              <mat-option *ngFor="let cluster of filteredCluster" [value]="cluster.position_name">
                {{cluster.position_name}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Task -->
        <div class="filter-field">
          <label class="form-label">Task</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="taskAuto" formControlName="task">
            <button mat-button *ngIf="filterForm.get('task')?.value" matSuffix mat-icon-button (click)="clearTaskCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #taskAuto="matAutocomplete" (optionSelected)="onTaskSelected($event)">
              <mat-option *ngFor="let task of filteredTask" [value]="task.task_name">
                {{task.task_name}} ({{task.task_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- FSR Hours (Combined operator and hours input) -->
        <div class="filter-field fsr-hours-field">
          <label class="form-label">FSR Hours</label>
          <div class="fsr-hours-container">
            <mat-form-field appearance="outline" class="operator-field">
              <mat-select formControlName="fsrHourOperator" (selectionChange)="onFsrHourOperatorChange()">
                <mat-option *ngFor="let op of fsrHourOperators" [value]="op.value">
                  {{op.label}}
                </mat-option>
              </mat-select>
            </mat-form-field>
            
            <mat-form-field appearance="outline" class="hour-field">
              <input matInput 
                    formControlName="fsrHour" 
                    type="number" 
                    placeholder="Hours"
                    (change)="onFsrHourChange()"
                    min="0"
                    max="999">
            </mat-form-field>
          </div>
        </div>

        <!-- Visible Columns -->
        <div class="filter-field">
          <label class="form-label">Visible Columns</label>
          <mat-form-field appearance="outline">
            <mat-label>Select Columns</mat-label>
            <mat-select multiple [(value)]="selectedColumns" (selectionChange)="onColumnSelectionChange()">
              <mat-option *ngFor="let column of availableColumns" 
                          [value]="column.key" 
                          [disabled]="column.required">
                {{column.label}}
                <span *ngIf="column.required" class="required-indicator"> *</span>
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Multi FSR Store Checkbox -->
        <div class="checkbox-field">
          <label class="form-label">Options</label>
          <mat-checkbox formControlName="multiFsrStore" (change)="onMultiFsrStoreChange()">
            Multi FSR Store
          </mat-checkbox>
        </div>
      </div>
          
    </form>
  </div>
</div>

<footer>
  <div class="mat-spinner-container">
    <mat-spinner mode="indeterminate" *ngIf="showSpinner"></mat-spinner>
    <div *ngIf="showSpinner" style="position:relative;left: 10px">Loading...</div>
  </div>
</footer>
