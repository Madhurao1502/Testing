import { Component, HostListener, Input, OnInit } from '@angular/core';
import { NestedTreeControl } from '@angular/cdk/tree';
import { MatTreeNestedDataSource } from '@angular/material/tree';
import { HttpClient } from '@angular/common/http';
import { MatDialog } from '@angular/material/dialog';
import { SnackbarService } from '../shared/snackbar.service';
import { Subject, takeUntil } from 'rxjs';
import { ShelfVarDialogComponent, ShelfVarDialogData } from '../shelf-var-dialog/shelf-var-dialog.component';

interface ShelfNode {
  Id: number;
  PId?: number;
  Name: string;
  level?: number;
  AllowAdd?: string;
  optional?: string;
  RetiredDate?: string | null;
  IsNewlyAdded?: 'N' | 'U' | '';
  MainMin?: string;
  MainMax?: string;
  MainSoftCheck?: string;
  MainHardCheck?: string;
  children?: ShelfNode[];
}

type UserAccessFlag = 'B' | 'U' | 'S';

@Component({
  selector: 'app-shelf-tree',
  templateUrl: './shelf-tree.component.html',
  styleUrls: ['./shelf-tree.component.css']
})
export class ShelfTreeComponent implements OnInit {
  @Input() group!: number;
  @Input() title!: string;
  @Input() userAccess: UserAccessFlag = 'U';

  treeControl = new NestedTreeControl<ShelfNode>(node => node.children);
  dataSource = new MatTreeNestedDataSource<ShelfNode>();

  selectedNode: ShelfNode | null = null;
  rightClickedNode: ShelfNode | null = null;

  contextMenuVisible = false;
  contextX = 0;
  contextY = 0;

  showLimits = false;
  showChecks = false;
  disableMinMax = false;
  showSpinner = false;

  private unsubscribe$ = new Subject<void>();

  constructor(
    private http: HttpClient,
    private dialog: MatDialog,
    private _snackBar: SnackbarService,
  ) {}

  ngOnInit(): void {
    this.getShelfVars();
  }

  getShelfVars() {
    this.showSpinner = true;
    this.http.post<ShelfNode[]>(`/api/MasterShelfVariables/GetShelfVar`, { Group: Number(this.group) })
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe({
        next: (res) => {
          const nestedData = this.buildNestedTree(res);
          this.dataSource.data = nestedData;
          this.expandAllNodes(nestedData);
          if (nestedData.length > 0) this.onSelect(nestedData[0]);
          this.showSpinner = false;
        },
        error: () => this.showSpinner = false
      });
  }

  hasChild = (_: number, node: ShelfNode) => !!node.children && node.children.length > 0;

  onSelect(node: ShelfNode): void {
    this.selectedNode = node;
    this.configureDisplayFields(node);
  }

  onRightClick(event: MouseEvent, node: ShelfNode): void {
    event.preventDefault();

    if (this.userAccess === 'U') {
      this._snackBar.openSnackBar("You don't have a security level assigned for shelf master.", 'error');
      return;
    }
    if (this.userAccess === 'B') {
      this._snackBar.openSnackBar("You have read-only rights assigned for the shelf variable master screen. You will not be able to make changes.", 'warning');
      return;
    }

    this.rightClickedNode = node;
    this.contextMenuVisible = true;
    this.contextX = event.clientX;
    this.contextY = event.clientY;
  }

  @HostListener('document:click')
  hideContextMenu() {
    this.contextMenuVisible = false;
  }

  configureDisplayFields(node: ShelfNode): void {
    const limitIds = [11160, 14825, 15490, 15995, 16910, 22700];
    const checkIds = [10100, 20000, 30100];

    this.disableMinMax = limitIds.includes(node.Id);
    this.showLimits = !checkIds.includes(node.Id);
    this.showChecks = !this.disableMinMax;
  }

  openAddDialog(): void {
    if (!this.canAdd()) return;
    this.contextMenuVisible = false;

    const dialogRef = this.dialog.open<ShelfVarDialogComponent, ShelfVarDialogData, string>(ShelfVarDialogComponent, {
      width: '400px',
      data: { mode: 'add', initialName: '' }
    });

    dialogRef.afterClosed().subscribe(name => {
      if (!name) return;

      const trimmedName = name.trim();

      if (!this.isUniqueNameInSiblings(this.rightClickedNode!, trimmedName)) {
        this._snackBar.openSnackBar(`Variable "${trimmedName}" already exists. Please choose a different name.`, 'error');
        return;
      }

      const newNode: ShelfNode = {
        Id: this.generateNewNodeId(this.rightClickedNode!),
        PId: this.rightClickedNode!.Id,
        Name: trimmedName,
        optional: 'Y',
        IsNewlyAdded: 'N',
        AllowAdd: '',
        children: []
      };

      this.rightClickedNode!.children = this.rightClickedNode!.children || [];
      this.rightClickedNode!.children.push(newNode);

      this.sortChildrenByName(this.rightClickedNode!);
      this.treeControl.expand(this.rightClickedNode!);
      this.dataSource.data = this.dataSource.data.slice();
    });
  }

  openEditDialog(): void {
    if (!this.canEdit() || !this.rightClickedNode) return;
    this.contextMenuVisible = false;

    const dialogRef = this.dialog.open<ShelfVarDialogComponent, ShelfVarDialogData, string>(ShelfVarDialogComponent, {
      width: '400px',
      data: { mode: 'edit', initialName: this.rightClickedNode.Name }
    });

    dialogRef.afterClosed().subscribe(name => {
      if (!name) return;

      const trimmedName = name.trim();

      if (!this.isUniqueNameInSiblings(this.findParent(this.dataSource.data, this.rightClickedNode)!, trimmedName, this.rightClickedNode.Id)) {
        this._snackBar.openSnackBar(`Variable "${trimmedName}" already exists. Please choose a different name.`, 'error');
        return;
      }

      this.rightClickedNode!.Name = trimmedName;
      this.rightClickedNode!.IsNewlyAdded = 'U';
      this.dataSource.data = this.dataSource.data.slice();
    });
  }

  confirmDialog(): void {
    // Not needed anymore since handled with MatDialog
  }

  cancelDialog(): void {
    // Not needed anymore since handled with MatDialog
  }

  deleteNode(): void {
    if (!this.canDelete() || !this.rightClickedNode) return;

    const parent = this.findParent(this.dataSource.data, this.rightClickedNode);
    if (parent) {
      parent.children = parent.children!.filter(c => c.Id !== this.rightClickedNode!.Id);
    } else {
      this.dataSource.data = this.dataSource.data.filter(c => c.Id !== this.rightClickedNode!.Id);
    }
    this.dataSource.data = this.dataSource.data.slice();
    this.contextMenuVisible = false;
  }

  retireNode(): void {
    if (!this.canRetire() || !this.rightClickedNode) return;

    const confirmRetire = confirm('Are you sure you want to retire the selected Shelf Variable?\nNOTE: This action will affect all child variables');
    if (!confirmRetire) return;

    this.rightClickedNode.Name += ' (Retired)';
    this.rightClickedNode.RetiredDate = new Date().toISOString();
    this.rightClickedNode.IsNewlyAdded = 'U';

    this.dataSource.data = this.dataSource.data.slice();
    this.contextMenuVisible = false;
  }

  unretireNode(): void {
    if (!this.canUnretire() || !this.rightClickedNode) return;

    const confirmUnretire = confirm('Are you sure you want to un-retire the selected Shelf Variable?\nNOTE: This action will affect all child variables');
    if (!confirmUnretire) return;

    this.rightClickedNode.Name = this.rightClickedNode.Name.replace(' (Retired)', '');
    this.rightClickedNode.RetiredDate = null;
    this.rightClickedNode.IsNewlyAdded = 'U';

    this.dataSource.data = this.dataSource.data.slice();
    this.contextMenuVisible = false;
  }

  getSelectedData(): ShelfNode[] {
    const result: ShelfNode[] = [];
    const accumulate = (node: ShelfNode) => {
      if (node.IsNewlyAdded === 'N' || node.IsNewlyAdded === 'U') {
        const copy = { ...node };
        delete copy.children;
        result.push(copy);
      }
      node.children?.forEach(accumulate);
    };
    this.dataSource.data.forEach(accumulate);
    return result;
  }

  private buildNestedTree(flat: ShelfNode[]): ShelfNode[] {
    const map: { [Id: number]: ShelfNode } = {};
    const roots: ShelfNode[] = [];

    flat.forEach(n => {
      n.children = [];
      map[n.Id] = n;
    });

    flat.forEach(n => {
      if (n.PId && map[n.PId]) {
        map[n.PId].children!.push(n);
      } else {
        roots.push(n);
      }
    });

    const setLevel = (node: ShelfNode, level: number) => {
      node.level = level;
      node.children?.forEach(child => setLevel(child, level + 1));
    };

    roots.forEach(root => setLevel(root, 0));

    return roots;
  }

  private expandAllNodes(nodes: ShelfNode[]): void {
    nodes.forEach(node => {
      this.treeControl.expand(node);
      if (node.children && node.children.length > 0) {
        this.expandAllNodes(node.children);
      }
    });
  }

  private findParent(nodes: ShelfNode[], target: ShelfNode): ShelfNode | null {
    for (const node of nodes) {
      if (node.children?.some(child => child.Id === target.Id)) {
        return node;
      }
      const parent = node.children ? this.findParent(node.children, target) : null;
      if (parent) return parent;
    }
    return null;
  }

  isUniqueNameInSiblings(parent: ShelfNode | null, name: string, excludeId?: number): boolean {
    if (!parent) {
      return !this.dataSource.data.some(n => n.Name.trim().toLowerCase() === name.toLowerCase() && n.Id !== excludeId);
    }
    return !parent.children?.some(c => c.Name.trim().toLowerCase() === name.toLowerCase() && c.Id !== excludeId);
  }

  private generateNewNodeId(parent: ShelfNode): number {
    const childIds = parent.children?.map(c => c.Id) || [];
    const maxId = childIds.length ? Math.max(...childIds) : parent.Id * 1000;
    return maxId + 1;
  }

  private sortChildrenByName(parent: ShelfNode): void {
    if (parent.children) {
      parent.children.sort((a, b) => a.Name.localeCompare(b.Name));
    }
  }

  // Permissions checkers below:

  canAdd(): boolean {
    if (this.userAccess !== 'S') return false;
    if (!this.rightClickedNode) return false;
    return this.rightClickedNode.AllowAdd === 'Y' || this.rightClickedNode.AllowAdd === 'T';
  }

  canEdit(): boolean {
    if (this.userAccess !== 'S') return false;
    if (!this.rightClickedNode) return false;
    return this.rightClickedNode.level !== 0 && !this.rightClickedNode.RetiredDate;
  }

  canDelete(): boolean {
    if (this.userAccess !== 'S') return false;
    if (!this.rightClickedNode) return false;
    return this.rightClickedNode.IsNewlyAdded === 'N' && !this.rightClickedNode.RetiredDate;
  }

  canRetire(): boolean {
    if (this.userAccess !== 'S') return false;
    if (!this.rightClickedNode) return false;
    if (this.rightClickedNode.RetiredDate) return false;
    const parent = this.findParent(this.dataSource.data, this.rightClickedNode);
    if (!parent) return false;
    const parentAllowAdd = parent.AllowAdd || '';
    return (parentAllowAdd === 'Y' || parentAllowAdd === 'T') && this.rightClickedNode.optional === 'Y';
  }

  canUnretire(): boolean {
    if (this.userAccess !== 'S') return false;
    if (!this.rightClickedNode) return false;
    return !!this.rightClickedNode.RetiredDate;
  }
}



<div class="shelf-wrapper">
  <div class="tree-panel">
    <h3>{{ title }}</h3>

    <mat-tree [dataSource]="dataSource" [treeControl]="treeControl" class="tree-root">
      <mat-tree-node *matTreeNodeDef="let node" class="node-line"
        [class.selected]="node === selectedNode"
        [ngStyle]="{ 'margin-left.px': (node.level || 0) * 20 }"
        (click)="onSelect(node)"
        (contextmenu)="onRightClick($event, node)"
      >
        <button mat-icon-button disabled></button>
        <mat-icon class="node-icon">insert_drive_file</mat-icon>
        {{ node.Name }}
      </mat-tree-node>

      <mat-nested-tree-node *matTreeNodeDef="let node; when: hasChild" class="node-line"
        [class.selected]="node === selectedNode"
        [ngStyle]="{ 'margin-left.px': (node.level || 0) * 20 }"
        (click)="onSelect(node)"
        (contextmenu)="onRightClick($event, node)"
      >
        <div class="node-content">
          <button mat-icon-button matTreeNodeToggle>
            <mat-icon>{{ treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right' }}</mat-icon>
          </button>
          <mat-icon class="node-icon">folder</mat-icon>
          {{ node.Name }}
        </div>
        <div *ngIf="treeControl.isExpanded(node)">
          <ng-container matTreeNodeOutlet></ng-container>
        </div>
      </mat-nested-tree-node>
    </mat-tree>
  </div>

  <div *ngIf="selectedNode && (showLimits || showChecks)" class="form-panel">
    <h4>Checks / Limits</h4>

    <div *ngIf="showLimits" class="form-section">
      <mat-form-field appearance="outline" class="limit-field">
        <mat-label>Min</mat-label>
        <input matInput [(ngModel)]="selectedNode.MainMin" (change)="updateValue('min', selectedNode.MainMin)" [disabled]="disableMinMax" />
      </mat-form-field>

      <mat-form-field appearance="outline" class="limit-field">
        <mat-label>Max</mat-label>
        <input matInput [(ngModel)]="selectedNode.MainMax" (change)="updateValue('max', selectedNode.MainMax)" [disabled]="disableMinMax" />
      </mat-form-field>
    </div>

    <div *ngIf="showChecks" class="form-section">
      <mat-form-field appearance="outline" class="limit-field">
        <mat-label>Soft</mat-label>
        <input matInput [(ngModel)]="selectedNode.MainSoftCheck" (change)="updateValue('soft', selectedNode.MainSoftCheck)" />
      </mat-form-field>

      <mat-form-field appearance="outline" class="limit-field">
        <mat-label>Hard</mat-label>
        <input matInput [(ngModel)]="selectedNode.MainHardCheck" (change)="updateValue('hard', selectedNode.MainHardCheck)" />
      </mat-form-field>
    </div>
  </div>
</div>

<!-- Right-click context menu -->
<div class="rMenu" *ngIf="contextMenuVisible" [ngStyle]="{ top: contextY + 'px', left: contextX + 'px' }" >
  <ul>
    <li><button [disabled]="!canAdd()" (click)="openAddDialog()">Add Variable</button></li>
    <li><button [disabled]="!canEdit()" (click)="openEditDialog()">Edit Variable</button></li>
    <li><button [disabled]="!canDelete()" (click)="deleteNode()">Delete Variable</button></li>
    <li><button [disabled]="!canRetire()" (click)="retireNode()">Retire</button></li>
    <li><button [disabled]="!canUnretire()" (click)="unretireNode()">Unretire</button></li>
  </ul>
</div>



.shelf-wrapper {
  display: flex;
  flex-direction: row;
  height: 100%;
  padding: 12px;
  gap: 20px;
  font-family: Arial, sans-serif;
}

.tree-panel {
  flex: 1;
  max-width: 400px;
  border: 1px solid #ccc;
  background-color: #fafafa;
  border-radius: 6px;
  overflow-y: auto;
  height: 500px;
}

.tree-root {
  padding: 8px;
}

.node-line {
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 4px 8px;
  user-select: none;
  transition: background-color 0.2s ease;
}

.node-line.selected {
  background-color: #bbdefb;
}

.node-line:hover {
  background-color: #e3f2fd;
}

.node-icon {
  margin-right: 8px;
  color: #3f51b5;
}

.form-panel {
  flex: 1;
  max-width: 350px;
  border: 1px solid #ccc;
  background-color: #fff;
  border-radius: 6px;
  padding: 16px;
}

.form-section {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.limit-field {
  flex: 1;
}

.rMenu {
  position: fixed;
  z-index: 10000;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  padding: 8px 0;
  width: 180px;
}

.rMenu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.rMenu ul li {
  margin: 0;
  padding: 0;
}

.rMenu button {
  width: 100%;
  text-align: left;
  padding: 8px 16px;
  border: none;
  background: none;
  cursor: pointer;
  font-size: 14px;
  color: #444;
}

.rMenu button:disabled {
  color: #aaa;
  cursor: default;
}

.rMenu button:not(:disabled):hover {
  background-color: #e3f2fd;
}



import { Component, Inject } from '@angular/core';
import { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';

export interface ShelfVarDialogData {
  mode: 'add' | 'edit';
  initialName: string;
}

@Component({
  selector: 'app-shelf-var-dialog',
  templateUrl: './shelf-var-dialog.component.html',
  styleUrls: ['./shelf-var-dialog.component.css'],
})
export class ShelfVarDialogComponent {
  name: string;

  constructor(
    public dialogRef: MatDialogRef<ShelfVarDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: ShelfVarDialogData
  ) {
    this.name = data.initialName || '';
  }

  onCancel(): void {
    this.dialogRef.close();
  }

  onConfirm(): void {
    const trimmedName = this.name.trim();
    if (!trimmedName) {
      alert('Name cannot be empty.');
      return;
    }
    this.dialogRef.close(trimmedName);
  }
}
<h2 mat-dialog-title>
  {{ data.mode === 'add' ? 'Add Shelf Variable' : 'Edit Shelf Variable' }}
</h2>

<div mat-dialog-content>
  <mat-form-field appearance="fill" class="full-width">
    <mat-label>Shelf Variable Name</mat-label>
    <input matInput [(ngModel)]="name" />
  </mat-form-field>
</div>

<div mat-dialog-actions align="end">
  <button mat-button (click)="onCancel()">Cancel</button>
  <button mat-raised-button color="primary" (click)="onConfirm()">
    {{ data.mode === 'add' ? 'Add' : 'Save' }}
  </button>
</div>
