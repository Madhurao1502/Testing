// assignment-dialog.component.ts - UPDATED WITH AUTOCOMPLETE
import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { HttpClient } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { Observable, of, firstValueFrom } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, map, catchError } from 'rxjs/operators';

export interface AssignmentDialogData {
  storeNumber: string;
  storeName: string;
  taskNumber?: string;
  taskName?: string;
  iriWeek: string;
  territoryId: string;
  positionNumber?: string;
  mode: 'StoreLevel' | 'TaskLevel' | 'ClusterLevel';
}

interface NameOption {
  emp_name: string;
  emp_id: string;
  label: string;
  value: string;
  id: string;
}

@Component({
  selector: 'app-assignment-dialog',
  template: `
    <h2 mat-dialog-title>{{getDialogTitle()}}</h2>
    
    <mat-dialog-content class="assignment-dialog-content">
      <!-- Filter Section -->
      <div class="filter-section" [formGroup]="filterForm">
        <div class="filter-row">
          <mat-form-field appearance="outline">
            <mat-label>IRI Week</mat-label>
            <input matInput [value]="data.iriWeek" readonly>
          </mat-form-field>
          
          <mat-form-field appearance="outline">
            <mat-label>Territory</mat-label>
            <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
              <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
                {{territory.territory_name}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>
        
        <div class="filter-row">
          <!-- First Name Autocomplete -->
          <mat-form-field appearance="outline">
            <mat-label>First Name</mat-label>
            <input matInput 
                   formControlName="firstName" 
                   placeholder="Search by first name..."
                   [matAutocomplete]="firstNameAuto">
            <mat-autocomplete #firstNameAuto="matAutocomplete"
                              (optionSelected)="onFirstNameSelected($event)"
                              [displayWith]="displayFn">
              <mat-option *ngFor="let option of filteredFirstNames | async" [value]="option">
                {{option.label}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          
          <!-- Last Name Autocomplete -->
          <mat-form-field appearance="outline">
            <mat-label>Last Name</mat-label>
            <input matInput 
                   formControlName="lastName" 
                   placeholder="Search by last name..."
                   [matAutocomplete]="lastNameAuto">
            <mat-autocomplete #lastNameAuto="matAutocomplete"
                              (optionSelected)="onLastNameSelected($event)"
                              [displayWith]="displayFn">
              <mat-option *ngFor="let option of filteredLastNames | async" [value]="option">
                {{option.label}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          
          <button mat-raised-button color="primary" (click)="searchFsrs()" [disabled]="isLoading">
            <mat-icon>search</mat-icon>
            Search
          </button>
        </div>
      </div>

      <!-- Loading Indicator -->
      <div *ngIf="isLoading" class="loading-container">
        <mat-spinner diameter="30"></mat-spinner>
        <span>Loading FSRs...</span>
      </div>

      <!-- FSR Table -->
      <div class="table-container" *ngIf="!isLoading">
        <mat-table [dataSource]="fsrDataSource" class="fsr-table">
          
          <!-- Action Columns (conditional based on mode) -->
          <ng-container matColumnDef="assign_all" *ngIf="showColumn('assign_all')">
            <mat-header-cell *matHeaderCellDef>Assign All</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="primary" (click)="assignTask(fsr, 2)">
                Assign All
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="unassign_all" *ngIf="showColumn('unassign_all')">
            <mat-header-cell *matHeaderCellDef>Unassign All</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="warn" (click)="assignTask(fsr, 4)">
                Unassign All
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="assign" *ngIf="showColumn('assign')">
            <mat-header-cell *matHeaderCellDef>Assign</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="primary" (click)="assignTask(fsr, 1)">
                Assign
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="unassign" *ngIf="showColumn('unassign')">
            <mat-header-cell *matHeaderCellDef>Unassign</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="warn" (click)="assignTask(fsr, 3)">
                Unassign
              </button>
            </mat-cell>
          </ng-container>

          <!-- FSR Information Columns -->
          <ng-container matColumnDef="name">
            <mat-header-cell *matHeaderCellDef>Name</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.last_name}}, {{fsr.first_name}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="address">
            <mat-header-cell *matHeaderCellDef>Address</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.addr_line1}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="assigned_hrs">
            <mat-header-cell *matHeaderCellDef>Assigned Hrs</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.assigned_hrs}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="max_hrs">
            <mat-header-cell *matHeaderCellDef>Max Hours</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.max_hrs}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="cluster">
            <mat-header-cell *matHeaderCellDef>Cluster</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.position_name}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="contact">
            <mat-header-cell *matHeaderCellDef>Contact</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <div>{{fsr.phone}}</div>
              <div><a href="mailto:{{fsr.email}}">{{fsr.email}}</a></div>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="getDisplayedColumns()"></mat-header-row>
          <mat-row *matRowDef="let row; columns: getDisplayedColumns()"></mat-row>
        </mat-table>

        <div *ngIf="fsrDataSource.data.length === 0 && !isLoading" class="no-data">
          No FSRs found. Please adjust your search criteria.
        </div>
      </div>
    </mat-dialog-content>
    
    <mat-dialog-actions align="end">
      <button mat-button (click)="onClose()">Close</button>
    </mat-dialog-actions>
  `,
  styles: [`
    .assignment-dialog-content {
      max-height: 70vh;
      overflow-y: auto;
      width: 100%;
    }

    .filter-section {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #f5f5f5;
      border-radius: 4px;
    }

    .filter-row {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 16px;
    }

    .filter-row mat-form-field {
      flex: 1;
    }

    .loading-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 40px;
    }

    .table-container {
      max-height: 400px;
      overflow-y: auto;
    }

    .fsr-table {
      width: 100%;
    }

    .no-data {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    /* Autocomplete styling */
    .mat-autocomplete-panel {
      max-height: 200px !important;
    }

    .mat-option {
      padding: 12px 16px;
      line-height: 1.2;
    }
  `]
})
export class AssignmentDialogComponent implements OnInit {
  filterForm: FormGroup;
  territories: any[] = [];
  fsrDataSource = new MatTableDataSource<any>([]);
  isLoading = false;

  // Autocomplete observables
  filteredFirstNames: Observable<NameOption[]>;
  filteredLastNames: Observable<NameOption[]>;

  // Store selected values
  selectedFirstNameId: string = '';
  selectedLastNameId: string = '';

  constructor(
    private dialogRef: MatDialogRef<AssignmentDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: AssignmentDialogData,
    private fb: FormBuilder,
    private http: HttpClient,
    @Inject('BASE_URL') private baseUrl: string
  ) {
    this.filterForm = this.fb.group({
      territory: [data.territoryId],
      firstName: [''],
      lastName: ['']
    });
  }

  async ngOnInit(): Promise<void> {
    await this.loadTerritories();
    this.setupAutocomplete();
    await this.loadCurrentAssignment();
  }

  private setupAutocomplete(): void {
    // Setup First Name Autocomplete
    this.filteredFirstNames = this.filterForm.get('firstName')!.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => {
        if (typeof value === 'string' && value.length >= 2) {
          return this.searchFirstNames(value);
        } else {
          return of([]);
        }
      })
    );

    // Setup Last Name Autocomplete
    this.filteredLastNames = this.filterForm.get('lastName')!.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => {
        if (typeof value === 'string' && value.length >= 2) {
          return this.searchLastNames(value);
        } else {
          return of([]);
        }
      })
    );
  }

  // Search First Names via API
  private searchFirstNames(searchText: string): Observable<NameOption[]> {
    const params = {
      iriWeek: this.data.iriWeek,
      territory: this.filterForm.get('territory')?.value || this.data.territoryId,
      searchText: searchText,
      nameType: 'first_name'
    };

    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map(response => response.map(item => ({
          emp_name: item.emp_name,
          emp_id: item.emp_id,
          label: item.emp_name,
          value: item.emp_name,
          id: item.emp_id
        }))),
        catchError(error => {
          console.error('Error fetching first names:', error);
          return of([]);
        })
      );
  }

  // Search Last Names via API
  private searchLastNames(searchText: string): Observable<NameOption[]> {
    const params = {
      iriWeek: this.data.iriWeek,
      territory: this.filterForm.get('territory')?.value || this.data.territoryId,
      searchText: searchText,
      nameType: 'last_name'
    };

    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map(response => response.map(item => ({
          emp_name: item.emp_name,
          emp_id: item.emp_id,
          label: item.emp_name,
          value: item.emp_name,
          id: item.emp_id
        }))),
        catchError(error => {
          console.error('Error fetching last names:', error);
          return of([]);
        })
      );
  }

  // Handle First Name Selection
  onFirstNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedFirstNameId = selectedOption.id;
    console.log('First name selected:', selectedOption);
    
    // Auto-search when name is selected
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  // Handle Last Name Selection
  onLastNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedLastNameId = selectedOption.id;
    console.log('Last name selected:', selectedOption);
    
    // Auto-search when name is selected
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  // Display function for autocomplete
  displayFn(option: NameOption): string {
    return option ? option.label : '';
  }

  // Handle territory change - clear name fields
  onTerritoryChange(): void {
    this.filterForm.patchValue({
      firstName: '',
      lastName: ''
    });
    this.selectedFirstNameId = '';
    this.selectedLastNameId = '';
    this.fsrDataSource.data = [];
  }

  getDialogTitle(): string {
    const location = this.data.mode === 'ClusterLevel' 
      ? `Cluster: ${this.data.positionNumber} | Store: ALL`
      : `Store: ${this.data.storeName} (${this.data.storeNumber})`;
    
    const task = this.data.taskName 
      ? ` | Task: ${this.data.taskName}`
      : ' | Task: ALL';
    
    return `Assignment for ${location}${task}`;
  }

  getDisplayedColumns(): string[] {
    const columns = [];
    
    // Add action columns based on mode
    if (this.data.mode === 'StoreLevel') {
      columns.push('assign_all', 'unassign_all');
    } else if (this.data.mode === 'TaskLevel') {
      columns.push('assign', 'unassign');
    } else if (this.data.mode === 'ClusterLevel') {
      columns.push('assign_to_cluster', 'unassign_from_cluster');
    }
    
    // Add info columns
    columns.push('name', 'address', 'assigned_hrs', 'max_hrs', 'cluster', 'contact');
    
    return columns;
  }

  showColumn(columnName: string): boolean {
    return this.getDisplayedColumns().includes(columnName);
  }

  private async loadTerritories(): Promise<void> {
    try {
      this.territories = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      );
    } catch (error) {
      console.error('Error loading territories:', error);
    }
  }

  private async loadCurrentAssignment(): Promise<void> {
    this.isLoading = true;
    try {
      const params = {
        iri_week: this.data.iriWeek,
        store_number: this.data.storeNumber,
        task_number: this.data.taskNumber || '',
        assignment_mode: this.data.mode,
        position_number: this.data.positionNumber || '',
        countryId: '1' // Get from service
      };

      const response = await firstValueFrom(
        this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCurrentAssignment', params)
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error loading current assignment:', error);
    } finally {
      this.isLoading = false;
    }
  }

  async searchFsrs(): Promise<void> {
    this.isLoading = true;
    try {
      const formValue = this.filterForm.value;
      
      // Get the actual text values from form controls
      const firstNameValue = typeof formValue.firstName === 'string' 
        ? formValue.firstName 
        : (formValue.firstName?.value || '');
      
      const lastNameValue = typeof formValue.lastName === 'string' 
        ? formValue.lastName 
        : (formValue.lastName?.value || '');

      const params = {
        iri_week: this.data.iriWeek,
        territory_id: formValue.territory,
        first_name: firstNameValue,
        last_name: lastNameValue,
        position_number: this.data.positionNumber || '',
        countryId: '1',
        area: '23'
      };

      console.log('Searching FSRs with params:', params);

      const response = await firstValueFrom(
        this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsrForAssignment', params)
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error searching FSRs:', error);
      this.fsrDataSource.data = [];
    } finally {
      this.isLoading = false;
    }
  }

  async assignTask(fsr: any, action: number): Promise<void> {
    const actionNames = {
      1: 'assign current task to',
      2: 'assign all tasks to',
      3: 'unassign current task from',
      4: 'unassign all tasks from',
      5: 'assign to cluster',
      6: 'unassign from cluster'
    };

    const message = `Are you sure you want to ${actionNames[action]} ${fsr.first_name} ${fsr.last_name}?`;
    
    if (!confirm(message)) return;

    try {
      const params = {
        iri_week: this.data.iriWeek,
        territory_id: this.filterForm.get('territory')?.value,
        store_number: this.data.storeNumber,
        emp_id: fsr.emp_id,
        task_number: this.data.taskNumber || '',
        position_number: this.data.positionNumber || '',
        action: action,
        assignment_mode: this.data.mode,
        countryId: '1'
      };

      await firstValueFrom(
        this.http.post(this.baseUrl + 'api/TaskAssinment/SaveAssignment', params)
      );

      // Refresh the assignment list
      await this.loadCurrentAssignment();
      
      // Clear search fields but keep the typed values
      // Don't clear - let user search again if needed
      
      alert('New Assignment saved successfully.');
      
    } catch (error) {
      console.error('Error saving assignment:', error);
      alert('Error while saving assignments.');
    }
  }

  onClose(): void {
    this.dialogRef.close(true); // Return true to indicate refresh needed
  }
}
