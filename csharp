Dynamic Week Type Class Assignment for Store Table
How the Week Type Classes Are Applied
The CSS classes week-current, week-future, and week-previous are dynamically applied to the <mat-table> element based on the current week type from CommonService.

1. UPDATE store-table.component.html (Add Dynamic Class)
xml
<div class="table-container">
  <mat-card class="table-card" [ngClass]="getWeekTypeClass()">
    <mat-card-header>
      <!-- Search Bar -->
      <div class="search-container">
        <mat-form-field appearance="outline" class="search-field">
          <mat-label>Search stores...</mat-label>
          <input matInput [formControl]="searchControl" 
                placeholder="Search by store number, name, address, city, state, assigned to, etc.">
          <mat-icon matPrefix>search</mat-icon>
          <button mat-button *ngIf="searchControl.value" matSuffix mat-icon-button (click)="clearSearch()">
            <mat-icon>clear</mat-icon>
          </button>
        </mat-form-field>
      </div>
    </mat-card-header>
    
    <mat-card-content>
      <div class="table-wrapper">
        <!-- UPDATED: Add dynamic week type class to table -->
        <mat-table #table 
                   [dataSource]="dataSource" 
                   matSort 
                   class="store-table mat-elevation-2"
                   [ngClass]="getWeekTypeTableClass()">
          
          <!-- All your existing column definitions remain the same -->
          <!-- Store Number Column -->
          <ng-container matColumnDef="store_number" *ngIf="isColumnVisible('store_number')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">
              <button mat-icon-button 
                      [disabled]="isExpandingAll"
                      (click)="expandAllRows()" 
                      [title]="allExpanded ? 'Collapse All' : 'Expand All'"
                      class="expand-all-btn">
                <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
              </button>
              Store #
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
              <span class="caret" [class.clicked]="isRowExpanded(element)">â–¼</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Territory Column -->
          <ng-container matColumnDef="territory" *ngIf="isColumnVisible('territory')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Terr</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.Territory}}</mat-cell>
          </ng-container>

          <!-- Position Number Column -->
          <ng-container matColumnDef="position_number" *ngIf="isColumnVisible('position_number')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Position #</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.PositionNumber}}</mat-cell>
          </ng-container>

          <!-- BDF Column -->
          <ng-container matColumnDef="bdf" *ngIf="isColumnVisible('bdf')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">BDF</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.BDF}}</mat-cell>
          </ng-container>

          <!-- Outlet Column -->
          <ng-container matColumnDef="outlet" *ngIf="isColumnVisible('outlet')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Outlet</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.Outlet}}</mat-cell>
          </ng-container>

          <!-- All other existing columns... -->
          
          <!-- Header and Data Rows -->
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row *matRowDef="let row; columns: displayedColumns; let i = index"
                  class="table-row"
                  [cdkDetailRow]="row" 
                  [cdkDetailRowTpl]="tpl"
                  (toggleChange)="GetSubgridData($event, row)"
                  (dataLoadRequest)="onDataLoadRequest($event)"
                  matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator [pageSizeOptions]="[50, 100, 150, 200]" 
                    showFirstLastButtons
                    class="table-paginator">
      </mat-paginator>
    </mat-card-content>
  </mat-card>
</div>
2. ADD to store-table.component.ts (Class Generation Methods)
typescript
export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  // ... all your existing properties ...

  // Week type tracking (you should already have this)
  currentWeekType: 'current' | 'future' | 'previous' = 'current';

  // ... all your existing methods ...

  // EXISTING: Week type class for card (you already have this)
  getWeekTypeClass(): string {
    return `week-${this.currentWeekType}`;
  }

  // ADD: Week type class specifically for table min-width
  getWeekTypeTableClass(): string {
    return `week-${this.currentWeekType}`;
  }

  // ADD: Get current table min-width for debugging/info
  getCurrentTableMinWidth(): number {
    switch (this.currentWeekType) {
      case 'current':
        return 1520;
      case 'future':
        return 1320;
      case 'previous':
        return 2100;
      default:
        return 1200;
    }
  }

  // ADD: Get week type display info
  getWeekTypeInfo(): { name: string, minWidth: number, columns: number } {
    switch (this.currentWeekType) {
      case 'current':
        return { 
          name: 'Current Week Tasks', 
          minWidth: 1520, 
          columns: this.currentWeekColumns.length 
        };
      case 'future':
        return { 
          name: 'Future Week Planning', 
          minWidth: 1320, 
          columns: this.futureWeekColumns.length 
        };
      case 'previous':
        return { 
          name: 'Previous Week History', 
          minWidth: 2100, 
          columns: this.previousWeekColumns.length 
        };
      default:
        return { 
          name: 'Store Data', 
          minWidth: 1200, 
          columns: this.baseColumns.length 
        };
    }
  }

  ngOnInit(): void {
    // ... your existing ngOnInit code ...

    // Subscribe to week type changes
    this.commonService.weekType$
      .pipe(takeUntil(this.destroy$))
      .subscribe(weekType => {
        console.log('Week type changed to:', weekType);
        this.currentWeekType = weekType; // This is key - updates the currentWeekType
        this.updateAvailableColumns();
        this.updateDisplayedColumns();
        
        // Log table info for debugging
        const tableInfo = this.getWeekTypeInfo();
        console.log(`Table configured for ${tableInfo.name}:`, {
          minWidth: `${tableInfo.minWidth}px`,
          columns: tableInfo.columns,
          cssClass: this.getWeekTypeTableClass()
        });
        
        this.cdr.detectChanges();
      });

    // ... rest of your existing ngOnInit code ...
  }

  // ... rest of your existing methods ...
}
3. HOW IT WORKS - The Flow:
Step 1: CommonService Determines Week Type
typescript
// In CommonService.applyFilters()
const currentIRIWeek = this.getCurrentIRIWeek();
const payloadIRIWeek = payload.iriWeek;

if (payloadIRIWeek === currentIRIWeek) {
  weekType = 'current';
} else if (payloadIRIWeek > currentIRIWeek) {
  weekType = 'future';
} else {
  weekType = 'previous';
}

this.weekTypeSubject.next(weekType); // Emits to weekType$ observable
Step 2: Store Table Subscribes to Week Type Changes
typescript
// In store-table.component.ts ngOnInit()
this.commonService.weekType$.subscribe(weekType => {
  this.currentWeekType = weekType; // Updates the component property
  // This triggers Angular change detection
});
Step 3: Template Uses Dynamic Class
xml
<!-- Angular evaluates [ngClass] on every change detection cycle -->
<mat-table [ngClass]="getWeekTypeTableClass()">
Step 4: CSS Rules Apply Based on Class
css
/* Angular adds/removes these classes dynamically */
.store-table.week-current { min-width: 1520px; }
.store-table.week-future { min-width: 1320px; }
.store-table.week-previous { min-width: 2100px; }
4. DEBUGGING - Add Console Logs (Optional)
typescript
// ADD to getWeekTypeTableClass() for debugging
getWeekTypeTableClass(): string {
  const className = `week-${this.currentWeekType}`;
  console.log(`Table class applied: ${className}`);
  return className;
}
5. ALTERNATIVE: Inline Style Approach (If Classes Don't Work)
If the CSS classes don't work for some reason, you can use inline styles:

xml
<mat-table #table 
           [dataSource]="dataSource" 
           matSort 
           class="store-table mat-elevation-2"
           [style.min-width.px]="getCurrentTableMinWidth()">
Summary of the Complete Flow:
text
1. User applies filters â†’ CommonService.applyFilters()
2. CommonService compares IRI weeks â†’ determines week type
3. CommonService.weekTypeSubject.next(weekType) â†’ emits change
4. StoreTable subscribes â†’ this.currentWeekType = weekType
5. Angular change detection â†’ evaluates [ngClass]="getWeekTypeTableClass()"
6. getWeekTypeTableClass() returns 'week-current' or 'week-future' or 'week-previous'
7. CSS applies: .store-table.week-current { min-width: 1520px; }
8. Table gets appropriate minimum width for horizontal scroll
Expected Results:
âœ… Current Week: Table min-width = 1520px, ~15 columns

âœ… Future Week: Table min-width = 1320px, ~13 columns

âœ… Previous Week: Table min-width = 2100px, ~20 columns

The key is that this.currentWeekType gets updated when the CommonService emits week type changes, and Angular's change detection automatically applies the correct CSS class! ðŸŽ¯
