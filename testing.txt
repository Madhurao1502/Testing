columnVisibility: boolean[] = Array(10).fill(true); // Track visibility of each column

expandedRows: { [storeNumber: string]: boolean } = {}; // Track expanded state for each StoreNumber
// Pagination State
currentPage: number = 1;
itemsPerPage: number = 10;
totalPages: number = 0;
rowsPerPageOptions: number[] = [5, 10, 20, 50];

filters = {
  w1c_ov_Doller_min: null,
  w1c_ov_Doller_max: null,
  w1s_ov_Doller_min: null,
  w1s_ov_Doller_max: null,
  w2c_ov_Doller_min: null,
  w2c_ov_Doller_max: null,
  w2s_ov_Doller_min: null,
  w2s_ov_Doller_max: null,
};

// Filter Dropdown State
filterDropdowns = {
  w1c_ov_Doller: false,
  w1s_ov_Doller: false,
  w2c_ov_Doller: false,
  w2s_ov_Doller: false,
};

// Toggle the filter dropdown
toggleFilterDropdown(column: string) {
  this.filterDropdowns[column] = !this.filterDropdowns[column];
}

// Apply filters based on min and max values
applyFilters() {
  this.currentPage = 1; // Reset to the first page when filters are applied
  this.updatePagination();
}

// Sorting State
sortColumn: string | null = null;
sortDirection: 'asc' | 'desc' | '' = ''; // '' means no sorting
ngOnInit() {
  this.expandAll(); // Expand all rows on initialization
  this.updatePagination();
  // document.addEventListener('click', this.handleClickOutside.bind(this));

}

// ngOnDestroy() {
//   document.removeEventListener('click', this.handleClickOutside.bind(this));
// }

handleClickOutside(event: MouseEvent) {
  const target = event.target as HTMLElement;
  const isFilterIcon = target.classList.contains('filter-icon');
  const isDropdown = target.closest('.filter-dropdown') !== null;

  if (!isFilterIcon && !isDropdown) {
    // Close all filter dropdowns
    Object.keys(this.filterDropdowns).forEach(key => {
      this.filterDropdowns[key] = false;
    });
  }
}

// Expand all rows initially and set expanded state for each StoreNumber
expandAll() {
  this.data.forEach(item => {
    if (item.TaskName === 'ALL') {
      this.expandedRows[item.StoreNumber] = true;
    }
  });
}

// Collapse all rows
collapseAll() {
  Object.keys(this.expandedRows).forEach(storeNumber => {
    this.expandedRows[storeNumber] = false;
  });
}

// Toggle the row expansion for a specific StoreNumber
toggleRow(storeNumber: string) {
  this.expandedRows[storeNumber] = !this.expandedRows[storeNumber];
}

// Toggle visibility of a specific column
toggleColumn(index: number) {

  this.columnVisibility[index] = !this.columnVisibility[index];
}

// Calculate the colspan needed for the placeholder cell to keep structure centered
getPlaceholderColspan(): number {
  return this.columnVisibility.slice(0, 10).filter(isVisible => isVisible).length || 1; // Minimum colspan of 1
}

getColumnName(index: number): string { const columnNames = [ 'Region', 'Territory', 'Store Number', 'Store Name', 'Address', 'City', 'State', 'Task Name', 'FSR', 'Guaranteed Miles' ]; return columnNames[index]; }

trackByIndex(index: number, item: any): number {
  return index;
}

// Calculate the colspan for expanded rows after Task Name and FSR columns
calculateChildColspan(): number {
  // Count visible columns after "Task Name" (index 7) and "FSR" (index 8)
  const remainingVisibleColumns = this.columnVisibility.slice(9).filter(isVisible => isVisible).length;
  return remainingVisibleColumns > 0 ? remainingVisibleColumns : 1; // Minimum colspan of 1
}




// Handle page change
goToPage(page: number) {
  if (page < 1 || page > this.totalPages) return;
  this.currentPage = page;
}



getDisplayedData() {
  const filteredData = this.getFilteredData();

  // Apply sorting if a sort column is set
  if (this.sortColumn) {
    filteredData.sort((a, b) => {
      const aValue = a[this.sortColumn];
      const bValue = b[this.sortColumn];

      const aNum = parseFloat(aValue) || 0;
      const bNum = parseFloat(bValue) || 0;

      return this.sortDirection === 'asc' ? aNum - bNum : bNum - aNum;
    });
  }

  // Paginate the data
  const startIndex = (this.currentPage - 1) * this.itemsPerPage;
  const endIndex = startIndex + this.itemsPerPage;
  return filteredData.slice(startIndex, endIndex);
}

// Handle sorting when a column header is clicked
sortData(column: string) {
  if (this.sortColumn === column) {
    // Toggle sorting direction correctly
    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
  } else {
    this.sortColumn = column;
    this.sortDirection = 'asc';
  }
  this.currentPage = 1; // Reset to the first page when sorting
  this.updatePagination();
}

// Update pagination state
updatePagination() {
  this.totalPages = Math.ceil(this.data.length / this.itemsPerPage);
}

getFilteredData() {
  return this.data.filter(item => {
    // Remove commas and parse the dollar values
    const w1c_ov_Doller = parseFloat(item.w1c_ov_Doller.replace(/,/g, '')) || 0;
    const w1s_ov_Doller = parseFloat(item.w1s_ov_Doller.replace(/,/g, '')) || 0;
    const w2c_ov_Doller = parseFloat(item.w2c_ov_Doller.replace(/,/g, '')) || 0;
    const w2s_ov_Doller = parseFloat(item.w2s_ov_Doller.replace(/,/g, '')) || 0;

    return (
      (!this.filters.w1c_ov_Doller_min || w1c_ov_Doller >= this.filters.w1c_ov_Doller_min) &&
      (!this.filters.w1c_ov_Doller_max || w1c_ov_Doller <= this.filters.w1c_ov_Doller_max) &&
      (!this.filters.w1s_ov_Doller_min || w1s_ov_Doller >= this.filters.w1s_ov_Doller_min) &&
      (!this.filters.w1s_ov_Doller_max || w1s_ov_Doller <= this.filters.w1s_ov_Doller_max) &&
      (!this.filters.w2c_ov_Doller_min || w2c_ov_Doller >= this.filters.w2c_ov_Doller_min) &&
      (!this.filters.w2c_ov_Doller_max || w2c_ov_Doller <= this.filters.w2c_ov_Doller_max) &&
      (!this.filters.w2s_ov_Doller_min || w2s_ov_Doller >= this.filters.w2s_ov_Doller_min) &&
      (!this.filters.w2s_ov_Doller_max || w2s_ov_Doller <= this.filters.w2s_ov_Doller_max)
    );
  });
}

// Clear the filters for a specific column
clearFilter(column: string) {
  this.filters[`${column}_min`] = null;
  this.filters[`${column}_max`] = null;
  this.applyFilters();
}

}

