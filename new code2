Complete Angular Project Enhancement Solutions
1. Code Simplification Review
Identified Areas for Simplification:
A. Filter-Sidebar Component:

Redundant API calls for same data

Complex form subscription setup

Can be streamlined

B. Store-Table Component:

Overly complex expand/collapse logic

Duplicate data loading patterns

Can be simplified

C. Common Service:

Multiple similar API methods

Can be consolidated with generic approach

Simplified Filter-Sidebar Component:
typescript
// filter-sidebar.component.ts - SIMPLIFIED VERSION

export class FilterSidebarComponent implements OnInit, OnDestroy {
  
  // Simplified data loading
  private async loadAllData(): Promise<void> {
    try {
      this.showSpinner = true;
      
      // Load all data in parallel
      const [iriWeeks, territories, employeeData] = await Promise.all([
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')),
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')),
        firstValueFrom(this.commonService.getEmployee(this.loggeduser))
      ]);

      this.iriWeeks = iriWeeks;
      this.territories = territories;
      this.employeedata = employeeData;
      
      this.setDefaultValues();
      this.setupFormSubscriptions();
      
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      this.showSpinner = false;
    }
  }

  // Generic autocomplete method
  private setupAutocomplete<T>(controlName: string, apiEndpoint: string): void {
    this.filterForm.get(controlName)?.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() => this.showSpinner = true),
      switchMap(searchText => this.genericSearch<T>(apiEndpoint, searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(results => {
      this[`filtered${controlName.charAt(0).toUpperCase() + controlName.slice(1)}`] = results;
      this.showSpinner = false;
    });
  }

  // Generic search method
  private genericSearch<T>(endpoint: string, searchText: string): Observable<T[]> {
    if (!searchText || searchText.length < 2) return of([]);
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<T[]>(this.baseUrl + endpoint, payload)
      .pipe(catchError(() => of([])));
  }
}
2. Column Hide/Show Functionality
Enhanced Filter-Sidebar with Column Visibility:
typescript
// filter-sidebar.component.ts - ADD COLUMN VISIBILITY

export class FilterSidebarComponent implements OnInit, OnDestroy {
  
  // Column visibility options
  availableColumns = [
    { key: 'store_number', label: 'Store Number', required: true },
    { key: 'store_name', label: 'Store Name', required: true },
    { key: 'addr_line1', label: 'Address', required: false },
    { key: 'city', label: 'City', required: false },
    { key: 'state', label: 'State', required: false },
    { key: 'zip', label: 'Zip', required: false },
    { key: 'assigned_to', label: 'Assigned To', required: true },
    { key: 'task_completed', label: 'Task Completed', required: false },
    { key: 'quality', label: 'Quality', required: false },
    { key: 'cost_over', label: 'Cost Over', required: false },
    { key: 'guaranteed_miles', label: 'Miles', required: false },
    { key: 'user_comment', label: 'Comments', required: true }
  ];

  selectedColumns: string[] = [];

  @Output() columnsChanged = new EventEmitter<string[]>();

  ngOnInit(): void {
    // Initialize with default columns
    this.selectedColumns = this.availableColumns
      .filter(col => col.required || ['addr_line1', 'city', 'state'].includes(col.key))
      .map(col => col.key);
      
    // ... existing ngOnInit code
  }

  onColumnSelectionChange(): void {
    // Ensure required columns are always selected
    const requiredColumns = this.availableColumns
      .filter(col => col.required)
      .map(col => col.key);
      
    this.selectedColumns = [...new Set([...this.selectedColumns, ...requiredColumns])];
    this.columnsChanged.emit(this.selectedColumns);
  }

  isColumnRequired(columnKey: string): boolean {
    return this.availableColumns.find(col => col.key === columnKey)?.required || false;
  }
}
Updated Filter-Sidebar HTML:
xml
<!-- filter-sidebar.component.html - ADD AFTER MULTI FSR STORE CHECKBOX -->

<!-- Column Visibility Dropdown -->
<div class="checkbox-field">
  <label class="form-label">Visible Columns</label>
  <mat-form-field appearance="outline">
    <mat-label>Select Columns</mat-label>
    <mat-select multiple [(value)]="selectedColumns" (selectionChange)="onColumnSelectionChange()">
      <mat-option *ngFor="let column of availableColumns" 
                  [value]="column.key" 
                  [disabled]="column.required">
        {{column.label}}
        <span *ngIf="column.required" class="required-indicator"> *</span>
      </mat-option>
    </mat-select>
  </mat-form-field>
</div>
CSS for Column Selector:
css
/* filter-sidebar.component.css - ADD THESE STYLES */

.required-indicator {
  color: #f44336;
  font-weight: bold;
}

.mat-option[aria-disabled="true"] {
  background-color: #f5f5f5;
  color: #999;
}

.column-selector-field {
  min-width: 200px;
}
3. Table Search Functionality
Enhanced Store-Table with Search:
typescript
// store-table.component.ts - ADD SEARCH FUNCTIONALITY

export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  // Search properties
  searchControl = new FormControl('');
  originalData: any[] = [];
  isSearching = false;

  ngOnInit(): void {
    // ... existing ngOnInit code

    // Setup search functionality
    this.setupSearch();
  }

  private setupSearch(): void {
    this.searchControl.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() => {
        this.isSearching = true;
        this.showSpinner = true;
      }),
      takeUntil(this.destroy$)
    ).subscribe(searchTerm => {
      this.performSearch(searchTerm || '');
    });
  }

  private performSearch(searchTerm: string): void {
    try {
      if (!searchTerm.trim()) {
        // No search term, show all data
        this.dataSource.data = [...this.originalData];
      } else {
        // Filter data based on search term
        const filtered = this.originalData.filter(row => 
          this.matchesSearchTerm(row, searchTerm.toLowerCase())
        );
        this.dataSource.data = filtered;
      }
      
      // Reset pagination and expansion state
      if (this.paginator) {
        this.paginator.firstPage();
      }
      this.resetExpansionState();
      
    } catch (error) {
      console.error('Error performing search:', error);
    } finally {
      this.isSearching = false;
      this.showSpinner = false;
    }
  }

  private matchesSearchTerm(row: any, searchTerm: string): boolean {
    const searchableFields = [
      'StoreNumber', 'StoreName', 'AddrLine1', 'City', 'State', 
      'Zip', 'AssignedTo', 'TaskCompleted', 'Quality', 'UserComment'
    ];

    return searchableFields.some(field => {
      const value = row[field];
      return value && value.toString().toLowerCase().includes(searchTerm);
    });
  }

  clearSearch(): void {
    this.searchControl.setValue('');
  }

  // Enhanced updateDataSource to preserve original data
  private updateDataSource(data: any[]): void {
    // Store original data for search functionality
    this.originalData = [...data];
    
    // Apply current search if active
    const searchTerm = this.searchControl.value;
    if (searchTerm && searchTerm.trim()) {
      this.performSearch(searchTerm);
    } else {
      this.dataSource.data = data;
    }
    
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    this.resetExpansionState();
  }
}
Updated Store-Table HTML with Search:
xml
<!-- store-table.component.html - ADD SEARCH BAR -->

<div class="table-container">
  <mat-card class="table-card">
    <mat-card-content>
      
      <!-- Search Bar -->
      <div class="search-container">
        <mat-form-field appearance="outline" class="search-field">
          <mat-label>Search stores...</mat-label>
          <input matInput [formControl]="searchControl" 
                 placeholder="Search by store number, name, address, city, state, assigned to, etc.">
          <mat-icon matPrefix>search</mat-icon>
          <button mat-button *ngIf="searchControl.value" matSuffix mat-icon-button (click)="clearSearch()">
            <mat-icon>clear</mat-icon>
          </button>
        </mat-form-field>
        
        <div class="search-info" *ngIf="searchControl.value">
          Showing {{dataSource.data.length}} of {{originalData.length}} stores
          <span *ngIf="isSearching" class="searching-indicator">
            <mat-spinner diameter="16"></mat-spinner>
            Searching...
          </span>
        </div>
      </div>

      <div class="table-wrapper">
        <!-- Existing table code -->
      </div>
    </mat-card-content>
  </mat-card>
</div>
Search CSS:
css
/* store-table.component.css - ADD SEARCH STYLES */

.search-container {
  padding: 16px;
  background: #f8f9fa;
  border-bottom: 1px solid #dee2e6;
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
}

.search-field {
  flex: 1;
  min-width: 300px;
}

.search-info {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #666;
}

.searching-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #1976d2;
}

@media (max-width: 768px) {
  .search-container {
    flex-direction: column;
    align-items: stretch;
  }
  
  .search-field {
    min-width: auto;
  }
}
4. Comprehensive Spinner Implementation
Enhanced Spinner Service:
typescript
// shared/spinner.service.ts - CREATE NEW SERVICE

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class SpinnerService {
  private spinnerSubject = new BehaviorSubject<boolean>(false);
  public spinner$ = this.spinnerSubject.asObservable();
  
  private loadingTasks = new Set<string>();

  show(taskId: string = 'default'): void {
    this.loadingTasks.add(taskId);
    this.spinnerSubject.next(true);
  }

  hide(taskId: string = 'default'): void {
    this.loadingTasks.delete(taskId);
    if (this.loadingTasks.size === 0) {
      this.spinnerSubject.next(false);
    }
  }

  hideAll(): void {
    this.loadingTasks.clear();
    this.spinnerSubject.next(false);
  }

  isLoading(): boolean {
    return this.spinnerSubject.value;
  }
}
Updated Components with Spinner:
typescript
// store-table.component.ts - ENHANCED SPINNER USAGE

export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  constructor(
    // ... existing dependencies
    private spinnerService: SpinnerService
  ) {}

  ngOnInit(): void {
    // Subscribe to spinner state
    this.spinnerService.spinner$
      .pipe(takeUntil(this.destroy$))
      .subscribe(isLoading => {
        this.showSpinner = isLoading;
      });

    // ... existing code
  }

  private updateDataSource(data: any[]): void {
    this.spinnerService.show('table-update');
    
    try {
      // ... existing update logic
    } finally {
      this.spinnerService.hide('table-update');
    }
  }

  private performSearch(searchTerm: string): void {
    this.spinnerService.show('table-search');
    
    try {
      // ... existing search logic
    } finally {
      this.spinnerService.hide('table-search');
    }
  }

  async GetSubgridData(cdkDetailRow: CdkDetailRowDirective, rowData: any): Promise<void> {
    this.spinnerService.show(`subgrid-${rowData.StoreNumber}`);
    
    try {
      // ... existing subgrid logic
    } finally {
      this.spinnerService.hide(`subgrid-${rowData.StoreNumber}`);
    }
  }
}
Updated Filter-Sidebar with Spinner:
typescript
// filter-sidebar.component.ts - ENHANCED SPINNER

export class FilterSidebarComponent implements OnInit, OnDestroy {
  
  constructor(
    // ... existing dependencies
    private spinnerService: SpinnerService
  ) {}

  onApplyFilters(): void {
    this.spinnerService.show('apply-filters');
    
    try {
      // ... existing filter logic
      this.filtersChanged.emit(filters);
    } finally {
      // Don't hide here - let the data loading complete first
      setTimeout(() => this.spinnerService.hide('apply-filters'), 100);
    }
  }

  private genericSearch<T>(endpoint: string, searchText: string): Observable<T[]> {
    const taskId = `search-${endpoint}`;
    this.spinnerService.show(taskId);
    
    return this.http.post<T[]>(this.baseUrl + endpoint, payload).pipe(
      finalize(() => this.spinnerService.hide(taskId)),
      catchError(() => of([]))
    );
  }
}
5. Comment Editing with User Group Restrictions
Enhanced Store-Table with User Group Security:
typescript
// store-table.component.ts - ADD USER GROUP SECURITY

export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  // User permissions
  canEditComments = false;
  canDeleteComments = false;

  ngOnInit(): void {
    // ... existing code

    // Subscribe to user group status
    this.commonService.groupStatus$.subscribe(userGroups => {
      this.canEditComments = userGroups['tech'] || userGroups['admin'];
      this.canDeleteComments = userGroups['tech'] || userGroups['admin'];
    });
  }

  startCommentEdit(element: any): void {
    if (!this.canEditComments) {
      console.log('User does not have permission to edit comments');
      return;
    }
    
    element.IsCommentEditing = true;
  }

  deleteComment(element: any): void {
    if (!this.canDeleteComments) {
      console.log('User does not have permission to delete comments');
      return;
    }
    
    if (confirm('Are you sure you want to delete this comment?')) {
      this.saveComment(element, '');
    }
  }

  async saveComment(element: any, comment: string): Promise<void> {
    if (!this.canEditComments) {
      console.log('User does not have permission to save comments');
      return;
    }

    this.spinnerService.show('save-comment');
    
    try {
      await firstValueFrom(
        this.commonService.saveUserComment(element.StoreNumber, comment)
      );
      
      element.UserComment = comment;
      element.IsCommentEditing = false;
      console.log('Comment saved successfully');
      
    } catch (error) {
      console.error('Error saving comment:', error);
    } finally {
      this.spinnerService.hide('save-comment');
    }
  }
}
Updated HTML with Security:
xml
<!-- store-table.component.html - SECURE COMMENT COLUMN -->

<ng-container matColumnDef="user_comment">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Comments</mat-header-cell>
  <mat-cell *matCellDef="let element" class="comment-cell">
    <!-- View mode -->
    <div *ngIf="!element.IsCommentEditing" class="comment-view">
      <span class="comment-text" 
            [title]="element.UserComment"
            (click)="canEditComments && startCommentEdit(element); $event.stopPropagation();"
            [style.cursor]="canEditComments ? 'pointer' : 'default'">
        {{element.UserComment || (canEditComments ? 'Add comment...' : 'No comment')}}
      </span>
      
      <!-- Edit button - only show if user has permission -->
      <button *ngIf="canEditComments" 
              mat-icon-button 
              (click)="startCommentEdit(element); $event.stopPropagation();"
              class="comment-edit-btn">
        <mat-icon>edit</mat-icon>
      </button>
      
      <!-- Delete button - only show if user has permission and comment exists -->
      <button *ngIf="canDeleteComments && element.UserComment" 
              mat-icon-button 
              (click)="deleteComment(element); $event.stopPropagation();"
              class="comment-delete-btn">
        <mat-icon>delete</mat-icon>
      </button>
    </div>
    
    <!-- Edit mode - only if user has permission -->
    <div *ngIf="element.IsCommentEditing && canEditComments" class="comment-edit">
      <mat-form-field appearance="outline" class="comment-field">
        <textarea matInput
                  [value]="element.UserComment"
                  placeholder="Enter comment..."
                  (keydown)="onCommentKeydown($event, element)"
                  #commentInput
                  rows="2"
                  maxlength="500">
        </textarea>
      </mat-form-field>
      <div class="comment-actions">
        <button mat-icon-button 
                color="primary"
                (click)="saveComment(element, commentInput.value); $event.stopPropagation();">
          <mat-icon>check</mat-icon>
        </button>
        <button mat-icon-button 
                (click)="cancelCommentEdit(element); $event.stopPropagation();">
          <mat-icon>close</mat-icon>
        </button>
      </div>
    </div>
  </mat-cell>
</ng-container>
6. Enhanced Assigned To Display (Multiple Names)
Updated Common Service:
typescript
// common.service.ts - ENHANCED ASSIGNED TO DISPLAY

private getAssignedToDisplay(row: any): string {
  if (!row.FirstName || !row.LastName) {
    return 'NOT ASSIGNED';
  }

  // Handle multiple names separated by commas
  const firstNames = row.FirstName.split(',').map(name => name.trim());
  const lastNames = row.LastName.split(',').map(name => name.trim());

  if (firstNames.length !== lastNames.length) {
    console.warn('Mismatch between first names and last names count');
    return `${row.FirstName} ${row.LastName}`;
  }

  // Create full names
  const fullNames = firstNames.map((firstName, index) => {
    const lastName = lastNames[index] || '';
    return `${firstName} ${lastName}`.trim();
  });

  return fullNames.join(', ');
}
Enhanced Assigned To Column:
typescript
// store-table.component.ts - ADD ASSIGNED TO HELPER METHODS

export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  // Get assigned to display with proper formatting
  getAssignedToDisplay(assignedTo: string): string {
    if (!assignedTo || assignedTo === 'NOT ASSIGNED') {
      return 'NOT ASSIGNED';
    }

    // Split by comma and take only first 2 names for display
    const names = assignedTo.split(',').map(name => name.trim());
    
    if (names.length <= 2) {
      return assignedTo;
    }

    // Show first 2 names and add "..." for more
    return `${names}, ${names}...`;
  }

  getAssignedToTooltip(assignedTo: string): string {
    if (!assignedTo || assignedTo === 'NOT ASSIGNED') {
      return 'No one assigned';
    }

    // Return full list for tooltip
    const names = assignedTo.split(',').map(name => name.trim());
    return names.join('\n');
  }

  getAssignmentClass(assignedTo: string): string {
    if (!assignedTo || assignedTo === 'NOT ASSIGNED') {
      return 'not-assigned';
    }
    
    // Check if multiple people assigned
    const nameCount = assignedTo.split(',').length;
    return nameCount > 1 ? 'multiple-assigned' : 'single-assigned';
  }
}
Updated HTML for Assigned To Column:
xml
<!-- store-table.component.html - ENHANCED ASSIGNED TO COLUMN -->

<ng-container matColumnDef="assigned_to">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Assigned To</mat-header-cell>
  <mat-cell *matCellDef="let element" class="assigned-cell" 
            (click)="openAssignmentDialog(element, 'StoreLevel'); $event.stopPropagation()">
    
    <div class="assignment-container">
      <!-- Display truncated names -->
      <span class="assignment-badge" 
            [ngClass]="getAssignmentClass(element.AssignedTo)"
            [matTooltip]="getAssignedToTooltip(element.AssignedTo)"
            matTooltipClass="multi-line-tooltip">
        {{getAssignedToDisplay(element.AssignedTo)}}
      </span>
      
      <!-- Show count if multiple people -->
      <span *ngIf="element.AssignedTo && element.AssignedTo.includes(',')" 
            class="assignment-count">
        (+{{element.AssignedTo.split(',').length - 2}} more)
      </span>
    </div>
  </mat-cell>
</ng-container>
CSS for Enhanced Assigned To:
css
/* store-table.component.css - ENHANCED ASSIGNED TO STYLES */

.assignment-container {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.assignment-badge.multiple-assigned {
  background: #2196f3;
  color: white;
  position: relative;
}

.assignment-badge.single-assigned {
  background: #4caf50;
  color: white;
}

.assignment-count {
  font-size: 10px;
  color: #666;
  font-style: italic;
}

/* Multi-line tooltip */
.mat-tooltip.multi-line-tooltip {
  white-space: pre-line;
  max-width: 300px;
  text-align: left;
}

/* Text overflow handling for all cells */
.mat-cell {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 200px;
}

.mat-cell[matTooltip] {
  cursor: help;
}

/* Specific column max-widths to prevent overflow */
.mat-column-store_name .mat-cell {
  max-width: 250px;
}

.mat-column-addr_line1 .mat-cell {
  max-width: 200px;
}

.mat-column-assigned_to .mat-cell {
  max-width: 180px;
}
7. Table Alignment Fix
Updated Table CSS:
css
/* store-table.component.css - FIXED TABLE ALIGNMENT */

.store-table {
  width: 100%;
  table-layout: fixed; /* This ensures consistent column widths */
  border-collapse: separate;
  border-spacing: 0;
}

.store-table .mat-header-cell,
.store-table .mat-cell {
  padding: 8px 12px;
  border-right: 1px solid #e0e0e0;
  vertical-align: middle;
  word-wrap: break-word;
}

.store-table .mat-header-cell:last-child,
.store-table .mat-cell:last-child {
  border-right: none;
}

/* Fixed column widths */
.mat-column-store_number {
  width: 120px;
  min-width: 120px;
}

.mat-column-store_name {
  width: 200px;
  min-width: 200px;
}

.mat-column-addr_line1 {
  width: 180px;
  min-width: 180px;
}

.mat-column-city {
  width: 150px;
  min-width: 150px;
}

.mat-column-state {
  width: 80px;
  min-width: 80px;
}

.mat-column-assigned_to {
  width: 160px;
  min-width: 160px;
}

.mat-column-user_comment {
  width: 200px;
  min-width: 200px;
}

/* Header alignment */
.mat-header-cell {
  text-align: left;
  font-weight: 600;
  color: #333;
  background: #f8f9fa;
  border-bottom: 2px solid #dee2e6;
}

/* Cell alignment */
.mat-cell {
  text-align: left;
  vertical-align: top;
  line-height: 1.4;
}

/* Ensure proper row height */
.mat-row {
  min-height: 48px;
}

.mat-header-row {
  min-height: 56px;
}
Implementation Summary:
✅ Code Simplified: Consolidated repetitive patterns, generic search methods
✅ Column Hide/Show: Multi-select dropdown in advanced filters
✅ Table Search: Real-time search across all table data
✅ Enhanced Spinner: Centralized spinner service for all loading states
✅ Secure Comments: Role-based edit/delete permissions
✅ Multi-name Display: Proper handling of multiple assigned people
✅ Fixed Alignment: Proper table column alignment and overflow handling

These enhancements provide a professional, user-friendly interface with proper security controls and improved performance!
