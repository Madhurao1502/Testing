<div class="table-container">
  <mat-card class="table-card">
    <mat-card-header>
      <mat-card-title>Store Assignment Data</mat-card-title>
      <mat-card-subtitle>{{dataSource.data.length}} stores found</mat-card-subtitle>
    </mat-card-header>
    
    <mat-card-content>
      <div class="table-wrapper">
        <!-- FIXED: Using your working table structure -->
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2">
          
          <!-- Store Number Column with Expansion -->
          <ng-container matColumnDef="store_number">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store #</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
              <span class="caret" [class.expanded]="isExpanded(element)" *ngIf="element.hasDetails">â–¼</span>
              <span *ngIf="!element.hasDetails">&nbsp;&nbsp;&nbsp;&nbsp;</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Store Name Column -->
          <ng-container matColumnDef="store_name">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store Name</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-name-cell">
              <div class="store-info">
                <span class="store-name">{{element.StoreName}}</span>
              </div>
            </mat-cell>
          </ng-container>

          <!-- Store Address Column -->
          <ng-container matColumnDef="addr_line1">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store Address</mat-header-cell>
            <mat-cell *matCellDef="let element" class="address-cell">
              {{element.AddrLine1}}
            </mat-cell>
          </ng-container>

          <!-- City Column -->
          <ng-container matColumnDef="city">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">City</mat-header-cell>
            <mat-cell *matCellDef="let element" class="city-cell">{{element.City}}</mat-cell>
          </ng-container>

          <!-- State Column -->
          <ng-container matColumnDef="state">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">State</mat-header-cell>
            <mat-cell *matCellDef="let element" class="state-cell">
              <span class="state-badge">{{element.State}}</span>
            </mat-cell>
          </ng-container>

          <!-- Zip Column -->
          <ng-container matColumnDef="zip">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Zip</mat-header-cell>
            <mat-cell *matCellDef="let element" class="zip-cell">{{element.Zip}}</mat-cell>
          </ng-container>

          <!-- Assigned To Column -->
          <ng-container matColumnDef="assigned_to">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Assigned To</mat-header-cell>
            <mat-cell *matCellDef="let element" class="assigned-cell">
              <span class="assignment-badge" [ngClass]="getAssignmentClass(element.AssignedTo)">
                {{element.AssignedTo}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Average Collection Time Column -->
          <ng-container matColumnDef="expected_collection_time">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Avg Coll Time</mat-header-cell>
            <mat-cell *matCellDef="let element" class="collection-time-cell">
              {{formatCollectionTime(element.ExpectedCollectionTime)}}
            </mat-cell>
          </ng-container>

          <!-- Cluster Column -->
          <ng-container matColumnDef="position_name">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Cluster</mat-header-cell>
            <mat-cell *matCellDef="let element" class="cluster-cell">
              {{getClusterDisplay(element.PositionName)}}
            </mat-cell>
          </ng-container>

          <!-- FIXED: Header and Data Rows (like your working example) -->
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row 
            *matRowDef="let row; columns: displayedColumns; let i = index"
            [ngClass]="{'selected-row': row === selectedRow}"
            class="table-row"
            (click)="selectedRow = selectedRow === row ? null : row"
            [cdkDetailRow]="row" 
            [cdkDetailRowTpl]="tpl"
            (toggleChange)="GetUPCCollectionDetail($event, row)"
            matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator 
        [pageSizeOptions]="[5, 10, 20, 50]" 
        showFirstLastButtons
        class="table-paginator">
      </mat-paginator>

      <!-- FIXED: Inner Table Template (exactly like your working example) -->
      <ng-template #tpl let-element>
        <div class="mat-row detail-row" [@detailExpand] style="overflow: hidden;">
          <table class="expanded-table"> 
            <tr> 
              <th>T #</th>
              <th>Collector</th>              
              <th>Store #</th>
              <th>Name</th>
              <th>Address</th>
              <th>Collected</th>
              <th>Height</th>
              <th>Width</th>
              <th>Depth</th>            
              <th>Processed</th>
            </tr>
            <tr *ngFor="let item of storeDetailsList">
              <td>{{item.territory || element.Territory || 'N/A'}}</td>
              <td>{{item.collectorName || element.CollectorName || 'N/A'}}</td>              
              <td>{{item.storeNumber || element.StoreNumber}}</td>
              <td style="max-width: 283px; white-space: normal;">
                {{item.storeName || element.StoreName}}                
              </td>
              <td style="max-width: 283px; white-space: normal;">
                {{item.storeAddress || element.AddrLine1}}
              </td>
              <td>{{item.collected || element.Collected || 'N/A'}}</td>
              <td>{{item.height || element.Height || 'N/A'}}</td>
              <td>{{item.width || element.Width || 'N/A'}}</td>
              <td>{{item.depth || element.Depth || 'N/A'}}</td>
              <td>{{item.processed || element.Processed || 'N/A'}}</td>
            </tr>       
          </table>
        </div>
      </ng-template>
    </mat-card-content>
  </mat-card>
</div>

import { Component, OnInit, OnDestroy, ViewChild } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { CommonService } from 'src/app/shared/common.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { animate, state, style, transition, trigger } from '@angular/animations';

@Component({
  selector: 'app-store-table',
  templateUrl: './store-table.component.html',
  styleUrls: ['./store-table.component.css'],
  animations: [
    trigger('detailExpand', [
      state('collapsed', style({height: '0px', minHeight: '0'})),
      state('expanded', style({height: '*'})),
      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
    ]),
  ],
})
export class StoreTableComponent implements OnInit, OnDestroy {
  
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;
  
  displayedColumns: string[] = [
    'store_number', 
    'store_name', 
    'addr_line1', 
    'city', 
    'state', 
    'zip', 
    'assigned_to', 
    'expected_collection_time', 
    'position_name'
  ];
  
  dataSource = new MatTableDataSource<any>([]);
  selectedRow: any = null;
  storeDetailsList: any[] = []; // For inner table data
  showSpinner = false;
  
  private destroy$ = new Subject<void>();

  constructor(private commonService: CommonService) { }

  ngOnInit(): void {
    // Subscribe to grid data changes from service
    this.commonService.gridData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        this.dataSource.data = data;
        console.log('Table data updated:', data.length, 'records');
      });
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  isExpanded(store: any): boolean {
    return this.selectedRow === store;
  }

  // FIXED: Function based on your working example
  GetUPCCollectionDetail(event: any, row: any): void {
    if (event) {
      this.selectedRow = this.selectedRow === row ? null : row;
      console.log('Expanding row:', row);
      
      // Here you would call your API to get detail data
      // For now, using sample data
      if (this.selectedRow) {
        this.loadStoreDetails(row);
      }
    } else {
      this.selectedRow = null;
      this.storeDetailsList = [];
    }
  }

  // FIXED: Load store details (replace with your API call)
  private loadStoreDetails(store: any): void {
    this.showSpinner = true;
    
    // Sample data - replace with your actual API call
    setTimeout(() => {
      this.storeDetailsList = [
        {
          territory: store.Territory || '101',
          collectorName: store.CollectorName || 'John Doe',
          storeNumber: store.StoreNumber,
          storeName: store.StoreName,
          storeAddress: store.AddrLine1,
          collected: store.Collected || 'Yes',
          height: store.Height || '10ft',
          width: store.Width || '20ft',
          depth: store.Depth || '15ft',
          processed: store.Processed || 'Complete'
        }
      ];
      this.showSpinner = false;
    }, 500);
  }

  getAssignmentClass(assignedTo: string): string {
    return assignedTo === 'NOT ASSIGNED' ? 'not-assigned' : 'assigned';
  }

  formatCollectionTime(time: string): string {
    return time || 'Not specified';
  }

  getClusterDisplay(positionName: string): string {
    return positionName || 'N/A';
  }
}



.table-container {
  width: 100%;
  height: 100%;
  position: relative;
  min-height: 66vh;
  max-height: 66vh;
  overflow-x: auto;
}

.table-card {
  height: 100%;
  display: flex;
  flex-direction: column;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
}

.table-wrapper {
  flex: 1;
  overflow: auto;
  min-height: 400px;
}

/* FIXED: Table structure based on your working example */
.store-table {
  width: 100%;
  max-width: 100%;
  background: white;
  display: table;
  border-collapse: collapse;
  margin: 0px;
}

.store-table .mat-header-row {
  height: 40px;
}

.store-table .mat-row {
  max-width: 120%;
  cursor: pointer;
  transition: background-color 0.2s;
}

.store-table .mat-row:hover {
  background-color: mintcream;
}

.store-table .mat-row.selected-row {
  background-color: lightyellow;
}

/* FIXED: Header styling like your working example */
.mat-header-style {
  font-weight: bold !important;
  font-size: 15px !important;
  background-color: lightgray !important;
}

/* FIXED: Column-specific styles with fixed widths (like your working example) */
.mat-column-store_number {
  width: 10%;
  min-width: 140px;
  max-width: 200px;
  padding: 0px 10px;
}

.mat-column-store_name {
  width: 20%;
  min-width: 200px;
  max-width: 500px;
  padding: 0px 10px;
}

.mat-column-addr_line1 {
  width: 20%;
  min-width: 200px;
  max-width: 500px;
  padding: 0px 10px;
}

.mat-column-city {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

.mat-column-state {
  width: 5%;
  min-width: 80px;
  max-width: 100px;
  padding: 0px 10px;
}

.mat-column-zip {
  width: 8%;
  min-width: 80px;
  max-width: 120px;
  padding: 0px 10px;
}

.mat-column-assigned_to {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

.mat-column-expected_collection_time {
  width: 10%;
  min-width: 120px;
  max-width: 200px;
  padding: 0px 10px;
}

.mat-column-position_name {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

/* FIXED: Caret styling (like your working example) */
.caret {
  display: inline-block;
  margin-right: 5px;
  margin-top: -1px;
  transition: transform 0.3s;
  font-size: 18px;
  font-weight: 800;  
  transform: rotate(90deg);
  cursor: pointer;
}

.caret.expanded {
  transform: rotate(180deg);
  margin-top: -5px;
}

/* Cell styling */
.store-number-cell {
  font-weight: 500;
}

.store-name-cell .store-name {
  font-weight: 500;
  color: #333;
}

.address-cell {
  color: #555;
}

.state-badge {
  background: #e8f5e8;
  color: #2e7d32;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
  display: inline-block;
}

.assignment-badge {
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  display: inline-block;
  white-space: nowrap;
}

.assignment-badge.assigned {
  background: #4caf50;
  color: white;
}

.assignment-badge.not-assigned {
  background: #ff9800;
  color: white;
}

.collection-time-cell {
  color: #666;
  font-size: 13px;
}

.cluster-cell {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 12px;
  background: #f5f5f5;
  color: #333;
  border-radius: 4px;
}

/* FIXED: Expanded table styling (exactly like your working example) */
.expanded-table {
  margin-top: 5px;
  margin-bottom: 15px;
  margin-left: 70px;
  border-collapse: collapse;
  border: 1px solid #ddd;
  font-size: 14px;
  width: calc(100% - 140px); /* Full width minus margins */
}

.expanded-table th,
.expanded-table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #ddd;
  white-space: nowrap;
}

.expanded-table th {
  background-color: #f2f2f2;
  font-weight: bold;
}

.expanded-table td[style*="max-width"] {
  white-space: normal !important;
  word-wrap: break-word;
}

/* Detail row styling */
.detail-row {
  background: #fafafa;
  overflow: hidden;
}

/* Paginator */
.table-paginator {
  border-top: 1px solid #e0e0e0;
  background: #fafafa;
  position: sticky;
  bottom: 0;
  z-index: 10;
  height: 52px;
}

/* Responsive design */
@media (max-width: 768px) {
  .table-wrapper {
    overflow-x: auto;
  }
  
  .store-table {
    min-width: 800px;
  }
  
  .expanded-table {
    margin-left: 20px;
    width: calc(100% - 40px);
    font-size: 12px;
  }
  
  .expanded-table th,
  .expanded-table td {
    padding: 6px 8px;
  }
}

/* Spinner styling */
.mat-spinner-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.mat-spinner {
  z-index: 111;
}
