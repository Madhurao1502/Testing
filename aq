import { SnackbarService } from './../../shared/snackbar.service';
import { trigger, transition, style, animate } from '@angular/animations';
import { HttpClient } from '@angular/common/http';
import { Component, ElementRef, EventEmitter, Inject, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { catchError, debounceTime, distinctUntilChanged, firstValueFrom, map, Observable, of, startWith, Subject, switchMap, takeUntil, tap } from 'rxjs';
import { StoreFilter, FilterOptions, GetGridDataFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

// ,
//   animations: [
//   trigger('slideDown', [
//     transition(':enter', [
//       style({ height: '0', opacity: '0', overflow: 'hidden' }),
//       animate('300ms ease-in', style({ height: '*', opacity: '1' }))
//     ]),
//     transition(':leave', [
//       animate('300ms ease-out', style({ height: '0', opacity: '0', overflow: 'hidden' }))
//     ])
//   ])
// ]

@Component({
  selector: 'app-filter-sidebar',
  templateUrl: './filter-sidebar.component.html',
  styleUrls: ['./filter-sidebar.component.css']
})
export class FilterSidebarComponent implements OnInit, OnDestroy {
  @Output() filtersChanged = new EventEmitter<GetGridDataFilter>();
  @Output() clearFilters = new EventEmitter<void>();
 private allAvailableColumns = {
    base: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'task', label: 'Task', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'zip', label: 'Zip', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'user_comment', label: 'Comments', required: true },
      { key:  'work_order', label: 'Work Order', required: true }
     
    ],
    current: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'position_number', label: 'Position Number', required: false },
      { key: 'task', label: 'Task', required: true },
      { key: 'bdf', label: 'BFD', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      // { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true },
      { key:  'work_order', label: 'Work Order', required: true }
    ],
    future: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'position_number', label: 'Position Number', required: false },
      { key: 'task', label: 'Task', required: true },
      { key: 'bdf', label: 'BFD', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'avg_cost', label: 'Avg Cost', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true },
      { key:  'work_order', label: 'Work Order', required: true }
    ],
    previous: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'territory', label: 'Territory', required: false },
      { key: 'position_number', label: 'Position Number', required: false },
      { key: 'task', label: 'Task', required: true },
      { key: 'bdf', label: 'BFD', required: false },
      { key: 'outlet', label: 'Outlet', required: false },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      // { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'wk1_costs', label: 'WK1 Costs', required: false },
      { key: 'wk1_travel', label: 'WK1 Travel Cost', required: false },
      { key: 'wk1_ovg_travel', label: 'WK1 ovg Travel Cost', required: false },     
      { key: 'wk2_costs', label: 'WK2 Costs', required: false },
      { key: 'wk2_travel', label: 'WK2 Travel Cost', required: false },
      { key: 'wk2_ovg_travel', label: 'WK2 ovg Travel Cost', required: false },
      { key: 'user_comment', label: 'Comments', required: true },
      { key:  'work_order', label: 'Work Order', required: true }
    ]
  };

  currentWeekType: 'current' | 'future' | 'previous' = 'current';
  availableColumns: any[] = [];
  selectedColumns: string[] = [];

  @Output() columnsChanged = new EventEmitter<string[]>();  
  @Output() filtersApplied = new EventEmitter<void>();
  filterForm!: FormGroup;
  showAdvancedFilters = false;
  showSpinner = false;
  expandedAdvancedLabel = 'Show Additional Filters';
   private formInitialized = false;
  private dataLoaded = {
    iriWeek: false,
    territory: false,
    employee: false
  };
  // Data arrays
  employeedata: any[] = [];
  iriWeeks: any[] = [];
  territories: any[] = [];
  filteredStores: any[] = [];
  filteredState: any[] = [];
  filteredCity: any[] = [];
  filteredCluster: any[] = [];
  filteredTask: any[] = [];
  filteredFSR: any[] = [];
  fsrHourOperators = [
    { value: 'NA', label: 'NA' },
    { value: '>', label: '>' },
    { value: '=', label: '=' },
    { value: '<', label: '<' }
  ];
  // Selected values
  selectedStoreNumber = '';
  selectedState = '';
  selectedCity = '';
  selectedCluster = '';
  selectedTask = '';
  selectedFsrId = '';
  areaNBRctrl = new FormControl();
  private unsubscribe$ = new Subject<void>();
  private loggeduser: string;

  constructor(
    private fb: FormBuilder,
    private commonService: CommonService,
    public http: HttpClient,
    private snackbar: SnackbarService,
    @Inject('BASE_URL') public baseUrl: string,
  ) {
    this.initializeForm();
    this.loggeduser = localStorage.getItem("loggedUserId") || '';
  }

  async ngOnInit(): Promise<void> {
 this.commonService.weekType$
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe(weekType => {
        this.currentWeekType = weekType;
        this.updateAvailableColumns();
        this.resetSelectedColumnsForWeekType();
      });

    try {
       this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
        this.dataLoaded.employee = true;
      await this.getIriWeek();
      this.dataLoaded.iriWeek = true;
      await this.getTerritory();  
      this.dataLoaded.territory = true;
      
      // Setup form subscriptions after data is loaded
      this.setupFormSubscriptions();
      
      // Mark form as initialized
      this.formInitialized = true;
      
      // NOW apply default filters after everything is ready
      this.applyDefaultFilters();
    } catch (error) {
      console.error('Error initializing filter component:', error);
    }
  }

  private initializeForm(): void {
    this.filterForm = this.fb.group({
      iriWeek: [''],
      territory: [''],
      store: [''],
      state: [''],
      city: [''],
      cluster: [''],
      task: [''],
      fsr: [''],
      fsrHour: [''],
      fsrHourOperator: ['NA'], 
      storeAssignment: ['all'],
      sampleType: ['all'],
      multiFsrStore: [false]
    });
  }

    private async getIriWeek(): Promise<void> {
    try {
      const response = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')
      );
      
      this.iriWeeks = response;
      
      // Set default value
      if (this.iriWeeks.length > 0) {
        this.filterForm.get('iriWeek')?.setValue(
          this.iriWeeks?.[1]?.['iri_week'], 
          { emitEvent: false }
        );
      }
    } catch (error) {
      console.error('Error fetching IRI weeks:', error);
      throw error;
    }
  }

  private async getTerritory(): Promise<void> {
    try {
      this.showSpinner = true;
      const response = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      );
      
      this.territories = response;
      
      // Set default territory
      const defaultTerritory = this.getDefaultTerritory();
      this.filterForm.get('territory')?.setValue(defaultTerritory, { emitEvent: false });
      
      if (this.territories.length > 0) {
        this.areaNBRctrl.setValue(this.territories['area']);
      }
      
    } catch (error) {
      console.error('Error fetching territories:', error);
      throw error;
    } finally {
      this.showSpinner = false;
    }
  }

  private getDefaultTerritory(): string {
    if (!this.employeedata) return '';
    
    return this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'];
  }

  private setupFormSubscriptions(): void {
    // Store autocomplete
    this.filterForm.get('store')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getStore(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(stores => {
      this.filteredStores = stores || [];
      this.showSpinner = false;
    });

    // State autocomplete
    this.filterForm.get('state')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getState(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(states => {
      this.filteredState = states || [];
      this.showSpinner = false;
    });

    // City autocomplete
    this.filterForm.get('city')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCity(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(cities => {
      this.filteredCity = cities || [];
      this.showSpinner = false;
    });

    // Cluster autocomplete
    this.filterForm.get('cluster')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCluster(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(clusters => {
      this.filteredCluster = clusters || [];
      this.showSpinner = false;
    });

    // Task autocomplete
    this.filterForm.get('task')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getTask(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(tasks => {
      this.filteredTask = tasks || [];
    });

    // FSR autocomplete
    this.filterForm.get('fsr')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getFsr(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(fsrs => {
      this.filteredFSR = fsrs || [];
    });
  }

 
  getStore(searchText: string) {
    if (!searchText || searchText.length < 3) {
      return of([]);
    }

    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetStore', payload)
      .pipe(catchError(() => of([])));
  }

  getState(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetState', payload)
      .pipe(catchError(() => of([])));
  }

  getCity(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCity', payload)
      .pipe(catchError(() => of([])));
  }

  getCluster(searchText: string) {
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCluster', payload)
      .pipe(catchError(() => of([])));
  }

  getTask(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetTask', payload)
      .pipe(catchError(() => of([])));
  }

  getFsr(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsr', payload)
      .pipe(catchError(() => of([])));
  }

  // Event handlers for IRI Week and Territory changes
  onIriWeekChange(): void {
    // Clear dependent fields when IRI week changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  onTerritoryChange(): void {
    // this.areaNBRctrl.setValue(ter.area)
    // Clear dependent fields when territory changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  // Selection event handlers
  onStoreSelected(event: any) {
    const selectedStore = this.filteredStores.find(store => store.store_name === event.option.value);
    this.selectedStoreNumber = selectedStore?.store_number || '';
  }

  onStateSelected(event: any) {
    const selectedState = this.filteredState.find(state => state.state === event.option.value);
    this.selectedState = selectedState?.state || '';
  }

  onCitySelected(event: any) {
    const selectedCity = this.filteredCity.find(city => city.city === event.option.value);
    this.selectedCity = selectedCity?.city || '';
  }

  onClusterSelected(event: any) {
    const selectedCluster = this.filteredCluster.find(cluster => cluster.position_name === event.option.value);
    this.selectedCluster = selectedCluster?.position_number || '';
  }

  onTaskSelected(event: any) {
    const selectedTask = this.filteredTask.find(task => task.task_name === event.option.value);
    this.selectedTask = selectedTask?.task_number || '';
  }

  onFsrSelected(event: any) {
    const selectedFsr = this.filteredFSR.find(fsr => fsr.emp_name === event.option.value);
    this.selectedFsrId = selectedFsr?.emp_id || '';
  }

  // Control methods
  toggleAdvancedFilters(): void {
    this.showAdvancedFilters = !this.showAdvancedFilters;
    // this.expandedAdvancedLabel = this.showAdvancedFilters ?'Hide Additional Filters':'Show Additional Filters';
  }


  onApplyFilters(): void {
    this.commonService.show('apply-filters');
     if (!this.formInitialized) {
        this.commonService.hide('apply-filters');     
      return;
    }

    const currentCountry = this.commonService.getCurrentCountry();
    if (!currentCountry) {
      // console.log('Please select a country first');
      // this.snackbar.openSnackBar("Loading country","warning")
      // return;
    }

    // Validate required fields
    const formValue = this.filterForm.value;
    if (!formValue.iriWeek || !formValue.territory) {
        this.commonService.hide('apply-filters');    
      return;
    }
    const filters = new GetGridDataFilter();
    filters.countryId = currentCountry||'1';
    filters.lanId = this.loggeduser;
    filters.iriWeek = formValue.iriWeek || '';
    filters.territoryId = formValue.territory || '';
    filters.area = this.areaNBRctrl.value || '23';
    filters.storeNumber = this.selectedStoreNumber;
    filters.storeName = formValue.store || '';
    filters.state = this.selectedState;
    filters.city = this.selectedCity;
    filters.positionNumber = this.selectedCluster;
    filters.taskNumber = this.selectedTask;
    filters.empId = this.selectedFsrId;
    filters.fsrHour = formValue.fsrHour || '';
    filters.fsrHourOperator = formValue.fsrHourOperator || 'NA'; 
    filters.fsrOver25hrs = 'false';
    filters.fsrOver6hrs = 'false';
    filters.temporary = 'false';
    filters.vacation = 'false';
    // Handle radio button selections
    if (formValue.storeAssignment === 'assigned') {
      filters.assignedStores = 'true';
      filters.unassignedStores = 'false';
    } else if (formValue.storeAssignment === 'unassigned') {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'true';
    } else {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'false';
    }

    if (formValue.sampleType === 'sample') {
      filters.sample = 'true';
      filters.nonSample = 'false';
    } else if (formValue.sampleType === 'nonSample') {
      filters.sample = 'false';
      filters.nonSample = 'true';
    } else {
      filters.sample = 'false';
      filters.nonSample = 'false';
    }

    filters.multiFsrStore = formValue.multiFsrStore ? 'true' : 'false';
  setTimeout(() => this.commonService.hide('apply-filters'), 100);
    this.filtersChanged.emit(filters);
    this.filtersApplied.emit();
  }

  // MISSING FUNCTION: Clear Filters
  onClearFilters(): void {
    this.filterForm.reset({
      iriWeek: this.iriWeeks.length > 1 ? this.iriWeeks?.[0]?.['iri_week'] : '',
      territory: this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'],
        storeAssignment: 'all',
      sampleType: 'all',
      multiFsrStore: false,
      fsrHourOperator: 'NA'
    });
    this.clearSelectedValues();
    this.clearFilters.emit();
  }

  // Apply Default Filters on Load
  private applyDefaultFilters(): void {
    if (!this.formInitialized || !this.allDataLoaded()) {
      // console.log('Form not ready for default filters');
      this.snackbar.openSnackBar("Loading default filters","warning")
      return;
    }

  
    setTimeout(() => {
      this.onApplyFilters();
    }, 500);
  }

  private allDataLoaded(): boolean {
    return this.dataLoaded.iriWeek && 
           this.dataLoaded.territory && 
           this.dataLoaded.employee;
  }

  private clearSelectedValues(): void {
    this.selectedStoreNumber = '';
    this.selectedState = '';
    this.selectedCity = '';
    this.selectedCluster = '';
    this.selectedTask = '';
    this.selectedFsrId = '';
  }

  // Clear individual controls
  clearStrCtrl() { 
    this.filterForm.get('store')?.reset(); 
    this.selectedStoreNumber = '';
  }
  clearStaCtrl() { 
    this.filterForm.get('state')?.reset(); 
    this.selectedState = '';
  }
  clearcityCtrl() { 
    this.filterForm.get('city')?.reset(); 
    this.selectedCity = '';
  }
  clearTaskCtrl() { 
    this.filterForm.get('task')?.reset(); 
    this.selectedTask = '';
  }
  clearFsrCtrl() { 
    this.filterForm.get('fsr')?.reset(); 
    this.selectedFsrId = '';
  }

   onFsrHourOperatorChange(): void {
    const operator = this.filterForm.get('fsrHourOperator')?.value;
    const fsrHourControl = this.filterForm.get('fsrHour');
    
    if (operator === 'NA') {
      fsrHourControl?.setValue('');
      fsrHourControl?.disable();
    } else {
      fsrHourControl?.enable();
    }
  }

  onFsrHourChange(): void {
    const fsrHour = this.filterForm.get('fsrHour')?.value;
    if (fsrHour && fsrHour.trim() !== '') {
      // Reset multi FSR store if user enters FSR hours
      this.filterForm.get('multiFsrStore')?.setValue(false);
    }
  }
  onMultiFsrStoreChange(): void {
    const multiFsrStore = this.filterForm.get('multiFsrStore')?.value;
    if (multiFsrStore) {
      this.filterForm.get('fsrHourOperator')?.setValue('NA');
      this.filterForm.get('fsrHour')?.setValue('');
      this.filterForm.get('fsrHour')?.disable();
    }
  }


   private async loadAllData(): Promise<void> {
    try {
      this.showSpinner = true;
      
      // Load all data in parallel
      const [iriWeeks, territories, employeeData] = await Promise.all([
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')),
        firstValueFrom(this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')),
        firstValueFrom(this.commonService.getEmployee(this.loggeduser))
      ]);

      this.iriWeeks = iriWeeks;
      this.territories = territories;
      this.employeedata = employeeData;
      
      this.applyDefaultFilters();
      this.setupFormSubscriptions();
      
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      this.showSpinner = false;
    }
  }

  // Generic autocomplete method
  private setupAutocomplete<T>(controlName: string, apiEndpoint: string): void {
    this.filterForm.get(controlName)?.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      tap(() => this.showSpinner = true),
      switchMap(searchText => this.genericSearch<T>(apiEndpoint, searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(results => {
      this[`filtered${controlName.charAt(0).toUpperCase() + controlName.slice(1)}`] = results;
      this.showSpinner = false;
    });
  }

  // Generic search method
  private genericSearch<T>(endpoint: string, searchText: string): Observable<T[]> {
    if (!searchText || searchText.length < 2) return of([]);
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<T[]>(this.baseUrl + endpoint, payload)
      .pipe(catchError(() => of([])));
  }

  private updateAvailableColumns(): void {
    switch (this.currentWeekType) {
      case 'current':
        this.availableColumns = this.allAvailableColumns.current;
        break;
      case 'future':
        this.availableColumns = this.allAvailableColumns.future;
        break;
      case 'previous':
        this.availableColumns = this.allAvailableColumns.previous;
        break;
      default:
        this.availableColumns = this.allAvailableColumns.base;
    }
  }

 //Reset selected columns when week type changes
  private resetSelectedColumnsForWeekType(): void {
    this.selectedColumns = this.availableColumns
      .filter(col => col.required || this.getDefaultVisibleColumns().includes(col.key))
      .map(col => col.key);
    this.columnsChanged.emit(this.selectedColumns);
  }

 //Get default visible columns based on week type
  private getDefaultVisibleColumns(): string[] {
    const common = ['addr_line1', 'city','work_order'];
    
    switch (this.currentWeekType) {
      case 'current':
        return [...common,'task', 'task_completed','position_number','bdf', 'outlet'];
      case 'future':
        return [...common,'task','avg_cost','guaranteed_miles','position_number','bdf', 'outlet'];
      case 'previous':
        return [...common, 'task','task_completed', 'wk1_costs','wk1_travel', 'wk1_ovg_travel','wk2_costs', 'wk2_travel','wk2_ovg_travel'];
      default:
        return common;
    }
  }

 //Column selection change with week type awareness
  onColumnSelectionChange(): void {
    const requiredColumns = this.availableColumns
      .filter(col => col.required)
      .map(col => col.key);
      
    this.selectedColumns = [...new Set([...this.selectedColumns, ...requiredColumns])];
    this.columnsChanged.emit(this.selectedColumns);
  }

  isColumnRequired(columnKey: string): boolean {
    return this.availableColumns.find(col => col.key === columnKey)?.required || false;
  }


  ngOnDestroy(): void {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}
