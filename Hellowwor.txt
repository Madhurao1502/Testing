createWave() {
  const selectedIds = this.getSelectedWeekIds(); // Implement this method to get selected weeks
  if (selectedIds.length < 2) {
    alert('Please select a minimum of 2 weeks to create a Wave');
    return;
  }

  selectedIds.sort((a, b) => a - b);

  if (!this.areWeeksContinuous(selectedIds)) {
    alert('Please select weeks in a continuous sequence');
    return;
  }

  const [startWeek, endWeek] = this.getStartAndEndWeeks(selectedIds);

  if (this.isOverlappingExistingWave(startWeek, endWeek)) {
    alert('The selected weeks overlap a currently defined Wave. Re-select schedule weeks and try again');
    return;
  }

  // Create new wave object
  const newWave = {
    startWeek,
    endWeek,
    startDate: this.getDateRange(startWeek), // Implement to get date range for the week
    endDate: this.getDateRange(endWeek),
    dueDate: null,
    waveNumber: this.generateWaveNumber()
  };

  this.waveSchedule.push(newWave);
  this.updateGrids();
}

private areWeeksContinuous(selectedIds: number[]): boolean {
  for (let i = 1; i < selectedIds.length; i++) {
    if (selectedIds[i] !== selectedIds[i - 1] + 1) {
      return false;
    }
  }
  return true;
}

private getStartAndEndWeeks(selectedIds: number[]): [number, number] {
  const startWeek = this.getWeekById(selectedIds[0]); // Implement this method
  const endWeek = this.getWeekById(selectedIds[selectedIds.length - 1]);
  return [startWeek, endWeek];
}

private isOverlappingExistingWave(startWeek: number, endWeek: number): boolean {
  return this.waveSchedule.some(wave =>
    (startWeek >= wave.startWeek && startWeek <= wave.endWeek) ||
    (endWeek >= wave.startWeek && endWeek <= wave.endWeek) ||
    (startWeek <= wave.startWeek && endWeek >= wave.endWeek)
  );
}


removeWave(startWeek: number, endWeek: number) {
  if (this.taskLockOutID !== this.currentUser) return;

  // Find and remove the wave
  this.waveSchedule = this.waveSchedule.filter(wave => wave.startWeek !== startWeek);

  // Add back to multi-week data
  const weeksToAddBack = this.mainTempWaveData.filter(week => 
    startWeek <= week.startWeek && week.startWeek <= endWeek
  );

  this.multiWeekData.push(...weeksToAddBack);
  this.multiWeekData.sort((a, b) => a.startWeek - b.startWeek);

  this.updateGrids();
}

private updateGrids() {
  // Update your grids accordingly, for example using a service or directly in the component
  this.waveScheduleGridDataSource = [...this.waveSchedule];
  this.multiWeekGridDataSource = [...this.multiWeekData];
}
