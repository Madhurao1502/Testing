createWave(): void {
  const selectedRows = this.selection.selected;

  if (selectedRows.length < 2) {
    this.errorMessage = "A wave must contain at least 2 consecutive rows.";
    return;
  }

  // Get indices of the selected rows
  const sortedRows = selectedRows.sort((a, b) => this.leftGridData.data.indexOf(a) - this.leftGridData.data.indexOf(b));
  const indices = sortedRows.map(row => this.leftGridData.data.indexOf(row));
  const minIndex = Math.min(...indices);
  const maxIndex = Math.max(...indices);

  // Check if selected rows form a consecutive block
  for (let i = minIndex; i <= maxIndex; i++) {
    if (!indices.includes(i)) {
      this.errorMessage = "Selected rows must be consecutive without gaps.";
      return;
    }
  }

  // Prepare the wave data
  const startRow = sortedRows[0];
  const endRow = sortedRows[sortedRows.length - 1];

  const startWeek = startRow.startWeek;
  const endWeek = endRow.startWeek;

  const maxDueDate = new Date(endRow.endDate);
  maxDueDate.setDate(maxDueDate.getDate() + 7);
  const minDueDate = new Date(startRow.startDate);
  minDueDate.setDate(minDueDate.getDate() - 7);

  const formatToDateTimeString = (date: Date): string => {
    return date.toISOString().slice(0, 16); // Extract 'YYYY-MM-DDTHH:MM' portion
  };

  const wave = {
    startWeek: `${startWeek} (${startRow.startDate} - ${startRow.endDate})`,
    endWeek: `${endWeek} (${endRow.startDate} - ${endRow.endDate})`,
    startDate: startRow.startDate,
    endDate: endRow.endDate,
    dueDate: '',
    minDueDate: formatToDateTimeString(minDueDate),
    maxDueDate: formatToDateTimeString(maxDueDate)
  };

  // Update the right grid with the new wave
  this.rightGridData.data = [...this.rightGridData.data, wave];
  // Remove selected rows from the left grid
  this.leftGridData.data = this.leftGridData.data.filter(item => !this.selection.isSelected(item));
  // Clear the selection
  this.selection.clear();
}
