.dashboard-layout {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.mat-toolbar {
  background: #1976d2;
  color: white;
  z-index: 1000;
  position: relative;
}

.toolbar-title {
  margin-left: 16px;
  font-size: 18px;
  font-weight: 500;
}

.toolbar-spacer {
  flex: 1 1 auto;
}

.sidenav-container {
  flex: 1;
  overflow: hidden;
}

.sidenav {
  width: 280px;
  background: #fafafa;
  border-right: 1px solid #e0e0e0;
  transition: all 0.3s ease-in-out;
}

.sidenav.sidenav-hidden {
  width: 0;
  border: none;
}

.main-content {
  transition: all 0.3s ease-in-out;
}

.main-content.sidebar-closed {
  margin-left: 0;
}

.content-wrapper {
  padding: 20px;
  height: 100%;
  overflow: auto;
}

/* Responsive Design */
@media (max-width: 768px) {
  .sidenav {
    position: fixed;
    z-index: 1001;
  }
}


<div class="filter-sidebar">
  <div class="sidebar-header">
    <h3>Filters</h3>
  </div>
  
  <div class="sidebar-content">
    <form [formGroup]="filterForm" class="filter-form">
      
      <!-- Quick Search -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Quick Search</mat-label>
          <input matInput formControlName="quickSearch" placeholder="Search stores...">
          <mat-icon matSuffix>search</mat-icon>
        </mat-form-field>
      </div>

      <!-- Territory Filter -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Territory</mat-label>
          <mat-select formControlName="territory">
            <mat-option value="">All Territories</mat-option>
            <mat-option *ngFor="let territory of filterOptions.territories" [value]="territory">
              {{territory}}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <!-- Location Filter -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Location</mat-label>
          <mat-select formControlName="location">
            <mat-option value="">All Locations</mat-option>
            <mat-option *ngFor="let location of filterOptions.locations" [value]="location">
              {{location}}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <!-- Status Filter -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Status</mat-label>
          <mat-select formControlName="status">
            <mat-option value="">All Statuses</mat-option>
            <mat-option *ngFor="let status of filterOptions.statuses" [value]="status">
              {{status}}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <!-- Store Type Filter -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Store Type</mat-label>
          <mat-select formControlName="storeType">
            <mat-option value="">All Types</mat-option>
            <mat-option *ngFor="let type of filterOptions.storeTypes" [value]="type">
              {{type}}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <!-- Assignment Filter -->
      <div class="filter-section">
        <mat-form-field appearance="outline" class="full-width">
          <mat-label>Assignment</mat-label>
          <mat-select formControlName="assignment">
            <mat-option value="">All Assignments</mat-option>
            <mat-option *ngFor="let assignment of filterOptions.assignments" [value]="assignment">
              {{assignment}}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <!-- Date Range -->
      <div class="filter-section">
        <div class="date-range">
          <mat-form-field appearance="outline" class="date-field">
            <mat-label>From Date</mat-label>
            <input matInput [matDatepicker]="fromPicker" formControlName="dateFrom">
            <mat-datepicker-toggle matSuffix [for]="fromPicker"></mat-datepicker-toggle>
            <mat-datepicker #fromPicker></mat-datepicker>
          </mat-form-field>
          
          <mat-form-field appearance="outline" class="date-field">
            <mat-label>To Date</mat-label>
            <input matInput [matDatepicker]="toPicker" formControlName="dateTo">
            <mat-datepicker-toggle matSuffix [for]="toPicker"></mat-datepicker-toggle>
            <mat-datepicker #toPicker></mat-datepicker>
          </mat-form-field>
        </div>
      </div>

      <!-- Multi FSR Toggle -->
      <div class="filter-section">
        <mat-slide-toggle formControlName="multiFsr" class="multi-fsr-toggle">
          Multi-FSR
        </mat-slide-toggle>
      </div>

      <!-- Action Buttons -->
      <div class="filter-actions">
        <button mat-raised-button color="primary" type="button" (click)="onApplyFilters()" class="action-button">
          Apply Filters
        </button>
        <button mat-stroked-button type="button" (click)="onClearFilters()" class="action-button">
          Clear All
        </button>
      </div>
    </form>
  </div>
</div>

.filter-sidebar {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: #fafafa;
}

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
}

.sidebar-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 500;
  color: #333;
}

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.filter-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.filter-section .full-width {
  width: 100%;
}

.date-range {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.date-range .date-field {
  width: 100%;
}

.multi-fsr-toggle {
  width: 100%;
  display: flex;
  justify-content: space-between;
}

.filter-actions {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 20px;
}

.filter-actions .action-button {
  width: 100%;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .sidebar-content {
    padding: 12px;
  }

  .filter-form {
    gap: 12px;
  }
}

.........................................
.table-container {
  width: 100%;
  height: 100%;
}

.table-card {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.table-wrapper {
  flex: 1;
  overflow: auto;
  min-height: 400px;
}

.mat-table {
  width: 100%;
  background: white;
}

.table-row:hover {
  background-color: #f5f5f5;
  cursor: pointer;
}

.status-badge {
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
}

.status-badge.status-active {
  background-color: #4caf50;
  color: white;
}

.status-badge.status-pending {
  background-color: #ff9800;
  color: white;
}

.status-badge.status-canceled {
  background-color: #f44336;
  color: white;
}

.table-paginator {
  border-top: 1px solid #e0e0e0;
  background: #fafafa;
}

/* Responsive Design */
@media (max-width: 768px) {
  .table-wrapper {
    min-height: 300px;
  }

  .mat-table {
    font-size: 14px;
  }

  .mat-cell,
  .mat-header-cell {
    padding: 8px;
  }
}


private filterOptionsData: FilterOptions = {
    cities: ["Middle Village", "New York", "Brooklyn", "Queens", "Staten Island", "Manhattan", "Bronx", "Yonkers", "White Plains", "New Rochelle"],
    states: ["NY", "NJ", "CT", "PA"],
    assignedTo: ["NOT ASSIGNED", "John Smith", "Sarah Johnson", "Mike Davis", "Emma Wilson", "David Brown", "Lisa Anderson"],
    clusters: ["NY11010(1837)", "NY10001(2156)", "NY11201(3445)", "NY11375(4567)", "NY10301(5678)", "NY10016(6789)", "NY10451(7890)", "NY10701(8901)", "NY10601(9012)", "NY10801(0123)"],
    taskNames: ["ALL", "INVENTORY", "AUDIT", "MAINTENANCE", "SURVEY"],
    waves: ["Wave 1", "Wave 2", "Wave 3"]
  };


import { Component, OnInit, OnDestroy, ViewChild } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { SelectionModel } from '@angular/cdk/collections';
import { CommonService } from '../../services/common.service';
import { Store } from '../../models/common.model';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Component({
  selector: 'app-store-table',
  templateUrl: './store-table.component.html',
  styleUrls: ['./store-table.component.scss']
})
export class StoreTableComponent implements OnInit, OnDestroy {
  
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;
  
  displayedColumns: string[] = ['select', 'store_name', 'addr_line1', 'city', 'state', 'zip', 'assigned_to', 'expected_collection_time', 'position_name'];
  dataSource = new MatTableDataSource<Store>([]);
  selection = new SelectionModel<Store>(true, []);
  
  private destroy$ = new Subject<void>();

  constructor(private commonService: CommonService) { }

  ngOnInit(): void {
    this.commonService.getFilteredStores()
      .pipe(takeUntil(this.destroy$))
      .subscribe(stores => {
        this.dataSource.data = stores;
        // Update selection model based on store.selected property
        this.selection.clear();
        stores.filter(store => store.selected).forEach(store => {
          this.selection.select(store);
        });
      });
  }

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  /** Selects all rows if they are not all selected; otherwise clear selection. */
  toggleAllRows() {
    if (this.isAllSelected()) {
      this.selection.clear();
      this.commonService.toggleAllStores(false);
      return;
    }

    this.selection.select(...this.dataSource.data);
    this.commonService.toggleAllStores(true);
  }

  /** The label for the checkbox on the passed row */
  checkboxLabel(row?: Store): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.id}`;
  }

  /** Handle individual row selection */
  toggleRow(row: Store) {
    this.selection.toggle(row);
    if (row.id) {
      this.commonService.toggleStoreSelection(row.id);
    }
  }

  /** Get full address string */
  getFullAddress(store: Store): string {
    return `${store.addr_line1}, ${store.city}, ${store.state} ${store.zip}`;
  }

  /** Format expected collection time */
  formatCollectionTime(time: string): string {
    return time || 'Not specified';
  }

  /** Get cluster display name */
  getClusterDisplay(positionName: string): string {
    return positionName || 'N/A';
  }

  /** Get assignment status styling */
  getAssignmentClass(assignedTo: string): string {
    return assignedTo === 'NOT ASSIGNED' ? 'not-assigned' : 'assigned';
  }
}


