dashbord-layout.component.css

.dashboard-layout {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #fafafa;
}

.mat-toolbar-primary {
  background: #1976d2;
  color: white;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.toolbar-title {
  margin-left: 16px;
  font-size: 20px;
  font-weight: 500;
}

.toolbar-spacer {
  flex: 1;
}

.country-field {
  margin-right: 16px;
}

.country-field .mat-form-field {
  width: 200px;
}

.country-field .mat-form-field .mat-form-field-wrapper {
  padding-bottom: 0;
}

/* Top Filter Bar */
.filter-top-bar {
  background: white;
  border-bottom: 1px solid #e0e0e0;
  overflow: hidden;
  transition: max-height 0.3s ease-in-out;
  max-height: 0;
}

.filter-top-bar.expanded {
  max-height: 500px;
}

/* Main Content */
.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.content-wrapper {
  padding: 24px;
  flex: 1;
  overflow: auto;
}


/* Responsive Design */
@media (max-width: 768px) {
  .content-wrapper {
    padding: 16px;
  }
  
  .country-field .mat-form-field {
    width: 150px;
  }
}

dashbord-layout.component.html

<div class="dashboard-layout">
  <!-- Toolbar -->
  <mat-toolbar class="mat-toolbar-primary">
    <button mat-icon-button (click)="toggleFilters()" aria-label="Toggle filters">
      <mat-icon>filter_list</mat-icon>
    </button>
    <h1 class="toolbar-title">Assignments Dashboard</h1>
    <span class="toolbar-spacer"></span>
    
    <!-- Country Selector -->
    <div class="country-field">
      <mat-form-field appearance="standard">
        <mat-select [formControl]="countryctrl" placeholder="Select country">
          <mat-option *ngFor="let country of countrylist" 
                      [value]="country.countryID" 
                      (onSelectionChange)="selectedcountry($event)">
            {{country.countryName}}
          </mat-option>
        </mat-select>
      </mat-form-field>        
    </div>
    
    <button mat-icon-button aria-label="Edit">
      <mat-icon>edit_square</mat-icon>
    </button>
    <button mat-icon-button aria-label="Send">
      <mat-icon>send</mat-icon>
    </button>
    <button mat-icon-button aria-label="Download">
      <mat-icon>download</mat-icon>
    </button>
  </mat-toolbar>

  <!-- TOP HORIZONTAL FILTER BAR -->
  <section class="filter-top-bar" [class.expanded]="isFiltersExpanded">
    <app-filter-sidebar 
      (filtersChanged)="onFiltersChanged($event)"
      (clearFilters)="onClearFilters()">
    </app-filter-sidebar>
  </section>

  <!-- Main Content -->
  <div class="main-content">
    <div class="content-wrapper">
      <app-store-table></app-store-table>
    </div>
  </div>
</div>

dashbord-layout.component.ts

import { HttpClient } from '@angular/common/http';
import { Component, OnInit, OnDestroy, Inject } from '@angular/core';
import { FormControl } from '@angular/forms';
import { firstValueFrom, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { countryModel, GetGridDataFilter, StoreFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-dashbord-layout',
  templateUrl: './dashbord-layout.component.html',
  styleUrls: ['./dashbord-layout.component.css']
})
export class DashbordLayoutComponent implements OnInit, OnDestroy {

  private destroy$ = new Subject<void>();
  countrylist: countryModel[] = [];
  employeedata: any[] = [];
  countryctrl = new FormControl();
  isFiltersExpanded = false; // Changed from sidebar to top filters
  currentIRIWeek: any;
  loggeduser: string;

  constructor(
    private commonService: CommonService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
  ) { 
    this.loggeduser = localStorage.getItem("loggedUserId");
  }

  async ngOnInit(): Promise<void> {
    // Remove sidebar state subscription since we're using top filters
    this.commonService.groupsStatus$.subscribe(userGroups => {    
      if(userGroups['isgTechnologyGroup']) { 
        this.countryctrl.enable();
      } else { 
        this.countryctrl.disable();
      }   
    });

    this.currentIRIWeek = await firstValueFrom(
      this.http.get<any>(this.baseUrl + 'api/TaskAssinment/GetCurrentIRIWeek')
    );   
    
    try {
      this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
    } catch(error) {
      console.error('Error fetching employee data:', error);
    }

    try {
      this.countrylist = await this.commonService.getcountry();
    } catch {
      console.error('Error fetching country data');
    }      
    
    this.employeedata.filter((x) => {
      this.countryctrl.setValue(x.countryId);
    });

    // Initialize default filters
    this.initializeDefaultFilters();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // Changed from toggleSidebar to toggleFilters
  toggleFilters(): void {
    this.isFiltersExpanded = !this.isFiltersExpanded;
  }

  onFiltersChanged(filters: any): void {
    this.commonService.applyFilters(filters);
  }

  onClearFilters(): void {
     this.commonService.clearFilters();
  }

  selectedcountry(event: any) {
    if (event.isUserInput) {
      // Handle country selection
    }
  }

  private initializeDefaultFilters(): void {
    const defaultFilters = new GetGridDataFilter();
    // Set default values based on employee data
    if (this.employeedata.length > 0) {
      defaultFilters.countryId = this.employeedata['countryId'] || '';
      defaultFilters.territoryId = this.employeedata['fieldTerritoryNumber']?.toString() || '';
    }
    
    // this.commonService.initializeDefaultFilters(defaultFilters);
  }
}

filter-sidebar.component.css

.filter-topbar {
  width: 100%;
  padding: 16px;
  background: #fafafa;
}

.filter-container {
  max-width: 100%;
}

.filter-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.filter-row {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  align-items: flex-end;
}

.filter-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 150px;
}

.form-label {
  font-size: 12px;
  font-weight: 500;
  color: #666;
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.filter-field .mat-form-field {
  width: 100%;
}

.filter-field .mat-form-field .mat-form-field-wrapper {
  padding-bottom: 0;
}

.action-buttons {
  display: flex;
  gap: 8px;
  align-items: flex-end;
  flex-shrink: 0;
  flex-direction: column;
}

.action-buttons button {
  min-width: 100px;
  height: 36px;
}

.advanced-filters {
  border-top: 1px solid #e0e0e0;
  padding-top: 16px;
  margin-top: 8px;
}

.options-filters {
  border-top: 1px solid #e0e0e0;
  padding-top: 16px;
  margin-top: 8px;
}

/* NEW: Toggle and Checkbox Styles */
.toggle-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 200px;
}

.radio-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.radio-group mat-radio-button {
  font-size: 14px;
}

.checkbox-field {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 150px;
}

.checkbox-field mat-checkbox {
  margin-top: 8px;
}

.advanced-toggle {
  display: flex;
  justify-content: center;
  margin-top: 12px;
}

.toggle-button {
  color: #1976d2;
  font-size: 14px;
}

.toggle-button mat-icon {
  margin-right: 4px;
}

/* Responsive Design */
@media (max-width: 1200px) {
  .filter-row {
    gap: 12px;
  }
  
  .filter-field,
  .toggle-field {
    min-width: 130px;
  }
}

@media (max-width: 768px) {
  .filter-topbar {
    padding: 12px;
  }
  
  .filter-row {
    flex-direction: column;
    gap: 12px;
  }
  
  .filter-field,
  .toggle-field,
  .checkbox-field {
    width: 100%;
    min-width: auto;
  }
  
  .action-buttons {
    width: 100%;
    justify-content: space-between;
  }
  
  .action-buttons button {
    flex: 1;
  }
  
  .radio-group {
    flex-direction: row;
    gap: 16px;
  }
}

filter-sidebar.component.html

<div class="filter-topbar">
  <div class="filter-container">
    <form [formGroup]="filterForm" class="filter-form">
      
      <!-- Row 1: Main Filters -->
      <div class="filter-row main-filters">
        <!-- IRI Week -->
        <div class="filter-field">
          <label class="form-label">IRI Week</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="iriWeek" (selectionChange)="onIriWeekChange()">
              <mat-option *ngFor="let week of iriWeeks" [value]="week.iri_week">
                {{week.iri_week_viewOnly}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Territory -->
        <div class="filter-field">
          <label class="form-label">Territory</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
              <mat-option [value]="-1">ALL</mat-option>
              <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
                {{territory.territory_name}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Store -->
        <div class="filter-field">
          <label class="form-label">Store</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="storeAuto" formControlName="store" placeholder="Search stores...">
            <button mat-button *ngIf="filterForm.get('store')?.value" matSuffix mat-icon-button (click)="clearStrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #storeAuto="matAutocomplete" (optionSelected)="onStoreSelected($event)">
              <mat-option *ngFor="let store of filteredStores" [value]="store.store_name" [matTooltip]="store.store_name">
                {{store.store_name}} ({{store.store_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- FSR (Field Service Representative) -->
        <div class="filter-field">
          <label class="form-label">FSR</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="fsrAuto" formControlName="fsr" placeholder="Search FSR...">
            <button mat-button *ngIf="filterForm.get('fsr')?.value" matSuffix mat-icon-button (click)="clearFsrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #fsrAuto="matAutocomplete" (optionSelected)="onFsrSelected($event)">
              <mat-option *ngFor="let fsr of filteredFSR" [value]="fsr.emp_name" [matTooltip]="fsr.emp_name">
                {{fsr.emp_name}} ({{fsr.emp_id}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
          <button mat-raised-button color="primary" (click)="onApplyFilters()">
            Apply Filters
          </button>
          <button mat-stroked-button (click)="onClearFilters()">
            Clear Filters
          </button>
        </div>
      </div>

      <!-- Row 2: Advanced Filters -->
      <div class="filter-row advanced-filters" [style.display]="showAdvancedFilters ? 'flex' : 'none'">
        <!-- State -->
        <div class="filter-field">
          <label class="form-label">State</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="stateAuto" formControlName="state">
            <button mat-button *ngIf="filterForm.get('state')?.value" matSuffix mat-icon-button (click)="clearStaCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #stateAuto="matAutocomplete" (optionSelected)="onStateSelected($event)">
              <mat-option *ngFor="let state of filteredState" [value]="state.state">
                {{state.state}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- City -->
        <div class="filter-field">
          <label class="form-label">City</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="cityAuto" formControlName="city">
            <button mat-button *ngIf="filterForm.get('city')?.value" matSuffix mat-icon-button (click)="clearcityCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #cityAuto="matAutocomplete" (optionSelected)="onCitySelected($event)">
              <mat-option *ngFor="let city of filteredCity" [value]="city.city">
                {{city.city}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Cluster -->
        <div class="filter-field">
          <label class="form-label">Cluster</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="clusterAuto" formControlName="cluster">
            <mat-autocomplete #clusterAuto="matAutocomplete" (optionSelected)="onClusterSelected($event)">
              <mat-option *ngFor="let cluster of filteredCluster" [value]="cluster.position_name">
                {{cluster.position_name}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Task -->
        <div class="filter-field">
          <label class="form-label">Task</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="taskAuto" formControlName="task">
            <button mat-button *ngIf="filterForm.get('task')?.value" matSuffix mat-icon-button (click)="clearTaskCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #taskAuto="matAutocomplete" (optionSelected)="onTaskSelected($event)">
              <mat-option *ngFor="let task of filteredTask" [value]="task.task_name">
                {{task.task_name}} ({{task.task_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>
      </div>

      <!-- Row 3: FSR Hours & Toggle Options -->
      <div class="filter-row options-filters" [style.display]="showAdvancedFilters ? 'flex' : 'none'">
        <!-- FSR Hours -->
        <div class="filter-field">
          <label class="form-label">FSR Hours</label>
          <mat-form-field appearance="outline">
            <input matInput formControlName="fsrHour" type="number" placeholder="Enter hours...">
          </mat-form-field>
        </div>

        <!-- Assigned/Unassigned Stores Toggle -->
        <div class="toggle-field">
          <label class="form-label">Store Assignment</label>
          <mat-radio-group formControlName="storeAssignment" class="radio-group">
            <mat-radio-button value="assigned">Assigned Stores</mat-radio-button>
            <mat-radio-button value="unassigned">Unassigned Stores</mat-radio-button>
            <mat-radio-button value="all">All Stores</mat-radio-button>
          </mat-radio-group>
        </div>

        <!-- Sample/Non-Sample Toggle -->
        <div class="toggle-field">
          <label class="form-label">Sample Type</label>
          <mat-radio-group formControlName="sampleType" class="radio-group">
            <mat-radio-button value="sample">Sample</mat-radio-button>
            <mat-radio-button value="nonSample">Non-Sample</mat-radio-button>
            <mat-radio-button value="all">All Types</mat-radio-button>
          </mat-radio-group>
        </div>

        <!-- Multi FSR Store Checkbox -->
        <div class="checkbox-field">
          <label class="form-label">Options</label>
          <mat-checkbox formControlName="multiFsrStore">Multi FSR Store</mat-checkbox>
        </div>
      </div>

      <!-- Advanced Filters Toggle -->
      <div class="advanced-toggle">
        <button mat-button type="button" (click)="toggleAdvancedFilters()" class="toggle-button">
          <mat-icon>{{showAdvancedFilters ? 'expand_less' : 'expand_more'}}</mat-icon>
          {{showAdvancedFilters ? 'Hide' : 'Show'}} Advanced Filters
        </button>
      </div>
    </form>
  </div>
</div>

filter-sidebar.component.ts

import { HttpClient } from '@angular/common/http';
import { Component, ElementRef, EventEmitter, Inject, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { catchError, debounceTime, distinctUntilChanged, firstValueFrom, map, Observable, of, startWith, Subject, switchMap, takeUntil, tap } from 'rxjs';
import { StoreFilter, FilterOptions, GetGridDataFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-filter-sidebar',
  templateUrl: './filter-sidebar.component.html',
  styleUrls: ['./filter-sidebar.component.css']
})
export class FilterSidebarComponent implements OnInit, OnDestroy {
  @Output() filtersChanged = new EventEmitter<GetGridDataFilter>();
  @Output() clearFilters = new EventEmitter<void>();

  filterForm!: FormGroup;
  showAdvancedFilters = false;
  showSpinner = false;
  
  // Data arrays
  employeedata: any[] = [];
  iriWeeks: any[] = [];
  territories: any[] = [];
  filteredStores: any[] = [];
  filteredState: any[] = [];
  filteredCity: any[] = [];
  filteredCluster: any[] = [];
  filteredTask: any[] = [];
  filteredFSR: any[] = [];

  // Selected values
  selectedStoreNumber = '';
  selectedState = '';
  selectedCity = '';
  selectedCluster = '';
  selectedTask = '';
  selectedFsrId = '';
  areaNBRctrl = new FormControl();
  private unsubscribe$ = new Subject<void>();
  private loggeduser: string;

  constructor(
    private fb: FormBuilder,
    private commonService: CommonService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
  ) {
    this.initializeForm();
    this.loggeduser = localStorage.getItem("loggedUserId") || '';
  }

  async ngOnInit(): Promise<void> {
    try {
      this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
      await this.getIriWeek();
      await this.getTerritory();
      this.setupFormSubscriptions();
      // Apply default filters after initialization
      this.applyDefaultFilters();
    } catch (error) {
      console.error('Error initializing filter component:', error);
    }
  }

  private initializeForm(): void {
    this.filterForm = this.fb.group({
      iriWeek: [''],
      territory: [''],
      store: [''],
      state: [''],
      city: [''],
      cluster: [''],
      task: [''],
      fsr: [''],
      fsrHour: [''],
      storeAssignment: ['all'], // assigned, unassigned, all
      sampleType: ['all'], // sample, nonSample, all
      multiFsrStore: [false]
    });
  }

  // FIXED: Get IRI Week with proper subscription pattern
  private getIriWeek(): void {
    this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe({
        next: (response) => {
          this.iriWeeks = response;
          // Set default to second item (index 1) as in your original code
          if (this.iriWeeks.length > 1) {
            this.filterForm.get('iriWeek')?.setValue(this.iriWeeks?.[0]?.['iri_week'], { emitEvent: false });
          }
        },
        error: (error) => { 
          console.error('Error fetching IRI weeks:', error); 
        }
      });
  }

  // FIXED: Get Territory with proper subscription pattern
  private getTerritory(): void {
    this.showSpinner = true;
    this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe({
        next: (response) => {
          this.territories = response;
          // Set default territory based on employee data
          const defaultTerritory = this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'];
          this.filterForm.get('territory')?.setValue(defaultTerritory, { emitEvent: false });
          this.areaNBRctrl.setValue( this.territories?.[0]?.['area'])
          this.showSpinner = false;
        },
        error: (error) => { 
          console.error('Error fetching territories:', error);
          this.showSpinner = false; 
        }
      });
  }

  private setupFormSubscriptions(): void {
    // Store autocomplete
    this.filterForm.get('store')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getStore(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(stores => {
      this.filteredStores = stores || [];
      this.showSpinner = false;
    });

    // State autocomplete
    this.filterForm.get('state')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getState(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(states => {
      this.filteredState = states || [];
      this.showSpinner = false;
    });

    // City autocomplete
    this.filterForm.get('city')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCity(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(cities => {
      this.filteredCity = cities || [];
      this.showSpinner = false;
    });

    // Cluster autocomplete
    this.filterForm.get('cluster')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCluster(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(clusters => {
      this.filteredCluster = clusters || [];
      this.showSpinner = false;
    });

    // Task autocomplete
    this.filterForm.get('task')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getTask(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(tasks => {
      this.filteredTask = tasks || [];
    });

    // FSR autocomplete
    this.filterForm.get('fsr')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getFsr(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(fsrs => {
      this.filteredFSR = fsrs || [];
    });
  }

 
  getStore(searchText: string) {
    if (!searchText || searchText.length < 3) {
      return of([]);
    }

    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetStore', payload)
      .pipe(catchError(() => of([])));
  }

  getState(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetState', payload)
      .pipe(catchError(() => of([])));
  }

  getCity(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCity', payload)
      .pipe(catchError(() => of([])));
  }

  getCluster(searchText: string) {
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCluster', payload)
      .pipe(catchError(() => of([])));
  }

  getTask(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetTask', payload)
      .pipe(catchError(() => of([])));
  }

  getFsr(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsr', payload)
      .pipe(catchError(() => of([])));
  }

  // Event handlers for IRI Week and Territory changes
  onIriWeekChange(): void {
    // Clear dependent fields when IRI week changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  onTerritoryChange(): void {
    // this.areaNBRctrl.setValue(ter.area)
    // Clear dependent fields when territory changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  // Selection event handlers
  onStoreSelected(event: any) {
    const selectedStore = this.filteredStores.find(store => store.store_name === event.option.value);
    this.selectedStoreNumber = selectedStore?.store_number || '';
  }

  onStateSelected(event: any) {
    const selectedState = this.filteredState.find(state => state.state === event.option.value);
    this.selectedState = selectedState?.state || '';
  }

  onCitySelected(event: any) {
    const selectedCity = this.filteredCity.find(city => city.city === event.option.value);
    this.selectedCity = selectedCity?.city || '';
  }

  onClusterSelected(event: any) {
    const selectedCluster = this.filteredCluster.find(cluster => cluster.position_name === event.option.value);
    this.selectedCluster = selectedCluster?.position_number || '';
  }

  onTaskSelected(event: any) {
    const selectedTask = this.filteredTask.find(task => task.task_name === event.option.value);
    this.selectedTask = selectedTask?.task_number || '';
  }

  onFsrSelected(event: any) {
    const selectedFsr = this.filteredFSR.find(fsr => fsr.emp_name === event.option.value);
    this.selectedFsrId = selectedFsr?.emp_id || '';
  }

  // Control methods
  toggleAdvancedFilters(): void {
    this.showAdvancedFilters = !this.showAdvancedFilters;
  }


  onApplyFilters(): void {

    const formValue = this.filterForm.value;
    
    const filters = new GetGridDataFilter();
    filters.countryId = "1"
    filters.lanId=this.loggeduser;
    filters.iriWeek = formValue.iriWeek || '';
    filters.territoryId = formValue.territory || '';
    filters.storeNumber = this.selectedStoreNumber;
    filters.storeName = formValue.store || '';
    filters.state = this.selectedState;
    filters.city = this.selectedCity;
    filters.positionNumber = this.selectedCluster;
    filters.taskNumber = this.selectedTask;
    filters.empId = this.selectedFsrId;
    filters.fsrHour = formValue.fsrHour || '';
    filters.area = this.areaNBRctrl.value||'23';
    filters.fsrOver25hrs='false';
    filters.fsrOver6hrs='false';
    filters.fsrHourOperator= 'NA';
    filters.temporary='false'
    // Handle radio button selections
    if (formValue.storeAssignment === 'assigned') {
      filters.assignedStores = 'true';
      filters.unassignedStores = 'false';
    } else if (formValue.storeAssignment === 'unassigned') {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'true';
    } else {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'false';
    }

    if (formValue.sampleType === 'sample') {
      filters.sample = 'true';
      filters.nonSample = 'false';
    } else if (formValue.sampleType === 'nonSample') {
      filters.sample = 'false';
      filters.nonSample = 'true';
    } else {
      filters.sample = 'false';
      filters.nonSample = 'false';
    }

    filters.multiFsrStore = formValue.multiFsrStore ? 'true' : 'false';
    
    this.filtersChanged.emit(filters);
  }

  // MISSING FUNCTION: Clear Filters
  onClearFilters(): void {
    this.filterForm.reset({
      iriWeek: this.iriWeeks.length > 1 ? this.iriWeeks?.[0]?.['iri_week'] : '',
      territory: this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'],
      storeAssignment: 'all',
      sampleType: 'all',
      multiFsrStore: false
    });
    this.clearSelectedValues();
    this.clearFilters.emit();
  }

  // MISSING FUNCTION: Apply Default Filters on Load
  private applyDefaultFilters(): void {
    // Wait a moment for form to be properly initialized
    setTimeout(() => {
      this.onApplyFilters();
    }, 500);
  }

  private clearSelectedValues(): void {
    this.selectedStoreNumber = '';
    this.selectedState = '';
    this.selectedCity = '';
    this.selectedCluster = '';
    this.selectedTask = '';
    this.selectedFsrId = '';
  }

  // Clear individual controls
  clearStrCtrl() { 
    this.filterForm.get('store')?.reset(); 
    this.selectedStoreNumber = '';
  }
  clearStaCtrl() { 
    this.filterForm.get('state')?.reset(); 
    this.selectedState = '';
  }
  clearcityCtrl() { 
    this.filterForm.get('city')?.reset(); 
    this.selectedCity = '';
  }
  clearTaskCtrl() { 
    this.filterForm.get('task')?.reset(); 
    this.selectedTask = '';
  }
  clearFsrCtrl() { 
    this.filterForm.get('fsr')?.reset(); 
    this.selectedFsrId = '';
  }

  ngOnDestroy(): void {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}


store-table.component.css

.table-container {
  width: 100%;
  height: 100%;
  position: relative;
  min-height: 66vh;
  max-height: 66vh;
  overflow-x: auto;
}

.table-card {
  height: 100%;
  display: flex;
  flex-direction: column;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
}

.table-wrapper {
  flex: 1;
  overflow: auto;
  min-height: 400px;
}

/* FIXED: Table structure based on your working example */
.store-table {
  width: 100%;
  max-width: 100%;
  background: white;
  display: table;
  border-collapse: collapse;
  margin: 0px;
}

.store-table .mat-header-row {
  height: 40px;
}

.store-table .mat-row {
  max-width: 120%;
  cursor: pointer;
  transition: background-color 0.2s;
}

.store-table .mat-row:hover {
  background-color: mintcream;
}

.store-table .mat-row.selected-row {
  background-color: lightyellow;
}

/* FIXED: Header styling like your working example */
.mat-header-style {
  font-weight: bold !important;
  font-size: 15px !important;
  background-color: lightgray !important;
}

/* FIXED: Column-specific styles with fixed widths (like your working example) */
.mat-column-store_number {
  width: 10%;
  min-width: 140px;
  max-width: 200px;
  padding: 0px 10px;
}

.mat-column-store_name {
  width: 20%;
  min-width: 200px;
  max-width: 500px;
  padding: 0px 10px;
}

.mat-column-addr_line1 {
  width: 20%;
  min-width: 200px;
  max-width: 500px;
  padding: 0px 10px;
}

.mat-column-city {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

.mat-column-state {
  width: 5%;
  min-width: 80px;
  max-width: 100px;
  padding: 0px 10px;
}

.mat-column-zip {
  width: 8%;
  min-width: 80px;
  max-width: 120px;
  padding: 0px 10px;
}

.mat-column-assigned_to {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

.mat-column-expected_collection_time {
  width: 10%;
  min-width: 120px;
  max-width: 200px;
  padding: 0px 10px;
}

.mat-column-position_name {
  width: 15%;
  min-width: 150px;
  max-width: 300px;
  padding: 0px 10px;
}

/* FIXED: Caret styling  */
.caret {
  display: inline-block;
  margin-right: 5px;
  margin-top: -1px;
  transition: transform 0.3s;
  font-size: 18px;
  font-weight: 800;  
  /* transform: rotate(90deg); */
  cursor: pointer;
}

.caret.clicked  {
  transform: rotate(180deg);
  margin-top: -5px;
}

/* Cell styling */
.store-number-cell {
  font-weight: 500;
}

.store-name-cell .store-name {
  font-weight: 500;
  color: #333;
}

.address-cell {
  color: #555;
}

.state-badge {
  background: #e8f5e8;
  color: #2e7d32;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
  display: inline-block;
}

.assignment-badge {
  padding: 6px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
  display: inline-block;
  white-space: nowrap;
}

.assignment-badge.assigned {
  background: #4caf50;
  color: white;
}

.assignment-badge.not-assigned {
  background: #ff9800;
  color: white;
}

.collection-time-cell {
  color: #666;
  font-size: 13px;
}

.cluster-cell {
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 12px;
  background: #f5f5f5;
  color: #333;
  border-radius: 4px;
}

/* FIXED: Expanded table styling (exactly like your working example) */
.expanded-table {
  margin-top: 5px;
  margin-bottom: 15px;
  margin-left: 70px;
  border-collapse: collapse;
  border: 1px solid #ddd;
  font-size: 14px;
  width: calc(100% - 140px); /* Full width minus margins */
}

.expanded-table th,
.expanded-table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid #ddd;
  white-space: nowrap;
}

.expanded-table th {
  background-color: #f2f2f2;
  font-weight: bold;
}

.expanded-table td[style*="max-width"] {
  white-space: normal !important;
  word-wrap: break-word;
}

/* Detail row styling */
.detail-row {
  background: #fafafa;
  overflow: hidden;
}

/* Paginator */
.table-paginator {
  border-top: 1px solid #e0e0e0;
  background: #fafafa;
  position: sticky;
  bottom: 0;
  z-index: 10;
  height: 52px;
}

/* Responsive design */
@media (max-width: 768px) {
  .table-wrapper {
    overflow-x: auto;
  }
  
  .store-table {
    min-width: 800px;
  }
  
  .expanded-table {
    margin-left: 20px;
    width: calc(100% - 40px);
    font-size: 12px;
  }
  
  .expanded-table th,
  .expanded-table td {
    padding: 6px 8px;
  }
}

/* Spinner styling */
.mat-spinner-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.mat-spinner {
  z-index: 111;
}

store-table.component.html

<div class="table-container">
  <mat-card class="table-card">
    <!-- <mat-card-header>
      <mat-card-title>Store Assignment Data</mat-card-title>
      <mat-card-subtitle>{{dataSource.data.length}} stores found</mat-card-subtitle>
    </mat-card-header>
     -->
    <mat-card-content>
      <div class="table-wrapper">
        <!-- FIXED: Using your working table structure -->
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2">
          
          <!-- Store Number Column with Expansion -->
          <ng-container matColumnDef="store_number">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store #</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
              <span class="caret" #caretIcon id="caretIcon">▼</span>
              <span *ngIf="!element.hasDetails">&nbsp;&nbsp;&nbsp;&nbsp;</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Store Name Column -->
          <ng-container matColumnDef="store_name">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store Name</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-name-cell">
              <div class="store-info">
                <span class="store-name" (click)="openProximityDataDialog(element);$event.stopPropagation();">{{element.StoreName}}</span>
              </div>
            </mat-cell>
          </ng-container>

          <!-- Store Address Column -->
          <ng-container matColumnDef="addr_line1">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store Address</mat-header-cell>
            <mat-cell *matCellDef="let element" class="address-cell">
              {{element.AddrLine1}}
            </mat-cell>
          </ng-container>

          <!-- City Column -->
          <ng-container matColumnDef="city">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">City</mat-header-cell>
            <mat-cell *matCellDef="let element" class="city-cell">{{element.City}}</mat-cell>
          </ng-container>

          <!-- State Column -->
          <ng-container matColumnDef="state">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">State</mat-header-cell>
            <mat-cell *matCellDef="let element" class="state-cell">
              <span class="state-badge">{{element.State}}</span>
            </mat-cell>
          </ng-container>

          <!-- Zip Column -->
          <ng-container matColumnDef="zip">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Zip</mat-header-cell>
            <mat-cell *matCellDef="let element" class="zip-cell">{{element.Zip}}</mat-cell>
          </ng-container>

          <!-- Assigned To Column -->
          <ng-container matColumnDef="assigned_to">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Assigned To</mat-header-cell>
            <mat-cell *matCellDef="let element" class="assigned-cell">
              <span class="assignment-badge" [ngClass]="getAssignmentClass(element.AssignedTo)">
                {{element.AssignedTo}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Average Collection Time Column -->
          <ng-container matColumnDef="expected_collection_time">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Avg Coll Time</mat-header-cell>
            <mat-cell *matCellDef="let element" class="collection-time-cell">
              {{formatCollectionTime(element.ExpectedCollectionTime)}}
            </mat-cell>
          </ng-container>

          <!-- Cluster Column -->
          <ng-container matColumnDef="position_name">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Cluster</mat-header-cell>
            <mat-cell *matCellDef="let element" class="cluster-cell">
              {{getClusterDisplay(element.PositionName)}}
            </mat-cell>
          </ng-container>

          <!-- FIXED: Header and Data Rows (like your working example) -->
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row 
            *matRowDef="let row; columns: displayedColumns; let i = index"
            [ngClass]="{'selected-row': row === selectedRow}"
            class="table-row"
            (click)="selectedRow = selectedRow === row ? null : row"
            [cdkDetailRow]="row" 
            [cdkDetailRowTpl]="tpl"
            (toggleChange)="GetSubgridData($event, row)"
            matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator 
        [pageSizeOptions]="[5, 10, 20, 50]" 
        showFirstLastButtons
        class="table-paginator">
      </mat-paginator>

      <!-- FIXED: Inner Table Template  -->
      <ng-template #tpl let-element>
        <div class="mat-row detail-row" [@detailExpand] style="overflow: hidden;">
          <table class="expanded-table"> 
            <tr> 
              <th>Task Name</th>
              <th>Assigned To</th>              
              <th>CSR Info</th>
              <th>Wave</th>
              <th>Avg Coll Time</th>
             
            </tr>
            <tr *ngFor="let item of SubgridData">
              <td> {{item.TaskName}}</td>
              <td>{{item.AssignedTo}} </td>              
              <td>{{item.CsrInfo}} </td>
              <td >
                {{item.Wave}}       
              </td>
              <td >
                {{item.ExpectedCollectionTime}}</td>
             
            </tr>       
          </table>
        </div>
      </ng-template>
    </mat-card-content>
  </mat-card>
</div>

store-table.component.ts

import { trigger, state, style, transition, animate } from '@angular/animations';
import { SelectionModel } from '@angular/cdk/collections';
import { HttpClient } from '@angular/common/http';
import { Component, Inject, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import { catchError, of, Subject, takeUntil } from 'rxjs';
import { ProximityDialogComponent } from 'src/app/dialog/proximity-dialog/proximity-dialog.component';
import { CdkDetailRowDirective } from 'src/app/shared/cdk-detail-row.directive';
import { GetGridDataFilter, Store } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-store-table',
  templateUrl: './store-table.component.html',
  styleUrls: ['./store-table.component.css'],
  animations: [
    trigger('detailExpand', [
      state('collapsed', style({height: '0px', minHeight: '0'})),
      state('expanded', style({height: '*'})),
      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
    ]),
  ],
})
export class StoreTableComponent implements OnInit, OnDestroy {
   @ViewChild(MatTable, { static: false }) table:MatTable<any>;
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;

  SubgridData=[];
  private unsubscribe$ = new Subject<void>();
  displayedColumns: string[] = ['store_number','store_name', 'addr_line1', 'city', 'state', 'zip', 'assigned_to', 'expected_collection_time', 'position_name'];
  dataSource = new MatTableDataSource<Store>([]);
  selection = new SelectionModel<Store>(true, []);
  GetGridDataFilter:GetGridDataFilter 
  private destroy$ = new Subject<void>();
  loggeduser:string
    selectedRow;
  isExpansionDetailRow = (index, row) => row.hasOwnProperty('detailRow');
  private expandedRow:CdkDetailRowDirective;
  constructor(private commonService: CommonService,
  public http: HttpClient,
  @Inject('BASE_URL') public baseUrl: string,
  private dialog:MatDialog) {this.loggeduser = localStorage.getItem("loggedUserId"); }

  ngOnInit(): void {
    this.commonService.gridData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(stores => {
       this.dataSource=new MatTableDataSource<any>([]);
         this.dataSource = new MatTableDataSource<any>(stores);
        this.dataSource.paginator = this.paginator;
        this.dataSource.sort = this.sort;
      });
  }
getGridData(){
// this.showSpinner= true
 const payLoad:GetGridDataFilter ={
   countryId: "1",
   countryName: '',
   lanId: this.loggeduser,
   iriWeek: '2404',
   iriWeekViewOnly: '',
   area: '23',
   territoryId: '52',
   territoryName: '',
   fromDate: '',
   toDate: '',
   storeNumber: '',
   storeName: '',
   state: '',
   city: '',
   taskNumber: '',
   taskName: '',
   positionNumber: '',
   positionName: '',
   empId: '',
   firstName: '',
   lastName: '',
   empName: '',
   fsrOver25hrs: 'false',
   fsrOver6hrs: 'false',
   fsrHour: '',
   fsrHourOperator: 'NA',
   assignedStores: 'false',
   unassignedStores: 'false',
   sample: 'false',
   nonSample: 'false',
   multiFsrStore: 'false',
   vacation: 'false',
   action: '',
   comment: '',
   fmEmail: '',
   fmEmpId: '',
   assignmentMode: '',
   temporary: 'false'
 }
    this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetGridData',payLoad).pipe(takeUntil(this.unsubscribe$)).subscribe( { 
      next: 
      (response) => {                  
        this.dataSource=new MatTableDataSource<any>([]);
         this.dataSource = new MatTableDataSource<any>(response);
        this.dataSource.paginator = this.paginator;
        this.dataSource.sort = this.sort;
       },
       error: 
       (error) => { console.error(error); },
      });   
}

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  /** Selects all rows if they are not all selected; otherwise clear selection. */
 

  /** The label for the checkbox on the passed row */
  checkboxLabel(row?: Store): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.id}`;
  }


  /** Get full address string */
  getFullAddress(store: Store): string {
    return `${store.addr_line1}, ${store.city}, ${store.state} ${store.zip}`;
  }

  /** Format expected collection time */
  formatCollectionTime(time: string): string {
    return time || 'Not specified';
  }

  /** Get cluster display name */
  getClusterDisplay(positionName: string): string {
    return positionName || 'N/A';
  }

  /** Get assignment status styling */
  getAssignmentClass(assignedTo: string): string {
    return assignedTo === 'NOT ASSIGNED' ? 'not-assigned' : 'assigned';
  }

 GetSubgridData(cdkDetailRow: CdkDetailRowDirective,row ) : void {   
    if(this.expandedRow && this.expandedRow.isExpanded ){     
      this.expandedRow.toggleRow();       
    }
    this.expandedRow = cdkDetailRow.isExpanded ? cdkDetailRow : undefined;


    if (cdkDetailRow.isExpandedClass) {  
     
         this.SubgridData=[]
        //  this.showSpinner=true
          this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetSubgridData',{IriWeek:row.IriWeek,StoreNumber:row.StoreNumber}).subscribe((response) => {
          this.SubgridData = response;   
      // this.showSpinner=false;      
      }, error => { console.error(error); })   
    }
    
   
    this.updateCaratIcon(cdkDetailRow,cdkDetailRow.isExpanded);
    

  }


private updateCaratIcon(cdkDetailRow:CdkDetailRowDirective,expanded:boolean){
  if(cdkDetailRow && cdkDetailRow.viewContainerRef){   
    const caret = cdkDetailRow.viewContainerRef.element.nativeElement.querySelector('.caret');
  if(caret){    
    if(expanded){     
      caret.classList.add('clicked');
    }else{      
      caret.classList.remove('clicked');
    }
  }
  }
}

  UpdateTableWidth(){
  const tablewidth = document.getElementById('table'); 
  if(this.displayedColumns.length == 20){
    tablewidth.style.width = 150+'%' ;      
  }
 }

 isExpanded(store: any): boolean {
  return this.selectedRow === store ;
}

openProximityDataDialog(data:any){
    const dialogRef = this.dialog.open(ProximityDialogComponent,{
      width: '40vw',
      maxWidth: '40vw',
      minWidth: '600px',
      // height: '55vh',
      maxHeight: '55vh',
      minHeight:'250px',
      data:data,
      disableClose: true,
    })
  }

}


proximity-dialog.component.css

.mat-dialog-title {
  margin: 0px;
  margin-bottom: 10px;
  font-size: medium;
  background-color: lightgray;
  padding-left: 1em;
  padding-right: 1em;
  cursor: grab;
}

.mat-dialog-body {   
  background-color: white;  
}


.close-btn{
  float:right; 
  color: #4e6a87; 
  margin-top: 4px;
}

.close-btn-icon{
  color: rgb(87 135 187);
}

.close-btn-icon:hover{
  color: black;
}

.close-btn:hover{ 
  color: rgb(87 135 187);
  background: #ccd6df;
  height: 20px;
}

.table-container {	
  position: relative;
  /* min-height: 35vh; */
  max-height: 60vh;
  min-width: 100%;   
  /* margin-top: 5%; */
  /* height: calc(50vh - 5px);	 */
  overflow: auto;
  margin-bottom: 10px;
  box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12);
}

.mat-elevation-z8{
  width: 100%;
 /* min-height: 40vh; */
  /*  max-height: 40vh; */
  box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12) !important;

}

.table-container {	
  position: relative;
  /* min-height: 35vh; */
  max-height: 30vh;
  min-width: 100%;   
  /* margin-top: 5%; */
  /* height: calc(50vh - 5px);	 */
  overflow: auto;
  margin-bottom: 10px;
}
.mat-table{
  font-weight: 500;
  font-size: 15px;
  box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12);
}

tr.mat-header-row{  
  background-color: #673ab7;  
  height: 35px;
}

tr.mat-row{
  height: 35px;
  white-space: nowrap;
}

.mat-row:hover {
  background-color: #e7e4e4;
}

.note-message{
  margin-top: 10px;
  padding: 10px;
  color: #ff0000;
  font-size: 14px;
  font-weight: bold;
  border: 1px solid #ffcccc;
  background-color: #ffe6e6;
  border-radius: 4px;
}

.highlighted-note{
  color: #0c07eb;
  font-weight: bold;
}

proximity-dialog.component.html

<h4 mat-dialog-title class="title-style" cdkDrag cdkDragRootElement=".cdk-overlay-pane" cdkDragHandle>
    Collector proximity for: {{ data.StoreName }} &nbsp;({{ data.StoreNumber }})
    <span class="close-btn" title="Close" [mat-dialog-close]="true"><mat-icon class="close-btn-icon">
            cancel_presentation</mat-icon></span>
    <!--<span style="float:right;color:slategray;padding-top:10px;" [mat-dialog-close]="true"><fa-icon [icon]="windowCloseIcon"></fa-icon></span>-->
</h4>

<mat-dialog-content class="mat-dialog-body">

    <div class="table-container">    

        <table mat-table [dataSource]="dataSource" class="mat-elevation-z8">
                        <!-- Employee Id -->
                        <ng-container matColumnDef="empId">
                            <th mat-header-cell *matHeaderCellDef  style="width: 130px; color: #fff3f3;"> Employee Id </th>
                            <td mat-cell *matCellDef="let element"> {{element.empId}} </td>
                        </ng-container>
                
                                      <!-- Employee Name -->
                        <ng-container matColumnDef="empName">
                            <th mat-header-cell *matHeaderCellDef  style="width: 200px; color: #fff3f3;;">Employee Name </th>
                            <td mat-cell *matCellDef="let element"> {{element.firstName}} {{element.lastName}}                            
                
                        </td>
                        </ng-container>
                
                                        <!-- Employee distance -->
                        <ng-container matColumnDef="distance">
                            <th mat-header-cell *matHeaderCellDef style="width: 100px;color: #fff3f3;;">Distance </th>
                            <td mat-cell *matCellDef="let element"> {{element.mile}} <span *ngIf="element.distancePayout == '0'">(NA)</span></td>
                        </ng-container>

                        <ng-container matColumnDef="cost">
                            <th mat-header-cell *matHeaderCellDef style="width: 100px;color: #fff3f3;;">Cost </th>
                            <td mat-cell *matCellDef="let element"> {{element.totalCost | currencyFormat}}</td>
                        </ng-container>
                
                        <ng-container matColumnDef="time">
                            <th mat-header-cell *matHeaderCellDef style="width: 100px;color: #fff3f3;;">Travel Time<br>(MM:SS) </th>
                            <td mat-cell *matCellDef="let element"> {{element.time}}</td>
                        </ng-container>
            
                        <ng-container matColumnDef="toll">
                            <th mat-header-cell *matHeaderCellDef style="width: 100px;color: #fff3f3;;">Toll </th>
                            <td mat-cell *matCellDef="let element"> {{element.toll | currencyFormat}}</td>
                        </ng-container>
                
                        <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
                        <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
        </table>
    </div>

</mat-dialog-content>



<footer>
    <div class="mat-spinner-container">
        <mat-spinner mode="indeterminate" *ngIf="showSpinner"></mat-spinner>
        <div *ngIf="showSpinner" style="position: relative; left: 10px">
            Loading...
        </div>
    </div>
</footer>

proximity-dialog.component.ts

import { HttpClient } from '@angular/common/http';
import { Component, Inject, OnInit } from '@angular/core';
import { MAT_DIALOG_DATA } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { Subject, takeUntil } from 'rxjs';
import { CommonService } from 'src/app/shared/common.service';
import { SnackbarService } from 'src/app/shared/snackbar.service';

@Component({
  selector: 'app-proximity-dialog',
  templateUrl: './proximity-dialog.component.html',
  styleUrls: ['./proximity-dialog.component.css']
})
export class ProximityDialogComponent implements OnInit {
  private unsubscribe$ = new Subject<void>();
  public showSpinner: boolean = false;
  displayedColumns:string[]=['empId','empName','time','distance','cost','toll'];
  dataSource:MatTableDataSource<any>
  isCollectorIDFound:boolean=false
  isNonSampleCStore:boolean=false
  constructor(
    @Inject(MAT_DIALOG_DATA) public data: any,
    private http: HttpClient, 
    @Inject('BASE_URL') private baseUrl: string,
    public service: CommonService,
    private _snackBar: SnackbarService,
  ) { }

  ngOnInit(): void {
    this.getProximityData()
  }

  getProximityData(){
    this.showSpinner = true;
    this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetClosestFsr',{StoreNumber:this.data.StoreNumber,CountryId:"1"}).pipe(takeUntil(this.unsubscribe$)).subscribe( { 
      next: 
      (response) => {  
        this.dataSource = new MatTableDataSource(response)   
        this.showSpinner= false           
        
       },
       error: 
       (error) => { console.error(error); this.showSpinner= false },
      });   
  }

}

private gridDataSubject = new BehaviorSubject<any[]>([]);
  public gridData$ = this.gridDataSubject.asObservable();

// Centralized API methods
getIriWeeks(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetIriWeek`)
    .pipe(catchError(this.handleError<any[]>('getIriWeeks', [])));
}

getTerritories(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetTerritory`)
    .pipe(catchError(this.handleError<any[]>('getTerritories', [])));
}

searchStores(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetStore`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStores', [])));
}

searchStates(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetState`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStates', [])));
}

searchCities(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCity`, payload)
    .pipe(catchError(this.handleError<any[]>('searchCities', [])));
}

searchClusters(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCluster`, payload)
    .pipe(catchError(this.handleError<any[]>('searchClusters', [])));
}

searchTasks(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetTask`, payload)
    .pipe(catchError(this.handleError<any[]>('searchTasks', [])));
}

getGridData(payload: GetGridDataFilter): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetGridData`, payload)
    .pipe(catchError(this.handleError<any[]>('getGridData', [])));
}

private handleError<T>(operation = 'operation', result?: T) {
  return (error: any): Observable<T> => {
    console.error(`${operation} failed:`, error);
    return of(result as T);
  };
}

 // MISSING FUNCTION 1: Apply Filters
  applyFilters(filters: GetGridDataFilter): void {
    this.filtersSubject.next(filters);
    // Call GetGridData API with filters
    this.getGridData(filters).subscribe({
      next: (data) => {
        this.gridDataSubject.next(data);
      },
      error: (error) => {
        console.error('Error applying filters:', error);
        this.gridDataSubject.next([]);
      }
    });
  }

  // MISSING FUNCTION 2: Clear Filters  
  clearFilters(): void {
    const defaultFilters = new GetGridDataFilter();
    this.filtersSubject.next(defaultFilters);
    this.gridDataSubject.next([]);
  }
