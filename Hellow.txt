given an array of prices where price[D] is the price of product onthe Dth day, you want to maximize your profit by choosing a single day to buy only one stock and choose a diffret day in the future to seel that stock retun the max profit you can achive from the trascation if you cannot make any profit return 0

example 
price =[7,1,5,3,6,4]
output =5
explnation : buy on day 2 price = 1 and sell on day 5 price = 6 prfit 6-1=5
note that buying on day 2 and sellig on day 1 is not allowed 

function maxProfit(prices:Array<number>) {
    if (prices.length < 2) {
        return 0; // Not enough data to make a profit
    }

    let minPrice = prices[0]; // Initialize with the price on the first day
    let maxProfit = 0; // Initialize maximum profit to 0

    for (let i = 1; i < prices.length; i++) {
        let currentPrice = prices[i];
        let potentialProfit = currentPrice - minPrice;

        // Update maxProfit if the current potential profit is higher
        if (potentialProfit > maxProfit) {
            maxProfit = potentialProfit;
        }

        // Update minPrice if the current price is lower
        if (currentPrice < minPrice) {
            minPrice = currentPrice;
        }
    }

    return maxProfit;
}

const prices = [100, 180, 260, 310, 40, 535, 695]
console.log(maxProfit(prices)); 

Test Case 1: Normal Case
Input: [7, 1, 5, 3, 6, 4]
Expected Output: 5
Explanation: Buy at price 1 and sell at price 6. Profit is 6 - 1 = 5.

Test Case 2: No Profit
Input: [7, 6, 4, 3, 1]
Expected Output: 0
Explanation: Prices keep decreasing, so no profit can be made.

Test Case 3: Single Day
Input: [5]
Expected Output: 0
Explanation: Not enough days to make a transaction.

Test Case 4: Two Days Increasing
Input: [2, 4]
Expected Output: 2
Explanation: Buy at price 2 and sell at price 4. Profit is 4 - 2 = 2.

Test Case 5: Two Days Decreasing
Input: [5, 3]
Expected Output: 0
Explanation: Prices decrease, so no profit can be made.

Test Case 6: Prices Remain Constant
Input: [3, 3, 3, 3, 3]
Expected Output: 0
Explanation: No matter when you buy and sell, the price is the same, so profit is 0.

Test Case 7: Multiple Opportunities
Input: [1, 2, 3, 4, 5, 6]
Expected Output: 5
Explanation: Buy at price 1 and sell at price 6. Profit is 6 - 1 = 5.

Test Case 8: Large Array with Random Values
Input: [8, 1, 5, 3, 7, 6, 4, 10]
Expected Output: 9
Explanation: Buy at price 1 and sell at price 10. Profit is 10 - 1 = 9.

Test Case 9: Decreasing and Then Increasing
Input: [10, 7, 5, 8, 11]
Expected Output: 6
Explanation: Buy at price 5 and sell at price 11. Profit is 11 - 5 = 6.

Test Case 10: No Transaction Needed
Input: [1, 1, 1, 1]
Expected Output: 0
Explanation: All prices are the same, so no profit can be made.

Test Case 11: Large Array with Mixed Values
Input: [100, 180, 260, 310, 40, 535, 695]
Expected Output: 655
Explanation: Buy at price 40 and sell at price 695. Profit is 695 - 40 = 655.



function runningSums(arr: number[]): number[] {
    const result: number[] = [];
    let sum = 0;

    arr.forEach(num => {
        sum += num;
        result.push(sum);
    });

    return result;
}

// Example usage
const array = [1, 2, 3, 4];
console.log(runningSums(array)); // Output: [1, 3, 6, 10]

est Case 1: Normal Case
Input: [1, 2, 3, 4]
Expected Output: [1, 3, 6, 10]
Explanation: Running sums are calculated as follows:

Sum of first element: 1
Sum of first two elements: 1 + 2 = 3
Sum of first three elements: 1 + 2 + 3 = 6
Sum of all elements: 1 + 2 + 3 + 4 = 10
Test Case 2: All Zeros
Input: [0, 0, 0, 0]
Expected Output: [0, 0, 0, 0]
Explanation: All elements are zero, so running sums remain zero.

Test Case 3: Single Element
Input: [5]
Expected Output: [5]
Explanation: With only one element, the running sum is the same as the element itself.

Test Case 4: Negative Numbers
Input: [-1, -2, -3, -4]
Expected Output: [-1, -3, -6, -10]
Explanation: Running sums are calculated as follows:

Sum of first element: -1
Sum of first two elements: -1 + (-2) = -3
Sum of first three elements: -1 + (-2) + (-3) = -6
Sum of all elements: -1 + (-2) + (-3) + (-4) = -10
Test Case 5: Mixed Positive and Negative Numbers
Input: [3, -1, 2, -3]
Expected Output: [3, 2, 4, 1]
Explanation: Running sums are calculated as follows:

Sum of first element: 3
Sum of first two elements: 3 + (-1) = 2
Sum of first three elements: 3 + (-1) + 2 = 4
Sum of all elements: 3 + (-1) + 2 + (-3) = 1
Test Case 6: Large Numbers
Input: [1000, 2000, 3000, 4000]
Expected Output: [1000, 3000, 6000, 10000]
Explanation: Running sums are calculated as follows:

Sum of first element: 1000
Sum of first two elements: 1000 + 2000 = 3000
Sum of first three elements: 1000 + 2000 + 3000 = 6000
Sum of all elements: 1000 + 2000 + 3000 + 4000 = 10000
Test Case 7: Mixed Elements Including Large and Small Values
Input: [1, 1000, -500, 200]
Expected Output: [1, 1001, 501, 701]
Explanation: Running sums are calculated as follows:

Sum of first element: 1
Sum of first two elements: 1 + 1000 = 1001
Sum of first three elements: 1 + 1000 - 500 = 501
Sum of all elements: 1 + 1000 - 500 + 200 = 701
Test Case 8: Alternating Sign
Input: [2, -2, 2, -2]
Expected Output: [2, 0, 2, 0]
Explanation: Running sums are calculated as follows:

Sum of first element: 2
Sum of first two elements: 2 - 2 = 0
Sum of first three elements: 2 - 2 + 2 = 2
Sum of all elements: 2 - 2 + 2 - 2 = 0
Test Case 9: Increasing Sequence
Input: [1, 2, 3, 4, 5]
Expected Output: [1, 3, 6, 10, 15]
Explanation: Running sums are calculated as follows:

Sum of first element: 1
Sum of first two elements: 1 + 2 = 3
Sum of first three elements: 1 + 2 + 3 = 6
Sum of first four elements: 1 + 2 + 3 + 4 = 10
Sum of all elements: 1 + 2 + 3 + 4 + 5 = 15
Test Case 10: Decreasing Sequence
Input: [5, 4, 3, 2, 1]
Expected Output: [5, 9, 12, 14, 15]
Explanation: Running sums are calculated as follows:

Sum of first element: 5
Sum of first two elements: 5 + 4 = 9
Sum of first three elements: 5 + 4 + 3 = 12
Sum of first four elements: 5 + 4 + 3 + 2 = 14
Sum of all elements: 5 + 4 + 3 + 2 + 1 = 15


++++++++++++++++++++++

Can you explain what lifecycle hooks are in Angular and why they are important?
ngOnChanges
ngOnInit
ngDoCheck
ngAfterContentInit
ngAfterContentChecked
ngAfterViewInit
ngAfterViewChecked
ngOnDestroy

What is the difference between ngAfterContentInit and ngAfterViewInit?
Expected Answer: ngAfterContentInit is called after Angular has projected the content into the component’s view. ngAfterViewInit is called after the component's view and child views are fully initialized. Use ngAfterContentInit to work with content projected into the component, and ngAfterViewInit to work with the component’s own view and child views.

 how would you dynamically add and remove form controls in a reactive form? Can you explain the steps involved and provide a sample implementation?

Reactive Forms: Explain that Angular's reactive forms use FormGroup and FormControl classes to manage form controls and their states.
Dynamic Controls: Mention that dynamic controls involve programmatically adding or removing controls from a FormArray within a FormGroup.
Steps to Implement Dynamic Controls:

Create a Form Group and Form Array: Define the form structure using FormGroup and FormArray in the component's TypeScript file.
Add Controls Dynamically: Use methods like push to add new form controls to the FormArray.
Remove Controls Dynamically: Use methods like removeAt to remove specific controls from the FormArray.
Update the Template: Bind the form controls dynamically in the template using Angular’s form directives.
Sample Implementation:

Here’s a basic implementation example:

import { Component } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      dynamicControls: this.fb.array([])
    });
  }

  get dynamicControls(): FormArray {
    return this.form.get('dynamicControls') as FormArray;
  }

  addControl(): void {
    const control = this.fb.control('', Validators.required);
    this.dynamicControls.push(control);
  }

  removeControl(index: number): void {
    this.dynamicControls.removeAt(index);
  }
}


<form [formGroup]="form">
  <div formArrayName="dynamicControls">
    <div *ngFor="let control of dynamicControls.controls; let i = index">
      <input [formControlName]="i" placeholder="Enter value">
      <button type="button" (click)="removeControl(i)">Remove</button>
    </div>
  </div>
  <button type="button" (click)="addControl()">Add Control</button>
</form>


Optimizing Rendering with TrackBy
You have a large list of items rendered with ngFor, and each item has an "Edit" button that allows modifying its data. The problem is that when one item is edited, the entire list is re-rendered, leading to performance issues. Optimize the list rendering.

To optimize the rendering of a large list in Angular, especially when using *ngFor with frequent updates (e.g., when editing items), you can use the trackBy function. The trackBy function helps Angular identify which items have changed, thereby preventing the entire list from being re-rendered when only a single item is updated.

Problem
When using *ngFor without trackBy, Angular treats each update as a potential change in the entire list, and it may re-render every item. This leads to performance issues, especially when you have a large dataset.

Solution: Using trackBy
Implementing the trackBy function: The trackBy function allows Angular to track items based on a unique identifier (such as an id), ensuring that only the modified item is re-rendered when changes occur.

import { Component } from '@angular/core';

@Component({
  selector: 'app-item-list',
  templateUrl: './item-list.component.html',
})
export class ItemListComponent {
  items = [
    { id: 1, name: 'Item 1', description: 'Description 1' },
    { id: 2, name: 'Item 2', description: 'Description 2' },
    { id: 3, name: 'Item 3', description: 'Description 3' },
    // ... more items
  ];

  // Method to update the name of an item
  editItem(itemId: number) {
    const itemIndex = this.items.findIndex(item => item.id === itemId);
    if (itemIndex !== -1) {
      // Simulate item update
      this.items[itemIndex].name = `Updated Item ${itemId}`;
    }
  }

  // trackBy function to uniquely identify each item by its id
  trackById(index: number, item: any): number {
    return item.id;
  }
}


<ul>
  <li *ngFor="let item of items; trackBy: trackById">
    <span>{{ item.name }} - {{ item.description }}</span>
    <button (click)="editItem(item.id)">Edit</button>
  </li>
</ul>


Explain the difference between subscribe and toPromise methods in Observables. When would you use each?

How would you handle multiple asynchronous operations using Promises in Angular and ensure they execute in a specific order?

Question:
You are building a custom pipe in Angular that formats numbers based on user locale. The pipe must support reactive locale changes (i.e., if the locale changes dynamically, the pipe should update the formatted numbers accordingly). How would you implement this custom pipe to handle asynchronous locale changes without triggering full component re-renders every time the locale changes?

Hints:

Consider how you can use ChangeDetectorRef.
Think about how to leverage Angular's async pipe in this scenario.

Question:
Suppose you have a long list of items rendered using ngFor and a custom pipe that performs complex, expensive transformations on each item. How would you optimize this custom pipe to avoid recalculating transformations every time ngFor re-renders due to changes unrelated to the item data (e.g., a parent component updates)?

Hints:

Use pure pipes.
How does Angular's default change detection mechanism work with pure and impure pipes?

pure pipe and impure pipes
Pure Pipes
Definition:
A pure pipe is a type of Angular pipe that only executes when the input data to the pipe changes. It is the default behavior for pipes in Angular.

Characteristics:
Execution Trigger: A pure pipe runs only when the input data (i.e., the arguments passed to the pipe) changes. If Angular's change detection mechanism detects that the input value has not changed, the pipe does not re-run.
Performance: Pure pipes are more efficient because they avoid unnecessary recalculations, especially when used in ngFor or other repeaters.
Stateless: Pure pipes should be stateless. They should not depend on or alter external state.

Definition:
An impure pipe is a type of Angular pipe that executes on every change detection cycle, regardless of whether the input data has changed or not.

Characteristics:
Execution Trigger: An impure pipe runs on every change detection cycle, meaning it recalculates the output every time Angular performs change detection.
Performance: Impure pipes can be less efficient compared to pure pipes because they re-run more frequently, which can lead to performance issues with large datasets or complex calculations.
Stateful: Impure pipes can maintain internal state or rely on external state, and they often work with data that changes more frequently or requires periodic updates.


How would you handle user inputs for date and time in an international application where users might be in different time zones?
What are the best practices for capturing date and time in web forms for different locales?
