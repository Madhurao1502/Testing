Now You Can Use This Code Directly
csharp
using MigraDoc.DocumentObjectModel;
using MigraDoc.Rendering;
using System.IO;

public class PdfSharpGeneratorService : IPdfGeneratorService
{
    private readonly ILogger<PdfSharpGeneratorService> _logger;

    public PdfSharpGeneratorService(ILogger<PdfSharpGeneratorService> logger)
    {
        _logger = logger;
    }

    public async Task<byte[]> GenerateWorkOrderPdfAsync(WorkOrderRequest request)
    {
        return await Task.Run(() =>
        {
            try
            {
                // Create MigraDoc document
                Document doc = new Document();
                Section section = doc.AddSection();
                section.PageSetup.TopMargin = "2cm";
                section.PageSetup.BottomMargin = "2cm";

                // Add title
                Paragraph title = section.AddParagraph("WORK ORDER");
                title.Format.Font.Size = 24;
                title.Format.Font.Bold = true;
                title.Format.Alignment = ParagraphAlignment.Center;

                // Add FSR info
                Paragraph fsr = section.AddParagraph($"FSR: {request.FsrName}");
                fsr.Format.Font.Size = 12;

                Paragraph id = section.AddParagraph($"ID: {request.FsrId}");
                id.Format.Font.Size = 12;

                section.AddParagraph("");

                // Add table
                Table table = section.AddTable();
                table.AddColumn("1cm");
                table.AddColumn("3cm");
                table.AddColumn("4cm");

                Row row = table.AddRow();
                row.Cells[0].AddParagraph("No.");
                row.Cells[1].AddParagraph("Task");
                row.Cells[2].AddParagraph("Store");

                // Add task rows
                int num = 1;
                if (request.Tasks != null)
                {
                    foreach (var task in request.Tasks)
                    {
                        row = table.AddRow();
                        row.Cells[0].AddParagraph(num.ToString());
                        row.Cells[1].AddParagraph(task.TaskName);
                        row.Cells[2].AddParagraph($"{task.StoreNumber} - {task.StoreName}");
                        num++;
                    }
                }

                // Convert to PDF
                PdfDocumentRenderer renderer = new PdfDocumentRenderer();
                renderer.Document = doc;
                renderer.RenderDocument();

                using (var memoryStream = new MemoryStream())
                {
                    renderer.PdfDocument.Save(memoryStream, false);
                    byte[] pdfBytes = memoryStream.ToArray();
                    
                    _logger.LogInformation($"PDF generated: {pdfBytes.Length} bytes");
                    return pdfBytes;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating PDF");
                throw;
            }
        });
    }

    public async Task<byte[]> GenerateTaskAssignmentPdfAsync(TaskAssignmentRequest request)
    {
        return await Task.Run(() =>
        {
            try
            {
                Document doc = new Document();
                Section section = doc.AddSection();

                Paragraph title = section.AddParagraph("TASK ASSIGNMENT");
                title.Format.Font.Size = 20;
                title.Format.Font.Bold = true;

                Paragraph task = section.AddParagraph($"Task: {request.TaskName}");
                Paragraph store = section.AddParagraph($"Store: {request.StoreName}");
                Paragraph assigned = section.AddParagraph($"Assigned To: {request.AssignedTo}");

                PdfDocumentRenderer renderer = new PdfDocumentRenderer();
                renderer.Document = doc;
                renderer.RenderDocument();

                using (var memoryStream = new MemoryStream())
                {
                    renderer.PdfDocument.Save(memoryStream, false);
                    return memoryStream.ToArray();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating task assignment");
                throw;
            }
        });
    }

    public async Task<byte[]> GenerateMultiplePdfsAsZipAsync(List<WorkOrderRequest> requests)
    {
        return await Task.Run(async () =>
        {
            using (var memoryStream = new MemoryStream())
            {
                using (var archive = new System.IO.Compression.ZipArchive(memoryStream, System.IO.Compression.ZipArchiveMode.Create, true))
                {
                    int count = 1;
                    foreach (var request in requests)
                    {
                        var pdfBytes = await GenerateWorkOrderPdfAsync(request);
                        var entry = archive.CreateEntry($"WorkOrder_{request.FsrId}_{count}.pdf");
                        
                        using (var entryStream = entry.Open())
                        {
                            entryStream.Write(pdfBytes, 0, pdfBytes.Length);
                        }
                        count++;
                    }
                }
                return memoryStream.ToArray();
            }
        });
    }
}
âœ… Next Steps (Copy-Paste Ready)
1. Create Service Interface: Services/IPdfGeneratorService.cs
csharp
namespace YourNamespace.Services
{
    public interface IPdfGeneratorService
    {
        Task<byte[]> GenerateWorkOrderPdfAsync(WorkOrderRequest request);
        Task<byte[]> GenerateTaskAssignmentPdfAsync(TaskAssignmentRequest request);
        Task<byte[]> GenerateMultiplePdfsAsZipAsync(List<WorkOrderRequest> requests);
    }

    public class WorkOrderRequest
    {
        public string FsrName { get; set; }
        public string FsrId { get; set; }
        public string FsrEmail { get; set; }
        public string Territory { get; set; }
        public DateTime AssignedDate { get; set; }
        public List<TaskData> Tasks { get; set; } = new();
    }

    public class TaskData
    {
        public int TaskId { get; set; }
        public string TaskName { get; set; }
        public string TaskNumber { get; set; }
        public string StoreNumber { get; set; }
        public string StoreName { get; set; }
        public string Status { get; set; }
    }

    public class TaskAssignmentRequest
    {
        public int TaskId { get; set; }
        public string TaskName { get; set; }
        public string StoreNumber { get; set; }
        public string StoreName { get; set; }
        public string AssignedTo { get; set; }
        public DateTime AssignedDate { get; set; }
        public string Notes { get; set; }
    }
}
2. Create Service Implementation: Services/PdfSharpGeneratorService.cs
Copy the code above from "Now You Can Use This Code Directly"

3. Register in Program.cs
csharp
builder.Services.AddScoped<IPdfGeneratorService, PdfSharpGeneratorService>();
4. Create Controller: Controllers/PdfController.cs
csharp
using Microsoft.AspNetCore.Mvc;
using YourNamespace.Services;

namespace YourNamespace.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class PdfController : ControllerBase
    {
        private readonly IPdfGeneratorService _pdfService;
        private readonly ILogger<PdfController> _logger;

        public PdfController(IPdfGeneratorService pdfService, ILogger<PdfController> logger)
        {
            _pdfService = pdfService;
            _logger = logger;
        }

        [HttpPost("generate-workorder")]
        public async Task<IActionResult> GenerateWorkOrder([FromBody] WorkOrderRequest request)
        {
            try
            {
                var pdfBytes = await _pdfService.GenerateWorkOrderPdfAsync(request);
                return File(pdfBytes, "application/pdf", $"WorkOrder_{request.FsrId}_{DateTime.Now:yyyyMMddHHmmss}.pdf");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating PDF");
                return StatusCode(500, new { error = ex.Message });
            }
        }

        [HttpPost("generate-task-assignment")]
        public async Task<IActionResult> GenerateTaskAssignment([FromBody] TaskAssignmentRequest request)
        {
            try
            {
                var pdfBytes = await _pdfService.GenerateTaskAssignmentPdfAsync(request);
                return File(pdfBytes, "application/pdf", $"TaskAssignment_{request.TaskId}_{DateTime.Now:yyyyMMddHHmmss}.pdf");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating PDF");
                return StatusCode(500, new { error = ex.Message });
            }
        }

        [HttpPost("generate-workorders-zip")]
        public async Task<IActionResult> GenerateWorkOrdersZip([FromBody] List<WorkOrderRequest> requests)
        {
            try
            {
                var zipBytes = await _pdfService.GenerateMultiplePdfsAsZipAsync(requests);
                return File(zipBytes, "application/zip", $"WorkOrders_{DateTime.Now:yyyyMMddHHmmss}.zip");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating ZIP");
                return StatusCode(500, new { error = ex.Message });
            }
        }
    }
}
5. Build & Test
bash
dotnet clean
dotnet build
dotnet run
6. Test Endpoint
bash
curl -X POST http://localhost:5000/api/pdf/generate-workorder \
  -H "Content-Type: application/json" \
  -d '{
    "fsrName": "John Doe",
    "fsrId": "EMP001",
    "fsrEmail": "john@example.com",
    "territory": "North",
    "assignedDate": "2025-11-04",
    "tasks": [{
      "taskId": 1,
      "taskName": "Inventory Check",
      "taskNumber": "TASK001",
      "storeNumber": "12345",
      "storeName": "Main Store",
      "status": "Pending"
    }]
  }' > WorkOrder.pdf
