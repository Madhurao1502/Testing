Complete Column Hide/Show Implementation for 3 Table Types
Issue: Column visibility changes from filter component need to work with 3 different table types (current/future/previous weeks)
Solution: Enhanced communication between filter-sidebar and store-table components
1. UPDATED filter-sidebar.component.ts (Column Management Enhancement)
typescript
// ADD these properties to your existing FilterSidebarComponent:

export class FilterSidebarComponent implements OnInit, OnDestroy {
  // ... your existing properties ...

  // ENHANCED: Dynamic column definitions based on week type
  private allAvailableColumns = {
    base: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'zip', label: 'Zip', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    current: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    future: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'avg_cost', label: 'Avg Cost', required: false },
      { key: 'guaranteed_miles', label: 'Miles', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ],
    previous: [
      { key: 'store_number', label: 'Store Number', required: true },
      { key: 'store_name', label: 'Store Name', required: true },
      { key: 'addr_line1', label: 'Address', required: false },
      { key: 'city', label: 'City', required: false },
      { key: 'state', label: 'State', required: false },
      { key: 'assigned_to', label: 'Assigned To', required: true },
      { key: 'task_completed', label: 'Task Completed', required: false },
      { key: 'quality', label: 'Quality', required: false },
      { key: 'cost_over', label: 'Cost Over', required: false },
      { key: 'wk1_costs', label: 'WK1 Costs', required: false },
      { key: 'wk2_costs', label: 'WK2 Costs', required: false },
      { key: 'user_comment', label: 'Comments', required: true }
    ]
  };

  // Current week type tracking
  currentWeekType: 'current' | 'future' | 'previous' = 'current';

  // ADD these methods to your existing component:

  ngOnInit(): Promise<void> {
    // ... your existing ngOnInit code ...

    // ADDED: Subscribe to week type changes from CommonService
    this.commonService.weekType$
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe(weekType => {
        this.currentWeekType = weekType;
        this.updateAvailableColumns();
        this.resetSelectedColumnsForWeekType();
      });

    // ... rest of your existing ngOnInit code ...
  }

  // ADDED: Update available columns based on week type
  private updateAvailableColumns(): void {
    switch (this.currentWeekType) {
      case 'current':
        this.availableColumns = this.allAvailableColumns.current;
        break;
      case 'future':
        this.availableColumns = this.allAvailableColumns.future;
        break;
      case 'previous':
        this.availableColumns = this.allAvailableColumns.previous;
        break;
      default:
        this.availableColumns = this.allAvailableColumns.base;
    }
    
    console.log(`Available columns updated for ${this.currentWeekType} week:`, this.availableColumns);
  }

  // ADDED: Reset selected columns when week type changes
  private resetSelectedColumnsForWeekType(): void {
    // Reset to default columns for the new week type
    this.selectedColumns = this.availableColumns
      .filter(col => col.required || this.getDefaultVisibleColumns().includes(col.key))
      .map(col => col.key);
    
    // Emit the change
    this.columnsChanged.emit(this.selectedColumns);
    
    console.log(`Selected columns reset for ${this.currentWeekType} week:`, this.selectedColumns);
  }

  // ADDED: Get default visible columns based on week type
  private getDefaultVisibleColumns(): string[] {
    const common = ['addr_line1', 'city', 'state'];
    
    switch (this.currentWeekType) {
      case 'current':
        return [...common, 'task_completed', 'quality'];
      case 'future':
        return [...common, 'avg_cost'];
      case 'previous':
        return [...common, 'task_completed', 'wk1_costs'];
      default:
        return common;
    }
  }

  // ENHANCED: Column selection change with week type awareness
  onColumnSelectionChange(): void {
    // Ensure required columns are always selected
    const requiredColumns = this.availableColumns
      .filter(col => col.required)
      .map(col => col.key);
      
    this.selectedColumns = [...new Set([...this.selectedColumns, ...requiredColumns])];
    
    console.log(`Column selection changed for ${this.currentWeekType} week:`, this.selectedColumns);
    
    // Emit the change with week type context
    this.columnsChanged.emit(this.selectedColumns);
  }

  // ... rest of your existing methods ...
}
2. ENHANCED store-table.component.ts (Add Column Visibility Methods)
typescript
// ADD these methods to your existing StoreTableComponent:

export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  // ... your existing properties ...

  // ADDED: Column visibility management properties
  private visibleColumns: string[] = [];

  ngOnInit(): void {
    // ... your existing ngOnInit code ...

    // Keep your existing week type subscription but enhance it:
    this.commonService.weekType$
      .pipe(takeUntil(this.destroy$))
      .subscribe(weekType => {
        console.log('Week type changed to:', weekType);
        this.currentWeekType = weekType;
        this.updateDisplayedColumns(); // This will now consider visible columns too
        this.cdr.detectChanges();
      });

    // ... rest of your existing ngOnInit code ...
  }

  // ADDED: Method to receive column visibility changes from filter component
  updateVisibleColumns(selectedColumns: string[]): void {
    console.log('Store table received visible columns:', selectedColumns);
    this.visibleColumns = selectedColumns;
    this.updateDisplayedColumns();
    this.cdr.detectChanges();
  }

  // ENHANCED: Update displayed columns considering both week type and visibility
  private updateDisplayedColumns(): void {
    let availableColumns: string[] = [];
    
    // Get available columns based on week type
    switch (this.currentWeekType) {
      case 'current':
        availableColumns = this.currentWeekColumns;
        break;
      case 'future':
        availableColumns = this.futureWeekColumns;
        break;
      case 'previous':
        availableColumns = this.previousWeekColumns;
        break;
      default:
        availableColumns = this.baseColumns;
    }
    
    // Filter by visible columns if specified
    if (this.visibleColumns.length > 0) {
      this.displayedColumns = availableColumns.filter(col => 
        this.visibleColumns.includes(col)
      );
    } else {
      // Show all available columns if no specific selection
      this.displayedColumns = [...availableColumns];
    }
    
    console.log(`Final displayed columns for ${this.currentWeekType} week:`, this.displayedColumns);
  }

  // ENHANCED: Column visibility check
  isColumnVisible(columnName: string): boolean {
    const isVisible = this.displayedColumns.includes(columnName);
    console.log(`Column ${columnName} visible:`, isVisible);
    return isVisible;
  }

  // ... rest of your existing methods ...
}
3. UPDATE store-table.component.html (Add *ngIf to ALL columns)
xml
<!-- UPDATE all your ng-container column definitions to include *ngIf: -->

<!-- Store Number Column (Always visible as it's required) -->
<ng-container matColumnDef="store_number" *ngIf="isColumnVisible('store_number')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">
    <button mat-icon-button 
            [disabled]="isExpandingAll"
            (click)="expandAllRows()" 
            [title]="allExpanded ? 'Collapse All' : 'Expand All'"
            class="expand-all-btn">
      <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
    </button>
    Store #
  </mat-header-cell>
  <mat-cell *matCellDef="let element" class="store-number-cell">
    <span class="caret" [class.clicked]="isRowExpanded(element)">▼</span>
    <span class="store-number">{{element.StoreNumber}}</span>
  </mat-cell>
</ng-container>

<!-- Store Name Column -->
<ng-container matColumnDef="store_name" *ngIf="isColumnVisible('store_name')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Store Name</mat-header-cell>
  <mat-cell *matCellDef="let element" class="store-name-cell">
    <span class="store-name" (click)="openProximityDataDialog(element); $event.stopPropagation();">
      {{element.StoreName}}
    </span>
  </mat-cell>
</ng-container>

<!-- Address Column -->
<ng-container matColumnDef="addr_line1" *ngIf="isColumnVisible('addr_line1')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Address</mat-header-cell>
  <mat-cell *matCellDef="let element">{{element.AddrLine1}}</mat-cell>
</ng-container>

<!-- City Column -->
<ng-container matColumnDef="city" *ngIf="isColumnVisible('city')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">City</mat-header-cell>
  <mat-cell *matCellDef="let element">{{element.City}}</mat-cell>
</ng-container>

<!-- State Column -->
<ng-container matColumnDef="state" *ngIf="isColumnVisible('state')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">State</mat-header-cell>
  <mat-cell *matCellDef="let element">
    <span class="state-badge">{{element.State}}</span>
  </mat-cell>
</ng-container>

<!-- Zip Column -->
<ng-container matColumnDef="zip" *ngIf="isColumnVisible('zip')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Zip</mat-header-cell>
  <mat-cell *matCellDef="let element">{{element.Zip}}</mat-cell>
</ng-container>

<!-- Assigned To Column -->
<ng-container matColumnDef="assigned_to" *ngIf="isColumnVisible('assigned_to')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Assigned To</mat-header-cell>
  <mat-cell *matCellDef="let element" class="assigned-cell" 
            (click)="openAssignmentDialog(element, 'StoreLevel'); $event.stopPropagation()">
    <span class="assignment-badge" [ngClass]="getAssignmentClass(element.AssignedTo)">
      {{element.AssignedTo}}
    </span>
  </mat-cell>
</ng-container>

<!-- Task Completed Column (Current & Previous weeks only) -->
<ng-container matColumnDef="task_completed" *ngIf="isColumnVisible('task_completed')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Completed</mat-header-cell>
  <mat-cell *matCellDef="let element">
    <span class="status-badge" [ngClass]="getTaskCompletedClass(element.TaskCompleted)">
      {{formatTaskCompleted(element.TaskCompleted)}}
    </span>
  </mat-cell>
</ng-container>

<!-- Quality Column (Current & Previous weeks only) -->
<ng-container matColumnDef="quality" *ngIf="isColumnVisible('quality')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Quality</mat-header-cell>
  <mat-cell *matCellDef="let element">
    <span class="quality-badge" [ngClass]="getQualityClass(element.Quality)">
      {{formatQuality(element.Quality)}}
    </span>
  </mat-cell>
</ng-container>

<!-- Cost Over Column (Current & Previous weeks only) -->
<ng-container matColumnDef="cost_over" *ngIf="isColumnVisible('cost_over')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Over Cost</mat-header-cell>
  <mat-cell *matCellDef="let element">
    <span class="cost-badge" [ngClass]="getCostOverClass(element.CostOver)">
      {{formatCostOver(element.CostOver)}}
    </span>
  </mat-cell>
</ng-container>

<!-- Guaranteed Miles Column -->
<ng-container matColumnDef="guaranteed_miles" *ngIf="isColumnVisible('guaranteed_miles')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Miles</mat-header-cell>
  <mat-cell *matCellDef="let element">{{formatGuaranteedMiles(element.GuaranteedMiles)}}</mat-cell>
</ng-container>

<!-- Average Cost Column (Future week only) -->
<ng-container matColumnDef="avg_cost" *ngIf="isColumnVisible('avg_cost')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Avg Cost</mat-header-cell>
  <mat-cell *matCellDef="let element">{{formatAvgCost(element.AvgCost)}}</mat-cell>
</ng-container>

<!-- WK1 Costs Column (Previous week only) -->
<ng-container matColumnDef="wk1_costs" *ngIf="isColumnVisible('wk1_costs')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">WK1 Costs</mat-header-cell>
  <mat-cell *matCellDef="let element">{{formatWk1Costs(element)}}</mat-cell>
</ng-container>

<!-- WK2 Costs Column (Previous week only) -->
<ng-container matColumnDef="wk2_costs" *ngIf="isColumnVisible('wk2_costs')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">WK2 Costs</mat-header-cell>
  <mat-cell *matCellDef="let element">{{formatWk2Costs(element)}}</mat-cell>
</ng-container>

<!-- Comments Column -->
<ng-container matColumnDef="user_comment" *ngIf="isColumnVisible('user_comment')">
  <mat-header-cell *matHeaderCellDef class="mat-header-style">Comments</mat-header-cell>
  <mat-cell *matCellDef="let element" class="comment-cell">
    <!-- Your existing comment cell content -->
    <div *ngIf="!element.IsCommentEditing" class="comment-view">
      <span class="comment-text" 
            [title]="element.UserComment"
            (click)="canEditComments && startCommentEdit(element); $event.stopPropagation();"
            [style.cursor]="canEditComments ? 'pointer' : 'default'">
        {{element.UserComment || (canEditComments ? 'Add comment...' : 'No comment')}}
      </span>
      
      <button *ngIf="canEditComments" 
              mat-icon-button 
              (click)="startCommentEdit(element); $event.stopPropagation();"
              class="comment-edit-btn">
        <mat-icon>edit</mat-icon>
      </button>
      
      <button *ngIf="canDeleteComments && element.UserComment" 
              mat-icon-button 
              (click)="deleteComment(element); $event.stopPropagation();"
              class="comment-delete-btn">
        <mat-icon>delete</mat-icon>
      </button>
    </div>
    
    <div *ngIf="element.IsCommentEditing && canEditComments" class="comment-edit">
      <mat-form-field appearance="standard" class="comment-field">
        <textarea matInput
                  [value]="element.UserComment"
                  placeholder="Enter comment..."
                  (keydown)="onCommentKeydown($event, element)"
                  #commentInput
                  rows="2"
                  maxlength="500">
        </textarea>
      </mat-form-field>
      <div class="comment-actions">
        <button mat-icon-button 
                color="primary"
                (click)="saveComment(element, commentInput.value); $event.stopPropagation();">
          <mat-icon>check</mat-icon>
        </button>
        <button mat-icon-button 
                (click)="cancelCommentEdit(element); $event.stopPropagation();">
          <mat-icon>close</mat-icon>
        </button>
      </div>
    </div>
  </mat-cell>
</ng-container>
4. UPDATE dashboard-layout.component.ts
typescript
// ADD this method to handle column changes:

export class DashboardLayoutComponent implements OnInit, OnDestroy {
  // ... your existing properties and methods ...

  // Handle column visibility changes from filter sidebar
  onColumnsChanged(selectedColumns: string[]): void {
    console.log('Dashboard received column changes:', selectedColumns);
    
    // Pass to store table component
    if (this.storeTableComponent) {
      this.storeTableComponent.updateVisibleColumns(selectedColumns);
    }
  }

  // ... rest of your existing methods ...
}
5. UPDATE dashboard-layout.component.html
xml
<!-- Update your filter sidebar to emit column changes -->
<app-filter-sidebar 
  (filtersChanged)="onFiltersChanged($event)"
  (columnsChanged)="onColumnsChanged($event)">
</app-filter-sidebar>

<!-- Make sure you have reference to store table -->
<app-store-table #storeTableComponent></app-store-table>
How It Works:
1. Week Type Detection:
CommonService determines current/future/previous week based on IRI week comparison

Filter sidebar subscribes to weekType$ changes

2. Dynamic Column Options:
Filter sidebar updates available columns based on week type

Different column options for current (Task Completed, Quality) vs future (Avg Cost) vs previous (WK1/WK2 Costs)

3. Column Selection Flow:
text
User Changes Week → CommonService.weekType$ → Filter Sidebar updates availableColumns 
↓
User Selects Columns → onColumnSelectionChange() → Emit columnsChanged
↓
Dashboard receives → onColumnsChanged() → Store Table.updateVisibleColumns()
↓
Store Table updates displayedColumns → Template *ngIf shows/hides columns
4. Template Rendering:
Each ng-container has *ngIf="isColumnVisible(columnName)"

isColumnVisible() checks if column is in current displayedColumns array

Columns automatically show/hide based on both week type AND user selection

This solution provides:

✅ Dynamic column options based on week type

✅ Real-time show/hide functionality

✅ Required columns protection (can't hide Store #, Name, Assigned To, Comments)

✅ Week-appropriate defaults (different default visible columns per week type)

✅ Seamless integration with your existing 3-table system
