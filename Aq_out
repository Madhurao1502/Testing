.mat-dialog-title {
  margin: 0px;
  margin-bottom: 10px;
  font-size: medium;
  background-color: lightgray;
  padding-left: 1em;
  padding-right: 1em;
  cursor: grab;
}

.close-btn{
  float:right; 
  color: #4e6a87; 
  margin-top: 4px;
}

.close-btn-icon{
  color: rgb(87 135 187);
}

.close-btn-icon:hover{
  color: black;
}

.close-btn:hover{ 
  color: rgb(87 135 187);
  background: #ccd6df;
  height: 20px;
}

 .assignment-dialog-content {
      max-height: 60vh;
      overflow-y: auto;
      width: 100%;
    }

    .filter-section {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #f5f5f5;
      border-radius: 4px;
    }

    .filter-row {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 16px;
    }

    .filter-row mat-form-field {
      flex: 1;
    }

    .loading-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 40px;
    }

    .table-container {
      max-height: 250px;
      min-height: 200px;
      overflow-y: auto;
    }

    .fsr-table {
      width: 100%;
    }

    .no-data {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .assignment-dialog-content {
      max-height: 60vh;
      overflow-y: auto;
      width: 100%;
    }

    .filter-section {
      margin-bottom: 20px;
      padding: 16px;
      background-color: #f5f5f5;
      border-radius: 4px;
    }

    .filter-row {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 16px;
    }

    .filter-row mat-form-field {
      flex: 1;
    }

    .loading-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 40px;
    }

    .table-container {
      max-height: 250px;
      overflow-y: auto;
    }

    .fsr-table {
      width: 100%;
    }

    .no-data {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    /* Autocomplete styling */
    .mat-autocomplete-panel {
      max-height: 200px !important;
    }

    .mat-option {
      padding: 12px 16px;
      line-height: 1.2;
    }


 <h2 mat-dialog-title class="title-style" cdkDrag cdkDragRootElement=".cdk-overlay-pane" cdkDragHandle>
   {{getDialogTitle()}}
    <span class="close-btn" title="Close" [mat-dialog-close]="true"><mat-icon class="close-btn-icon">
            cancel_presentation</mat-icon></span> </h2>
    
    <mat-dialog-content class="assignment-dialog-content">
      <!-- Filter Section -->
      <div class="filter-section" [formGroup]="filterForm">
        <div class="filter-row">
          <mat-form-field appearance="outline">
            <mat-label>IRI Week</mat-label>
            <input matInput [value]="data.iriWeek" readonly>
          </mat-form-field>
          
          <mat-form-field appearance="outline">
            <mat-label>Territory</mat-label>
            <mat-select formControlName="territory">
              <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
                {{territory.territory_name}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>
        
     <div class="filter-row">
          <!-- First Name Autocomplete -->
          <mat-form-field appearance="outline">
            <mat-label>First Name</mat-label>
            <input matInput 
                   formControlName="firstName" 
                   placeholder="Search by first name..."
                   [matAutocomplete]="firstNameAuto">
            <mat-autocomplete #firstNameAuto="matAutocomplete"
                              (optionSelected)="onFirstNameSelected($event)"
                              [displayWith]="displayFn">
              <mat-option *ngFor="let option of filteredFirstNames | async" [value]="option">
                {{option.FirstName}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          
          <!-- Last Name Autocomplete -->
          <mat-form-field appearance="outline">
            <mat-label>Last Name</mat-label>
            <input matInput 
                   formControlName="lastName" 
                   placeholder="Search by last name..."
                   [matAutocomplete]="lastNameAuto">
            <mat-autocomplete #lastNameAuto="matAutocomplete"
                              (optionSelected)="onLastNameSelected($event)"
                              [displayWith]="displayFn">
              <mat-option *ngFor="let option of filteredLastNames | async" [value]="option">
                {{option.FirstName}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          
          <button mat-raised-button color="primary" (click)="searchFsrs()" [disabled]="isLoading">
            <mat-icon>search</mat-icon>
            Search
          </button>
        </div>
      </div>
    

      <!-- Loading Indicator -->
      <div *ngIf="isLoading" class="loading-container">
        <mat-spinner diameter="30"></mat-spinner>
        <span>Loading FSRs...</span>
      </div>

      <!-- FSR Table -->
      <div class="table-container" *ngIf="!isLoading">
        <mat-table [dataSource]="fsrDataSource" class="fsr-table">
          
          <!-- Action Columns (conditional based on mode) -->
          <ng-container matColumnDef="assign_all" *ngIf="showColumn('assign_all')">
            <mat-header-cell *matHeaderCellDef>Assign All</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="primary" (click)="assignTask(fsr, 2)">
                Assign All
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="unassign_all" *ngIf="showColumn('unassign_all')">
            <mat-header-cell *matHeaderCellDef>Unassign All</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="warn" (click)="assignTask(fsr, 4)">
                Unassign All
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="assign" *ngIf="showColumn('assign')">
            <mat-header-cell *matHeaderCellDef>Assign</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="primary" (click)="assignTask(fsr, 1)">
                Assign
              </button>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="unassign" *ngIf="showColumn('unassign')">
            <mat-header-cell *matHeaderCellDef>Unassign</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <button mat-stroked-button color="warn" (click)="assignTask(fsr, 3)">
                Unassign
              </button>
            </mat-cell>
          </ng-container>

          <!-- FSR Information Columns -->
          <ng-container matColumnDef="name">
            <mat-header-cell *matHeaderCellDef>Name</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.LastName}}, {{fsr.FirstName}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="address">
            <mat-header-cell *matHeaderCellDef>Address</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.AddrLine1}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="assigned_hrs">
            <mat-header-cell *matHeaderCellDef>Assigned Hrs</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.AssignedHrs}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="max_hrs">
            <mat-header-cell *matHeaderCellDef>Max Hours</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.MaxHrs}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="cluster">
            <mat-header-cell *matHeaderCellDef>Cluster</mat-header-cell>
            <mat-cell *matCellDef="let fsr">{{fsr.PositionName}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="contact">
            <mat-header-cell *matHeaderCellDef>Contact</mat-header-cell>
            <mat-cell *matCellDef="let fsr">
              <div>{{fsr.phone}}</div>
              <div><a href="mailto:{{fsr.Email}}">{{fsr.Email}}</a></div>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="getDisplayedColumns()"></mat-header-row>
          <mat-row *matRowDef="let row; columns: getDisplayedColumns()"></mat-row>
        </mat-table>

        <div *ngIf="fsrDataSource.data.length === 0 && !isLoading" class="no-data">
          No FSRs found. Please adjust your search criteria.
        </div>
      </div>
    </mat-dialog-content>

  
    
    <mat-dialog-actions align="end">
      <button mat-button (click)="onClose()">Close</button>
    </mat-dialog-actions>

    <footer>
      <div class="mat-spinner-container">
          <mat-spinner mode="indeterminate" *ngIf="showSpinner"></mat-spinner>
          <div *ngIf="showSpinner" style="position:relative;left: 10px">Loading...</div>
      </div>
    </footer>

import { CommonService } from './../../shared/common.service';
import { Component, Inject, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';
import { HttpClient } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { catchError, debounceTime, distinctUntilChanged, firstValueFrom, map, Observable, of, switchMap } from 'rxjs';
export interface AssignmentDialogData {
  storeNumber: string;
  storeName: string;
  taskNumber?: string;
  taskName?: string;
  iriWeek: string;
  territoryId: string;
  positionNumber?: string;
  mode: 'StoreLevel' | 'TaskLevel' | 'ClusterLevel';
}

interface NameOption {
  emp_name: string;
  emp_id: string;
  FirstName: string;
  LastName: string;
  value: string;
  id: string;
}
@Component({
  selector: 'app-assignment-dialog',
  templateUrl: './assignment-dialog.component.html',
  styleUrls: ['./assignment-dialog.component.css']
})
export class AssignmentDialogComponent implements OnInit {
filterForm: FormGroup;
territories: any[] = [];
fsrDataSource = new MatTableDataSource<any>([]);
isLoading = false;
filteredFirstNames: Observable<NameOption[]>;
filteredLastNames: Observable<NameOption[]>;
showSpinner:boolean=false;
  // Store selected values
  selectedFirstNameId: string = '';
  selectedLastNameId: string = '';
   constructor(
    private dialogRef: MatDialogRef<AssignmentDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: AssignmentDialogData,
    private fb: FormBuilder,
    private http: HttpClient,
    private commonService: CommonService,
    @Inject('BASE_URL') private baseUrl: string
  ) {
    this.filterForm = this.fb.group({
      territory: [data.territoryId],
      firstName: [''],
      lastName: ['']
    });
  }

   async ngOnInit(): Promise<void> {
    await this.loadTerritories();
    this.setupAutocomplete()
    await this.loadCurrentAssignment();
  }

  getDialogTitle(): string {
    const location = this.data.mode === 'ClusterLevel' 
      ? `Cluster: ${this.data.positionNumber} | Store: ALL`
      : `Store: ${this.data.storeName} (${this.data.storeNumber})`;
    
    const task = this.data.taskName 
      ? ` | Task: ${this.data.taskName}`
      : ' | Task: ALL';
    
    return `Assignment for ${location}${task}`;
  }

  getDisplayedColumns(): string[] {
    const columns = [];
    
    // Add action columns based on mode
    if (this.data.mode === 'StoreLevel') {
      columns.push('assign_all', 'unassign_all');
    } else if (this.data.mode === 'TaskLevel') {
      columns.push('assign', 'unassign');
    } else if (this.data.mode === 'ClusterLevel') {
      columns.push('assign_to_cluster', 'unassign_from_cluster');
    }
    
    // Add info columns
    columns.push('name', 'address', 'assigned_hrs', 'max_hrs', 'cluster', 'contact');
    
    return columns;
  }

  showColumn(columnName: string): boolean {
    return this.getDisplayedColumns().includes(columnName);
  }

  private async loadTerritories(): Promise<void> {
    try {
      this.territories = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      );
    } catch (error) {
      console.error('Error loading territories:', error);
    }
  }

  private async loadCurrentAssignment(): Promise<void> {
    this.isLoading = true;
    try {
      const params = {
        IriWeek: this.data.iriWeek,
        StoreNumber: this.data.storeNumber,
        TaskNumber: this.data.taskNumber || '',
        AssignmentMode: this.data.mode,
        PositionNumber: this.data.positionNumber || '',
        CountryId: this.commonService.getCurrentCountry()
      };
      const response = await firstValueFrom(
        this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCurrentAssignment', params)
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error loading current assignment:', error);
    } finally {
      this.isLoading = false;
    }
  }

  async searchFsrs(): Promise<void> {
    this.isLoading = true;
    try {
      const formValue = this.filterForm.value;
     
      const params = {
        IriWeek: this.data.iriWeek,
        TerritoryId: formValue.territory,
        FirstName: formValue.firstName.FirstName,
        LastName: formValue.lastName.FirstName,
        PositionNumber: this.data.positionNumber || '',
        countryId: this.commonService.getCurrentCountry(),
        Area: '23'
      };
      const response = await firstValueFrom(
        this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsrForAssignment', params)
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error searching FSRs:', error);
    } finally {
      this.isLoading = false;
    }
  }

  async assignTask(fsr: any, action: number): Promise<void> {
    const actionNames = {
      1: 'assign current task to',
      2: 'assign all tasks to',
      3: 'unassign current task from',
      4: 'unassign all tasks from',
      5: 'assign to cluster',
      6: 'unassign from cluster'
    };

    const message = `Are you sure you want to ${actionNames[action]} ${fsr.FirstName} ${fsr.LastName}?`;
    
    if (!confirm(message)) return;

    try {
      const params = {
        iri_week: this.data.iriWeek,
        territory_id: this.filterForm.get('territory')?.value,
        store_number: this.data.storeNumber,
        emp_id: fsr.emp_id,
        task_number: this.data.taskNumber || '',
        position_number: this.data.positionNumber || '',
        action: action,
        assignment_mode: this.data.mode,
        countryId: this.commonService.getCurrentCountry()
      };

      await firstValueFrom(
        this.http.post(this.baseUrl + 'api/TaskAssinment/SaveAssignment', params)
      );

      // Refresh the assignment list
      await this.loadCurrentAssignment();
      
      // Clear search fields
      this.filterForm.patchValue({ firstName: '', lastName: '' });
      
      alert('New Assignment saved successfully.');
      
    } catch (error) {
      console.error('Error saving assignment:', error);
      alert('Error while saving assignments.');
    }
  }

    private setupAutocomplete(): void {
    // Setup First Name Autocomplete
    this.filteredFirstNames = this.filterForm.get('firstName')!.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => {
        if (typeof value === 'string' && value.length >= 2) {
          return this.searchFirstNames(value);
        } else {
          return of([]);
        }
      })
    );

    // Setup Last Name Autocomplete
    this.filteredLastNames = this.filterForm.get('lastName')!.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(value => {
        if (typeof value === 'string' && value.length >= 2) {
          return this.searchLastNames(value);
        } else {
          return of([]);
        }
      })
    );
  }

  // Search First Names via API
  private searchFirstNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'first_name'
    };

    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map(response => response.map(item => ({
          emp_name: item.emp_name,
          emp_id: item.emp_id,
          FirstName:item.FirstName,
          LastName: item.LastName,
          value: item.emp_name,
          id: item.emp_id
        }))),
        catchError(error => {
          console.error('Error fetching first names:', error);
          return of([]);
        })
      );
  }

  // Search Last Names via API
  private searchLastNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'last_name'
    };

    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map(response => response.map(item => ({
          emp_name: item.emp_name,
          emp_id: item.emp_id,
          FirstName:item.FirstName,
          LastName: item.LastName,
          value: item.emp_name,
          id: item.emp_id
        }))),
        catchError(error => {
          console.error('Error fetching last names:', error);
          return of([]);
        })
      );
  }

  // Handle First Name Selection
  onFirstNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedFirstNameId = selectedOption.id;    
    // Auto-search when name is selected
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  // Handle Last Name Selection
  onLastNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedLastNameId = selectedOption.id;    
    // Auto-search when name is selected
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  // Display function for autocomplete
  displayFn(option: NameOption): string {
    return option ? option.FirstName : '';
  }



  // Handle territory change - clear name fields
  onTerritoryChange(): void {
    this.filterForm.patchValue({
      firstName: '',
      lastName: ''
    });
    this.selectedFirstNameId = '';
    this.selectedLastNameId = '';
    this.fsrDataSource.data = [];
  }


  onClose(): void {
    this.dialogRef.close(true); 
  }
}
