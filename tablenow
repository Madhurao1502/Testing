<!-- Loading indicator -->
<div *ngIf="isLoading" class="row-loading" [attr.colspan]="displayedColumns.length">
  <mat-spinner diameter="20"></mat-spinner>
  <span>Loading data for {{element.StoreName}}...</span>
</div>

<!-- Expanded rows using same column structure as parent -->
<ng-container *ngIf="!isLoading">
  <div class="expanded-row-container">
    
    <!-- Loop through sub-grid data -->
    <div class="expanded-data-row" *ngFor="let item of subgridData">
      
      <!-- Match parent table columns exactly -->
      
      <!-- Store Number Column (left aligned with caret space) -->
      <div class="expanded-cell mat-column-store_number" *ngIf="isColumnVisible('store_number')">
        <span class="expanded-indent">└─</span>
      </div>

      <!-- Territory -->
      <div class="expanded-cell mat-column-territory" *ngIf="isColumnVisible('territory')">
        {{item.bfd || '-'}}
      </div>

      <!-- Position Number -->
      <div class="expanded-cell mat-column-position_number" *ngIf="isColumnVisible('position_number')">
        {{item.taskName}}
      </div>

      <!-- BFD -->
      <div class="expanded-cell mat-column-bdf" *ngIf="isColumnVisible('bdf')">
        {{item.bfd || '-'}}
      </div>

      <!-- Outlet -->
      <div class="expanded-cell mat-column-outlet" *ngIf="isColumnVisible('outlet')">
        -
      </div>

      <!-- Store Name -->
      <div class="expanded-cell mat-column-store_name" *ngIf="isColumnVisible('store_name')">
        <!-- Empty for sub-rows or show task details -->
      </div>

      <!-- Address -->
      <div class="expanded-cell mat-column-addr_line1" *ngIf="isColumnVisible('addr_line1')">
        -
      </div>

      <!-- City -->
      <div class="expanded-cell mat-column-city" *ngIf="isColumnVisible('city')">
        -
      </div>

      <!-- State -->
      <div class="expanded-cell mat-column-state" *ngIf="isColumnVisible('state')">
        -
      </div>

      <!-- Zip (if visible) -->
      <div class="expanded-cell mat-column-zip" *ngIf="isColumnVisible('zip')">
        -
      </div>

      <!-- Assigned To -->
      <div class="expanded-cell mat-column-assigned_to" *ngIf="isColumnVisible('assigned_to')">
        <span class="clickable-link" (click)="openTaskAssignmentDialog2(item); $event.stopPropagation()">
          {{item.assignedTo}}
        </span>
      </div>

      <!-- Task Completed (for current/previous weeks) -->
      <div class="expanded-cell mat-column-task_completed" *ngIf="isColumnVisible('task_completed')">
        <ng-container *ngIf="weekType === 'current' || weekType === 'previous'">
          {{item.taskCompleted}}
        </ng-container>
        <ng-container *ngIf="weekType === 'future'">
          {{item.expectedCollectionTime}}
        </ng-container>
      </div>

      <!-- Guaranteed Miles -->
      <div class="expanded-cell mat-column-guaranteed_miles" *ngIf="isColumnVisible('guaranteed_miles')">
        {{formatGuaranteedMiles(item.guaranteedMiles)}}
      </div>

      <!-- Average Cost -->
      <div class="expanded-cell mat-column-avg_cost" *ngIf="isColumnVisible('avg_cost')">
        <ng-container *ngIf="weekType === 'future'">
          {{formatAvgCost(item.avgCost)}}
        </ng-container>
      </div>

      <!-- Cost Over -->
      <div class="expanded-cell mat-column-cost_over" *ngIf="isColumnVisible('cost_over')">
        <ng-container *ngIf="weekType === 'current' || weekType === 'previous'">
          {{formatCostOver(item.costOver)}}
        </ng-container>
      </div>

      <!-- WK1 Costs -->
      <div class="expanded-cell mat-column-wk1_costs" *ngIf="isColumnVisible('wk1_costs')">
        <span [ngClass]="{'negative': item.wK1FSRProdCost > 0, 'positive': item.wK1FSRProdCost <= 0}">
          {{item.wK1FSRProdCost | currencyFormat}}
        </span>
      </div>

      <!-- WK1 Travel -->
      <div class="expanded-cell mat-column-wk1_travel" *ngIf="isColumnVisible('wk1_travel')">
        <span class="travel-column">{{item.wK1StoreTravelCost | currencyFormat}}</span>
      </div>

      <!-- WK1 Ovg Travel -->
      <div class="expanded-cell mat-column-wk1_ovg_travel" *ngIf="isColumnVisible('wk1_ovg_travel')">
        <span [ngClass]="{'negative': item.wK1StoreTravelOvgCost > 0, 'positive': item.wK1StoreTravelOvgCost <= 0}">
          {{item.wK1StoreTravelOvgCost | currencyFormat}}
        </span>
      </div>

      <!-- WK2 Costs -->
      <div class="expanded-cell mat-column-wk2_costs" *ngIf="isColumnVisible('wk2_costs')">
        <span [ngClass]="{'negative': item.wK2FSRProdCost > 0, 'positive': item.wK2FSRProdCost <= 0}">
          {{item.wK2FSRProdCost | currencyFormat}}
        </span>
      </div>

      <!-- WK2 Travel -->
      <div class="expanded-cell mat-column-wk2_travel" *ngIf="isColumnVisible('wk2_travel')">
        <span class="travel-column">{{item.wK2StoreTravelCost | currencyFormat}}</span>
      </div>

      <!-- WK2 Ovg Travel -->
      <div class="expanded-cell mat-column-wk2_ovg_travel" *ngIf="isColumnVisible('wk2_ovg_travel')">
        <span [ngClass]="{'negative': item.wK2StoreTravelOvgCost > 0, 'positive': item.wK2StoreTravelOvgCost <= 0}">
          {{item.wK2StoreTravelOvgCost | currencyFormat}}
        </span>
      </div>

      <!-- Comments -->
      <div class="expanded-cell mat-column-user_comment" *ngIf="isColumnVisible('user_comment')">
        -
      </div>

    </div>
  </div>
</ng-container>



/* Remove old expanded-table styles and add these */

/* Detail row styling - seamless continuation */
.detail-row {
  background: #fafafa;
  overflow: hidden;
  display: block;
  width: 100%;
}

/* Container for expanded rows */
.expanded-row-container {
  width: 100%;
  display: block;
  border-left: 3px solid #2196f3;
  background: #f8f9fa;
}

/* Individual expanded data row */
.expanded-data-row {
  display: flex;
  width: 100%;
  min-height: 40px;
  border-bottom: 1px solid #e0e0e0;
  align-items: center;
  transition: background-color 0.2s;
}

.expanded-data-row:hover {
  background-color: #e3f2fd;
}

.expanded-data-row:last-child {
  border-bottom: 2px solid #2196f3;
  margin-bottom: 5px;
}

/* Expanded cells - must match parent column widths exactly */
.expanded-cell {
  padding: 8px 5px;
  font-size: 13px;
  color: #555;
  display: flex;
  align-items: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  box-sizing: border-box;
}

/* Indent indicator for expanded rows */
.expanded-indent {
  color: #999;
  font-size: 14px;
  margin-right: 5px;
  font-weight: 300;
}

/* Match exact column widths from parent table */
.expanded-cell.mat-column-store_number {
  width: 110px;
  min-width: 110px;
  max-width: 130px;
}

.expanded-cell.mat-column-territory {
  width: 70px;
  min-width: 70px;
  max-width: 80px;
}

.expanded-cell.mat-column-position_number {
  width: 100px;
  min-width: 100px;
  max-width: 140px;
}

.expanded-cell.mat-column-bdf {
  width: 80px;
  min-width: 80px;
  max-width: 90px;
}

.expanded-cell.mat-column-outlet {
  width: 80px;
  min-width: 80px;
  max-width: 90px;
}

.expanded-cell.mat-column-store_name {
  width: 200px;
  min-width: 180px;
  max-width: 250px;
}

.expanded-cell.mat-column-addr_line1 {
  width: 200px;
  min-width: 180px;
  max-width: 250px;
}

.expanded-cell.mat-column-city {
  width: 140px;
  min-width: 120px;
  max-width: 180px;
}

.expanded-cell.mat-column-state {
  width: 80px;
  min-width: 80px;
  max-width: 90px;
}

.expanded-cell.mat-column-zip {
  width: 80px;
  min-width: 80px;
  max-width: 90px;
}

.expanded-cell.mat-column-assigned_to {
  width: 180px;
  min-width: 160px;
  max-width: 220px;
}

.expanded-cell.mat-column-task_completed {
  width: 80px;
  min-width: 80px;
  max-width: 95px;
}

.expanded-cell.mat-column-guaranteed_miles {
  width: 100px;
  min-width: 90px;
  max-width: 120px;
}

.expanded-cell.mat-column-avg_cost {
  width: 110px;
  min-width: 100px;
  max-width: 130px;
  text-align: right;
}

.expanded-cell.mat-column-cost_over,
.expanded-cell.mat-column-wk1_costs,
.expanded-cell.mat-column-wk1_travel,
.expanded-cell.mat-column-wk1_ovg_travel,
.expanded-cell.mat-column-wk2_costs,
.expanded-cell.mat-column-wk2_travel,
.expanded-cell.mat-column-wk2_ovg_travel {
  width: 120px;
  min-width: 110px;
  max-width: 140px;
  text-align: right;
  justify-content: flex-end;
}

.expanded-cell.mat-column-user_comment {
  width: 150px;
  min-width: 150px;
}

/* Week-specific widths for expanded rows */
.store-table.week-current ~ .detail-row .expanded-row-container,
.store-table.week-current .detail-row .expanded-row-container {
  min-width: 1520px;
}

.store-table.week-future ~ .detail-row .expanded-row-container,
.store-table.week-future .detail-row .expanded-row-container {
  min-width: 1320px;
}

.store-table.week-previous ~ .detail-row .expanded-row-container,
.store-table.week-previous .detail-row .expanded-row-container {
  min-width: 2100px;
}

/* Loading indicator for expanded rows */
.row-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 20px;
  background: #f8f9fa;
  border: 1px dashed #dee2e6;
  margin: 5px 10px;
  border-radius: 4px;
  font-size: 14px;
  color: #666;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .expanded-row-container {
    margin-left: 10px;
    font-size: 12px;
  }
  
  .expanded-cell {
    padding: 6px 4px;
  }
}

********************************************8
import { Component, OnInit, OnDestroy, AfterViewInit, ViewChild, ViewChildren, QueryList, ChangeDetectorRef } from '@angular/core';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { Subject, takeUntil, firstValueFrom } from 'rxjs';
import { CommonService } from '../shared/common.service';

@Component({
  selector: 'app-store-table',
  templateUrl: './store-table.component.html',
  styleUrls: ['./store-table.component.css'],
  animations: [
    // Your existing animations
  ]
})
export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  
  @ViewChild(MatTable, { static: false }) table: MatTable<any>;
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;
  @ViewChildren(CdkDetailRowDirective) detailRows!: QueryList<CdkDetailRowDirective>;

  // Week type tracking
  currentWeekType: 'current' | 'future' | 'previous' = 'current';

  // Dynamic column configuration based on week type
  baseColumns = ['store_number', 'store_name', 'addr_line1', 'city', 'state', 'zip', 'assigned_to', 'user_comment'];
  
  currentWeekColumns = [
    'store_number', 'store_name', 'addr_line1', 'city', 'state', 'assigned_to', 
    'task_completed', 'quality', 'cost_over', 'guaranteed_miles', 'user_comment'
  ];
  
  futureWeekColumns = [
    'store_number', 'store_name', 'addr_line1', 'city', 'state', 'assigned_to',
    'avg_cost', 'guaranteed_miles', 'user_comment'
  ];
  
  previousWeekColumns = [
    'store_number', 'store_name', 'addr_line1', 'city', 'state', 'assigned_to',
    'task_completed', 'quality', 'cost_over', 'wk1_costs', 'wk2_costs', 'user_comment'
  ];

  // Current displayed columns
  displayedColumns: string[] = this.baseColumns;
  
  // Data source and expansion state
  dataSource = new MatTableDataSource<any>([]);
  isExpandingAll = false;
  allExpanded = false;
  expandedRowsData = new Map<string, any[]>();
  expandedRows = new Set<CdkDetailRowDirective>();
  selectedRows = new Set<any>();
  
  private destroy$ = new Subject<void>();
  private loggeduser: string;

  constructor(
    private commonService: CommonService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
    private dialog: MatDialog,
    private cdr: ChangeDetectorRef
  ) {
    this.loggeduser = localStorage.getItem("loggedUserId");
  }

  ngOnInit(): void {
    // Subscribe to week type changes
    this.commonService.weekType$
      .pipe(takeUntil(this.destroy$))
      .subscribe(weekType => {
        this.currentWeekType = weekType;
        this.updateDisplayedColumns();
        this.cdr.detectChanges();
      });

    // Subscribe to current week data
    this.commonService.currentWeekData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        if (this.currentWeekType === 'current') {
          this.updateDataSource(data);
        }
      });

    // Subscribe to future week data
    this.commonService.futureWeekData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        if (this.currentWeekType === 'future') {
          this.updateDataSource(data);
        }
      });

    // Subscribe to previous week data
    this.commonService.previousWeekData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        if (this.currentWeekType === 'previous') {
          this.updateDataSource(data);
        }
      });
  }

  private updateDataSource(data: any[]): void {
    this.dataSource = new MatTableDataSource<any>(data);
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    this.resetExpansionState();
  }

  private updateDisplayedColumns(): void {
    switch (this.currentWeekType) {
      case 'current':
        this.displayedColumns = this.currentWeekColumns;
        break;
      case 'future':
        this.displayedColumns = this.futureWeekColumns;
        break;
      case 'previous':
        this.displayedColumns = this.previousWeekColumns;
        break;
      default:
        this.displayedColumns = this.baseColumns;
    }
    console.log(`Updated columns for ${this.currentWeekType} week:`, this.displayedColumns);
  }

  // Week type specific display methods
  getWeekTypeDisplayName(): string {
    switch (this.currentWeekType) {
      case 'current': return 'Current Week Tasks';
      case 'future': return 'Future Week Planning';
      case 'previous': return 'Previous Week History';
      default: return 'Store Assignment Data';
    }
  }

  getWeekTypeClass(): string {
    return `week-${this.currentWeekType}`;
  }

  // Column visibility checks
  isColumnVisible(columnName: string): boolean {
    return this.displayedColumns.includes(columnName);
  }

  // Data formatting methods for different week types
  formatTaskCompleted(value: any): string {
    return value?.toLowerCase() === 'yes' ? 'Yes' : 'No';
  }

  formatQuality(value: any): string {
    return value || 'N/A';
  }

  formatCostOver(value: any): string {
    return value?.toLowerCase() === 'yes' ? 'Yes' : 'No';
  }

  formatGuaranteedMiles(value: any): string {
    return value ? `${value} miles` : 'N/A';
  }

  formatAvgCost(value: any): string {
    return value ? `$${parseFloat(value).toFixed(2)}` : 'TBD';
  }

  formatWk1Costs(row: any): string {
    const prod = parseFloat(row.WK1FSRProdCost || 0);
    const travel = parseFloat(row.WK1StoreTravelCost || 0);
    const ovg = parseFloat(row.WK1StoreTravelOvgCost || 0);
    const total = prod + travel + ovg;
    return total > 0 ? `$${total.toFixed(2)}` : '$0.00';
  }

  formatWk2Costs(row: any): string {
    const prod = parseFloat(row.WK2FSRProdCost || 0);
    const travel = parseFloat(row.WK2StoreTravelCost || 0);
    const ovg = parseFloat(row.WK2StoreTravelOvgCost || 0);
    const total = prod + travel + ovg;
    return total > 0 ? `$${total.toFixed(2)}` : '$0.00';
  }

  // Status badge classes
  getTaskCompletedClass(value: any): string {
    return value?.toLowerCase() === 'yes' ? 'completed' : 'incomplete';
  }

  getQualityClass(value: any): string {
    const quality = value?.toLowerCase();
    if (quality === 'good') return 'quality-good';
    if (quality === 'average') return 'quality-average';
    if (quality === 'poor') return 'quality-poor';
    return 'quality-unknown';
  }

  getCostOverClass(value: any): string {
    return value?.toLowerCase() === 'yes' ? 'cost-over' : 'cost-ok';
  }

  // Your existing methods (expand/collapse, assignments, etc.)
  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    
    if (this.paginator) {
      this.paginator.page
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          console.log('Page changed - resetting expansion state');
          this.forceCollapseAllRows();
          this.resetExpansionState();
        });
    }
  }

  // All your existing methods remain the same:
  // - expandAllRows()
  // - forceCollapseAllRows()
  // - GetSubgridData()
  // - openAssignmentDialog()
  // - openTaskAssignmentDialog()
  // - startCommentEdit()
  // - saveComment()
  // - etc.

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
3. Enhanced HTML Template with Dynamic Columns
xml
<!-- store-table.component.html - ENHANCED WITH DYNAMIC COLUMNS -->

<div class="table-container">
  <mat-card class="table-card" [ngClass]="getWeekTypeClass()">
    <mat-card-header>
      <mat-card-title>
        {{getWeekTypeDisplayName()}}
        <span class="week-indicator" [ngClass]="currentWeekType">
          {{currentWeekType | uppercase}}
        </span>
      </mat-card-title>
      <mat-card-subtitle>
        {{dataSource.data.length}} stores found
        <span *ngIf="getExpandedRowCount() > 0" class="expanded-info">
          • {{getExpandedRowCount()}} rows expanded
        </span>
      </mat-card-subtitle>
    </mat-card-header>
    
    <mat-card-content>
      <div class="table-wrapper">
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2">
          
          <!-- Store Number Column (Always Present) -->
          <ng-container matColumnDef="store_number">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">
              <button mat-icon-button 
                      [disabled]="isExpandingAll"
                      (click)="expandAllRows()" 
                      [title]="allExpanded ? 'Collapse All' : 'Expand All'"
                      class="expand-all-btn">
                <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
              </button>
              Store #
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
              <span class="caret" [class.clicked]="isRowExpanded(element)">▼</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Store Name Column (Always Present) -->
          <ng-container matColumnDef="store_name">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Store Name</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-name-cell">
              <span class="store-name" (click)="openProximityDataDialog(element); $event.stopPropagation();">
                {{element.StoreName}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Address Column (Always Present) -->
          <ng-container matColumnDef="addr_line1">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Address</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.AddrLine1}}</mat-cell>
          </ng-container>

          <!-- City Column (Always Present) -->
          <ng-container matColumnDef="city">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">City</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.City}}</mat-cell>
          </ng-container>

          <!-- State Column (Always Present) -->
          <ng-container matColumnDef="state">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">State</mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="state-badge">{{element.State}}</span>
            </mat-cell>
          </ng-container>

          <!-- Zip Column (Conditional) -->
          <ng-container matColumnDef="zip" *ngIf="isColumnVisible('zip')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Zip</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.Zip}}</mat-cell>
          </ng-container>

          <!-- Assigned To Column (Always Present) -->
          <ng-container matColumnDef="assigned_to">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Assigned To</mat-header-cell>
            <mat-cell *matCellDef="let element" class="assigned-cell" 
                      (click)="openAssignmentDialog(element, 'StoreLevel'); $event.stopPropagation()">
              <span class="assignment-badge" [ngClass]="getAssignmentClass(element.AssignedTo)">
                {{element.AssignedTo}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Task Completed Column (Current & Previous Week) -->
          <ng-container matColumnDef="task_completed" *ngIf="isColumnVisible('task_completed')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Completed</mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="status-badge" [ngClass]="getTaskCompletedClass(element.TaskCompleted)">
                <mat-icon>{{element.TaskCompleted?.toLowerCase() === 'yes' ? 'check_circle' : 'radio_button_unchecked'}}</mat-icon>
                {{formatTaskCompleted(element.TaskCompleted)}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Quality Column (Current & Previous Week) -->
          <ng-container matColumnDef="quality" *ngIf="isColumnVisible('quality')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Quality</mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="quality-badge" [ngClass]="getQualityClass(element.Quality)">
                {{formatQuality(element.Quality)}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Cost Over Column (Current & Previous Week) -->
          <ng-container matColumnDef="cost_over" *ngIf="isColumnVisible('cost_over')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Over Cost</mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="cost-badge" [ngClass]="getCostOverClass(element.CostOver)">
                <mat-icon>{{element.CostOver?.toLowerCase() === 'yes' ? 'warning' : 'check_circle'}}</mat-icon>
              </span>
            </mat-cell>
          </ng-container>

          <!-- Guaranteed Miles Column (Current & Future Week) -->
          <ng-container matColumnDef="guaranteed_miles" *ngIf="isColumnVisible('guaranteed_miles')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Miles</mat-header-cell>
            <mat-cell *matCellDef="let element">{{formatGuaranteedMiles(element.GuaranteedMiles)}}</mat-cell>
          </ng-container>

          <!-- Average Cost Column (Future Week Only) -->
          <ng-container matColumnDef="avg_cost" *ngIf="isColumnVisible('avg_cost')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Avg Cost</mat-header-cell>
            <mat-cell *matCellDef="let element">{{formatAvgCost(element.AvgCost)}}</mat-cell>
          </ng-container>

          <!-- WK1 Costs Column (Previous Week Only) -->
          <ng-container matColumnDef="wk1_costs" *ngIf="isColumnVisible('wk1_costs')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">WK1 Costs</mat-header-cell>
            <mat-cell *matCellDef="let element">{{formatWk1Costs(element)}}</mat-cell>
          </ng-container>

          <!-- WK2 Costs Column (Previous Week Only) -->
          <ng-container matColumnDef="wk2_costs" *ngIf="isColumnVisible('wk2_costs')">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">WK2 Costs</mat-header-cell>
            <mat-cell *matCellDef="let element">{{formatWk2Costs(element)}}</mat-cell>
          </ng-container>

          <!-- Comments Column (Always Present) -->
          <ng-container matColumnDef="user_comment">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Comments</mat-header-cell>
            <mat-cell *matCellDef="let element" class="comment-cell">
              <!-- View mode -->
              <div *ngIf="!element.IsCommentEditing" class="comment-view">
                <span class="comment-text" 
                      [title]="element.UserComment"
                      (click)="startCommentEdit(element); $event.stopPropagation();">
                  {{element.UserComment || 'Add comment...'}}
                </span>
                <button mat-icon-button 
                        (click)="startCommentEdit(element); $event.stopPropagation();"
                        class="comment-edit-btn">
                  <mat-icon>edit</mat-icon>
                </button>
              </div>
              
              <!-- Edit mode -->
              <div *ngIf="element.IsCommentEditing" class="comment-edit">
                <mat-form-field appearance="outline" class="comment-field">
                  <textarea matInput
                            [value]="element.UserComment"
                            placeholder="Enter comment..."
                            (keydown)="onCommentKeydown($event, element)"
                            #commentInput
                            rows="2"
                            maxlength="500">
                  </textarea>
                </mat-form-field>
                <div class="comment-actions">
                  <button mat-icon-button 
                          color="primary"
                          (click)="saveComment(element, commentInput.value); $event.stopPropagation();">
                    <mat-icon>check</mat-icon>
                  </button>
                  <button mat-icon-button 
                          (click)="cancelCommentEdit(element); $event.stopPropagation();">
                    <mat-icon>close</mat-icon>
                  </button>
                </div>
              </div>
            </mat-cell>
          </ng-container>

          <!-- Header and Data Rows -->
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row *matRowDef="let row; columns: displayedColumns; let i = index"
                   class="table-row"
                   [cdkDetailRow]="row" 
                   [cdkDetailRowTpl]="tpl"
                   (toggleChange)="GetSubgridData($event, row)"
                   (dataLoadRequest)="onDataLoadRequest($event)"
                   matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator [pageSizeOptions]="[5, 10, 20, 50]" 
                     showFirstLastButtons
                     class="table-paginator">
      </mat-paginator>

      <!-- Your existing subgrid template -->
      <ng-template #tpl let-element let-subgridData="subgridData" let-isLoading="isLoading">
        <!-- Your existing template content -->
      </ng-template>
    </mat-card-content>
  </mat-card>
</div>
4. Enhanced CSS for Week Types
css
/* store-table.component.css - ENHANCED FOR WEEK TYPES */

/* Week type indicators */
.week-indicator {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  margin-left: 8px;
}

.week-indicator.current {
  background: #4caf50;
  color: white;
}

.week-indicator.future {
  background: #2196f3;
  color: white;
}

.week-indicator.previous {
  background: #ff9800;
  color: white;
}

/* Week type specific card styling */
.week-current {
  border-left: 4px solid #4caf50;
}

.week-future {
  border-left: 4px solid #2196f3;
}

.week-previous {
  border-left: 4px solid #ff9800;
}

/* Status badges */
.status-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 11px;
}

.status-badge.completed {
  background: #d4edda;
  color: #155724;
}

.status-badge.incomplete {
  background: #f8d7da;
  color: #721c24;
}

.quality-badge {
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 11px;
  font-weight: 500;
}

.quality-good { background: #d4edda; color: #155724; }
.quality-average { background: #fff3cd; color: #856404; }
.quality-poor { background: #f8d7da; color: #721c24; }
.quality-unknown { background: #e2e3e5; color: #495057; }

.cost-badge mat-icon {
  font-size: 16px;
}

.cost-over mat-icon { color: #dc3545; }
.cost-ok mat-icon { color: #28a745; }

/* Comment column styles */
.comment-cell {
  min-width: 200px;
  max-width: 300px;
}

.comment-view {
  display: flex;
  align-items: center;
  gap: 8px;
}

.comment-text {
  flex: 1;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  color: #666;
  font-style: italic;
}

.comment-text:hover {
  background-color: #f5f5f5;
}

.comment-text:not(:empty) {
  color: #333;
  font-style: normal;
}

.comment-edit-btn {
  opacity: 0;
  transition: opacity 0.2s;
}

.comment-view:hover .comment-edit-btn {
  opacity: 1;
}

.comment-edit {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.comment-field {
  width: 100%;
}

.comment-actions {
  display: flex;
  justify-content: flex-end;
  gap: 4px;
}
Summary:
✅ Works with your existing C# code - No changes needed on backend
✅ Single component handles all 3 week types - Dynamic columns based on week
✅ JSON string parsing - Handles your C# controller's JSON responses
✅ Comment column included - Editable comments on all week types
✅ Field name normalization - Handles different field names from different APIs
✅ Visual indicators - Different styling for current/future/previous weeks
✅ Dynamic column visibility - Shows relevant columns for each week type
✅ All existing functionality preserved - Expand/collapse, dialogs, etc.

This solution adapts your existing store-table component to work with the 3 different week data structures while keeping all your existing functionality intact!




export class CommonService {
  
  // Week type and data subjects  
  private weekTypeSubject = new BehaviorSubject<'current' | 'future' | 'previous'>('current');
  public weekType$ = this.weekTypeSubject.asObservable();

  // Separate data subjects for each week type
  private currentWeekDataSubject = new BehaviorSubject<any[]>([]);
  public currentWeekData$ = this.currentWeekDataSubject.asObservable();

  private futureWeekDataSubject = new BehaviorSubject<any[]>([]);
  public futureWeekData$ = this.futureWeekDataSubject.asObservable();

  private previousWeekDataSubject = new BehaviorSubject<any[]>([]);
  public previousWeekData$ = this.previousWeekDataSubject.asObservable();

  // Current IRI Week tracking
  private currentIRIWeekSubject = new BehaviorSubject<string>('2405');
  
  // UPDATED: Enhanced getGridData to handle JSON string responses
  getGridData(payload: GetGridDataFilter): Observable<any[]> {
    const currentIRIWeek = this.getCurrentIRIWeek();
    const payloadIRIWeek = payload.iriWeek;
    
    let apiEndpoint = '';
    let weekType: 'current' | 'future' | 'previous' = 'current';
    
    // Determine which API to call (your exact endpoints)
    if (payloadIRIWeek === currentIRIWeek) {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetcurrentweekGridData`;
      weekType = 'current';
    } else if (payloadIRIWeek > currentIRIWeek) {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetfutureweekGridData`;
      weekType = 'future';
    } else {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetpreviousweekGridData`;
      weekType = 'previous';
    }
    
    console.log(`API Selection: ${weekType} week - ${apiEndpoint}`);
    
    // Update week type
    this.weekTypeSubject.next(weekType);
    
    // UPDATED: Handle JSON string response from your C# controller
    return this.http.post<string>(apiEndpoint, payload).pipe(
      map(jsonString => {
        try {
          // Parse the JSON string returned by your C# controller
          const parsedData = JSON.parse(jsonString);
          return Array.isArray(parsedData) ? parsedData : [];
        } catch (error) {
          console.error('Error parsing JSON response:', error);
          return [];
        }
      }),
      catchError(this.handleError<any[]>('getGridData', []))
    );
  }

  // UPDATED: Apply filters with specific data stream updates
  applyFilters(filters: GetGridDataFilter): void {
    const currentCountry = this.getCurrentCountry();
    
    if (!currentCountry) {
      filters.countryId = '1';
    } else {
      filters.countryId = currentCountry;
    }

    this.filtersSubject.next(filters);
    this.setCurrentFilterValues(this.convertToCurrentFilters(filters));
    
    // Call API and update specific data stream
    this.getGridData(filters).subscribe({
      next: (data) => {
        const currentIRIWeek = this.getCurrentIRIWeek();
        const payloadIRIWeek = filters.iriWeek;
        
        // Add comment editing capability and normalize field names
        const dataWithComments = data.map(row => ({
          ...row,
          // Normalize field names for consistent access
          StoreNumber: row.StoreNumber || row.store_number,
          StoreName: row.StoreName || row.store_name,
          City: row.CityName || row.city_name,
          State: row.StateCd || row.state_cd,
          Zip: row.ZipCd || row.zip_cd,
          AddrLine1: row.AddrLine1 || row.addr_line1,
          AssignedTo: this.getAssignedToDisplay(row),
          UserComment: row.UserComment || '',
          IsCommentEditing: false
        }));
        
        // Update appropriate data stream based on week type
        if (payloadIRIWeek === currentIRIWeek) {
          this.currentWeekDataSubject.next(dataWithComments);
          console.log(`Updated current week data: ${dataWithComments.length} records`);
        } else if (payloadIRIWeek > currentIRIWeek) {
          this.futureWeekDataSubject.next(dataWithComments);
          console.log(`Updated future week data: ${dataWithComments.length} records`);
        } else {
          this.previousWeekDataSubject.next(dataWithComments);
          console.log(`Updated previous week data: ${dataWithComments.length} records`);
        }
        
        // Also update main grid data for backward compatibility
        this.gridDataSubject.next(dataWithComments);
      },
      error: (error) => {
        console.error('Error applying filters:', error);
        this.currentWeekDataSubject.next([]);
        this.futureWeekDataSubject.next([]);
        this.previousWeekDataSubject.next([]);
        this.gridDataSubject.next([]);
      }
    });
  }

  // Helper method to get assigned display
  private getAssignedToDisplay(row: any): string {
    if (row.FirstName && row.LastName) {
      return `${row.LastName}, ${row.FirstName}`;
    }
    return 'NOT ASSIGNED';
  }

  getCurrentWeekType(): 'current' | 'future' | 'previous' {
    return this.weekTypeSubject.value;
  }

  // Add missing methods for filter management
  convertToCurrentFilters(filters: GetGridDataFilter): any {
    return {
      countryId: filters.countryId || '',
      iri_week: filters.iriWeek || '',
      territory_id: filters.territoryId || '',
      area: filters.area || '23',
      store_number: filters.storeNumber || '',
      store_name: filters.storeName || '',
      state: filters.state || '',
      city: filters.city || '',
      position_number: filters.positionNumber || '',
      task_number: filters.taskNumber || '',
      emp_id: filters.empId || '',
      fsr_hour: filters.fsrHour || '',
      fsr_hour_operator: filters.fsrHourOperator || 'NA',
      fsr_over_25hrs: filters.fsrOver25hrs || 'false',
      fsr_over_6hrs: filters.fsrOver6hrs || 'false',
      assigned_stores: filters.assignedStores || 'false',
      unassigned_stores: filters.unassignedStores || 'false',
      sample: filters.sample || 'false',
      nonsample: filters.nonSample || 'false',
      multi_fsr_store: filters.multiFsrStore || 'false',
      vacation: filters.vacation || 'false',
      temporary: filters.temporary || 'false'
    };
  }

  setCurrentFilterValues(filters: any): void {
    this.currentFiltersSubject.next(filters);
    console.log('Current filters updated:', filters);
  }
}
