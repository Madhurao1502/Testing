<div class="table-container">
  <mat-card class="table-card" [ngClass]="getWeekTypeClass()">
    
    <mat-card-content>
      <div class="table-wrapper">
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2" [ngClass]="getWeekTypeTableClass()">
          
          <!-- ==================== ALL COLUMN DEFINITIONS ==================== -->
          
          <!-- Store Number Column -->
          <ng-container matColumnDef="store_number" *ngIf="isColumnVisible('store_number')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="StoreNumber" class="mat-header-style">
              <button mat-icon-button 
                      [disabled]="isExpandingAll"
                      (click)="expandAllRows(); $event.stopPropagation()" 
                      [title]="allExpanded ? 'Collapse All' : 'Expand All'"
                      class="expand-all-btn">
                <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
              </button>
              Store #
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
              <span class="caret" [class.clicked]="isRowExpanded(element)">▼</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Territory -->
          <ng-container matColumnDef="territory" *ngIf="isColumnVisible('territory')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="FldTerrtyNbr" class="mat-header-style" matTooltip="Territory">
              Terr
            </mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.FldTerrtyNbr || element.bfd}}</mat-cell>
          </ng-container>

          <!-- Position Number -->
          <ng-container matColumnDef="position_number" *ngIf="isColumnVisible('position_number')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="PositionName" class="mat-header-style">
              Position #
            </mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.PositionName || element.taskName}}</mat-cell>
          </ng-container>

          <!-- BFD -->
          <ng-container matColumnDef="bdf" *ngIf="isColumnVisible('bdf')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="Bfd" class="mat-header-style">BFD</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.Bfd || element.bfd}}</mat-cell>
          </ng-container>

          <!-- Outlet -->
          <ng-container matColumnDef="outlet" *ngIf="isColumnVisible('outlet')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="OutletType" class="mat-header-style">
              Outlet
            </mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.OutletType}}</mat-cell>
          </ng-container>

          <!-- Store Name -->
          <ng-container matColumnDef="store_name" *ngIf="isColumnVisible('store_name')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="StoreName" class="mat-header-style">
              Store Name
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-name-cell">
              <span class="store-name" 
                    *ngIf="!element.isChildRow"
                    (click)="openProximityDataDialog(element); $event.stopPropagation();">
                {{element.StoreName}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Address -->
          <ng-container matColumnDef="addr_line1" *ngIf="isColumnVisible('addr_line1')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="AddrLine1" class="mat-header-style">
              Address
            </mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.AddrLine1}}</mat-cell>
          </ng-container>

          <!-- City -->
          <ng-container matColumnDef="city" *ngIf="isColumnVisible('city')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="City" class="mat-header-style">City</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.City}}</mat-cell>
          </ng-container>

          <!-- State -->
          <ng-container matColumnDef="state" *ngIf="isColumnVisible('state')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="State" class="mat-header-style">State</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.State}}</mat-cell>
          </ng-container>

          <!-- Zip -->
          <ng-container matColumnDef="zip" *ngIf="isColumnVisible('zip')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="Zip" class="mat-header-style">Zip</mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.Zip}}</mat-cell>
          </ng-container>

          <!-- Assigned To -->
          <ng-container matColumnDef="assigned_to" *ngIf="isColumnVisible('assigned_to')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="AssignedTo" class="mat-header-style">
              Assigned To
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="assigned-cell" 
                      [class.child-assigned]="element.isChildRow"
                      (click)="element.isChildRow ? openTaskAssignmentDialog2(element) : openAssignmentDialog(element, 'StoreLevel'); $event.stopPropagation()">
              
              <!-- Parent Row Assigned To -->
              <div *ngIf="!element.isChildRow" class="assignment-container">
                <div class="assignment-names" 
                     [ngClass]="getAssignmentClass(element.AssignedTo)"
                     [matTooltip]="getAssignedToTooltip(element.AssignedTo)"
                     matTooltipClass="multi-line-tooltip">
                  
                  <div *ngIf="!shouldDisplayMultipleLines(element.AssignedTo)" class="single-name">
                    {{element.AssignedTo || 'NOT ASSIGNED'}}
                  </div>
                  
                  <div *ngIf="shouldDisplayMultipleLines(element.AssignedTo)" class="multiple-names">
                    <div *ngFor="let name of getIndividualNames(element.AssignedTo); let i = index" 
                         class="name-line" [class.first-name]="i === 0">
                      {{name}}
                    </div>
                  </div>
                </div>
                
                <!-- Optimal Collector Indicator -->
                <div class="optimal-collector-indicator">
                  <div class="circle-green" 
                       *ngIf="hasOptimalCollector(element.OptimalCollectorId) && isOptimalCollectorMatch(element.EmpId, element.OptimalCollectorId)" 
                       (click)="openClosestFsrDataDialog(element); $event.stopPropagation()"
                       matTooltip="Optimal collector assigned">
                    <span class="checkmark"></span>
                  </div>
                  
                  <div class="circle-red" 
                       *ngIf="hasOptimalCollector(element.OptimalCollectorId) && !isOptimalCollectorMatch(element.EmpId, element.OptimalCollectorId)" 
                       (click)="openClosestFsrDataDialog(element); $event.stopPropagation()"
                       matTooltip="Non-optimal collector assigned">
                    <span class="crossmark"></span>
                  </div>
                  
                  <div class="circle-gray" 
                       *ngIf="!hasOptimalCollector(element.OptimalCollectorId) && element.EmpId" 
                       (click)="openClosestFsrDataDialog(element); $event.stopPropagation()"
                       matTooltip="No optimal collector data">
                    <span class="checkmark"></span>
                  </div>
                </div>
              </div>
              
              <!-- Child Row Assigned To -->
              <span *ngIf="element.isChildRow" class="clickable-link">
                {{element.assignedTo || element.AssignedTo}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Task Completed -->
          <ng-container matColumnDef="task_completed" *ngIf="isColumnVisible('task_completed')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="TaskCompleted" class="mat-header-style" matTooltip="Completed">
              Completed
            </mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="status-badge" [ngClass]="getTaskCompletedClass(element.TaskCompleted || element.taskCompleted)">
                {{formatTaskCompleted(element.TaskCompleted || element.taskCompleted)}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Cost Over -->
          <ng-container matColumnDef="cost_over" *ngIf="isColumnVisible('cost_over')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="CostOver" class="mat-header-style">
              Over Cost
            </mat-header-cell>
            <mat-cell *matCellDef="let element">
              <span class="cost-badge" [ngClass]="getCostOverClass(element.CostOver || element.costOver)">
                {{(element.CostOver || element.costOver) | currencyFormat}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Guaranteed Miles -->
          <ng-container matColumnDef="guaranteed_miles" *ngIf="isColumnVisible('guaranteed_miles')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="GuaranteedMiles" class="mat-header-style">
              Miles
            </mat-header-cell>
            <mat-cell *matCellDef="let element">
              {{formatGuaranteedMiles(element.GuaranteedMiles || element.guaranteedMiles)}}
            </mat-cell>
          </ng-container>

          <!-- Average Cost (Future Week) -->
          <ng-container matColumnDef="avg_cost" *ngIf="isColumnVisible('avg_cost')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="AvgCost" class="mat-header-style">
              Avg Cost
            </mat-header-cell>
            <mat-cell *matCellDef="let element">
              {{formatAvgCost(element.AvgCost || element.avgCost)}}
            </mat-cell>
          </ng-container>

          <!-- WK1 Costs -->
          <ng-container matColumnDef="wk1_costs" *ngIf="isColumnVisible('wk1_costs')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK1FSRProdCost" class="mat-header-style">
              W{{this.currentFilters?.iri_week}} Cost
            </mat-header-cell>
            <mat-cell *matCellDef="let element" 
                      [ngClass]="{'negative': (element.WK1FSRProdCost || element.wK1FSRProdCost) > 0, 
                                  'positive': (element.WK1FSRProdCost || element.wK1FSRProdCost) <= 0}">
              {{(element.WK1FSRProdCost || element.wK1FSRProdCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- WK1 Travel -->
          <ng-container matColumnDef="wk1_travel" *ngIf="isColumnVisible('wk1_travel')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK1StoreTravelCost" class="mat-header-style">
              W{{this.currentFilters?.iri_week}} Travel
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="travel-column">
              {{(element.WK1StoreTravelCost || element.wK1StoreTravelCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- WK1 Ovg Travel -->
          <ng-container matColumnDef="wk1_ovg_travel" *ngIf="isColumnVisible('wk1_ovg_travel')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK1StoreTravelOvgCost" class="mat-header-style">
              W{{this.currentFilters?.iri_week}} Ovg Travel
            </mat-header-cell>
            <mat-cell *matCellDef="let element"
                      [ngClass]="{'negative': (element.WK1StoreTravelOvgCost || element.wK1StoreTravelOvgCost) > 0, 
                                  'positive': (element.WK1StoreTravelOvgCost || element.wK1StoreTravelOvgCost) <= 0}">
              {{(element.WK1StoreTravelOvgCost || element.wK1StoreTravelOvgCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- WK2 Costs -->
          <ng-container matColumnDef="wk2_costs" *ngIf="isColumnVisible('wk2_costs')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK2FSRProdCost" class="mat-header-style">
              WK2 Cost
            </mat-header-cell>
            <mat-cell *matCellDef="let element"
                      [ngClass]="{'negative': (element.WK2FSRProdCost || element.wK2FSRProdCost) > 0, 
                                  'positive': (element.WK2FSRProdCost || element.wK2FSRProdCost) <= 0}">
              {{(element.WK2FSRProdCost || element.wK2FSRProdCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- WK2 Travel -->
          <ng-container matColumnDef="wk2_travel" *ngIf="isColumnVisible('wk2_travel')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK2StoreTravelCost" class="mat-header-style">
              WK2 Travel
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="travel-column">
              {{(element.WK2StoreTravelCost || element.wK2StoreTravelCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- WK2 Ovg Travel -->
          <ng-container matColumnDef="wk2_ovg_travel" *ngIf="isColumnVisible('wk2_ovg_travel')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="WK2StoreTravelOvgCost" class="mat-header-style">
              WK2 Ovg Travel
            </mat-header-cell>
            <mat-cell *matCellDef="let element"
                      [ngClass]="{'negative': (element.WK2StoreTravelOvgCost || element.wK2StoreTravelOvgCost) > 0, 
                                  'positive': (element.WK2StoreTravelOvgCost || element.wK2StoreTravelOvgCost) <= 0}">
              {{(element.WK2StoreTravelOvgCost || element.wK2StoreTravelOvgCost) | currencyFormat}}
            </mat-cell>
          </ng-container>

          <!-- Comments -->
          <ng-container matColumnDef="user_comment" *ngIf="isColumnVisible('user_comment')">
            <mat-header-cell *matHeaderCellDef mat-sort-header="UserComment" class="mat-header-style">
              Comments
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="comment-cell">
              <div *ngIf="!element.isChildRow"
                   class="comment-display"
                   (click)="openCommentDialog(element); $event.stopPropagation();"
                   [title]="element.UserComment || 'Click to add/edit comment'"
                   [class.has-comment]="element.UserComment"
                   [class.clickable]="canEditComments || element.UserComment">
                <span class="comment-text">{{getCommentDisplay(element.UserComment)}}</span>
              </div>
            </mat-cell>
          </ng-container>

          <!-- ==================== HEADER AND DATA ROWS ==================== -->
          
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          
          <!-- Regular rows (both parent and child) -->
          <mat-row *matRowDef="let row; columns: displayedColumns;"
                   class="table-row"
                   [class.parent-row]="!row.isChildRow"
                   [class.child-row]="row.isChildRow"
                   [class.child-row-first]="row.isChildRow && row.isFirstChild"
                   [class.child-row-last]="row.isChildRow && row.isLastChild"
                   [cdkDetailRow]="row" 
                   [cdkDetailRowTpl]="tpl"                  
                   (toggleChange)="onDataLoadRequest({directive: $event, rowData: row})"
                   matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <!-- Search and Paginator -->
      <div class="search-paginator-bar">
        <mat-form-field appearance="standard" class="search-field">
          <mat-label>Search...</mat-label>
          <input matInput [formControl]="searchControl" 
                 placeholder="Search by store number, name, address, city, state, assigned to, etc.">
          <mat-icon matPrefix>search</mat-icon>
          <button mat-button *ngIf="searchControl.value" matSuffix mat-icon-button (click)="clearSearch()">
            <mat-icon>clear</mat-icon>
          </button>
        </mat-form-field>
        
        <mat-paginator [pageSizeOptions]="[50,100,150,200]"
                       showFirstLastButtons="true">
        </mat-paginator>
      </div>

    </mat-card-content>
  </mat-card>
</div>

<!-- Empty template - child rows are rendered directly in the table -->
<ng-template #tpl let-element></ng-template>

<footer>
  <div class="mat-spinner-container">
    <mat-spinner mode="indeterminate" *ngIf="showSpinner"></mat-spinner>
    <div *ngIf="showSpinner" style="position:relative;left: 10px">Loading...</div>
  </div>
</footer>


/**
 * Modified data load request to insert child rows into datasource
 */
onDataLoadRequest(event: {directive: CdkDetailRowDirective, rowData: any}): void {
  const { directive, rowData } = event;
  const storeKey = rowData.StoreNumber || rowData.store_number;
  
  if (directive.isExpanded && !rowData.isChildRow) {
    // Expanding parent row - load and insert child rows
    this.expandedRows.add(directive);
    this.selectedRows.add(rowData);
    
    if (this.expandedRowsData.has(storeKey)) {
      const cachedData = this.expandedRowsData.get(storeKey);
      this.insertChildRowsIntoDataSource(rowData, cachedData?.data || [], cachedData?.weekType || 'current');
    } else {
      this.loadSubgridDataForRow(rowData)
        .then(responseData => {
          this.insertChildRowsIntoDataSource(rowData, responseData.data || [], responseData.weekType || 'current');
        })
        .catch(error => {
          console.error('Error loading subgrid data:', error);
        });
    }
  } else if (!directive.isExpanded) {
    // Collapsing - remove child rows
    this.expandedRows.delete(directive);
    this.selectedRows.delete(rowData);
    this.removeChildRowsFromDataSource(rowData);
    
    if (this.allExpanded && this.expandedRows.size < this.getCurrentPageData().length) {
      this.allExpanded = false;
    }
  }
  
  this.cdr.detectChanges();
}

/**
 * Insert child rows directly into the table's datasource
 */
private insertChildRowsIntoDataSource(parentRow: any, childData: any[], weekType: string): void {
  const currentData = this.dataSource.data;
  const parentIndex = currentData.findIndex(row => 
    row.StoreNumber === parentRow.StoreNumber && !row.isChildRow
  );
  
  if (parentIndex === -1) return;
  
  // Remove any existing child rows for this parent first
  this.removeChildRowsFromDataSource(parentRow);
  
  // Map child data to match parent column structure
  const childRows = childData.map((child, index) => ({
    ...child,
    isChildRow: true,
    isFirstChild: index === 0,
    isLastChild: index === childData.length - 1,
    parentStoreNumber: parentRow.StoreNumber,
    
    // Map child fields to parent column names
    StoreNumber: '', // Empty for indent
    FldTerrtyNbr: child.bfd || '',
    PositionName: child.taskName || '',
    Bfd: child.bfd || '',
    OutletType: '',
    StoreName: '',
    AddrLine1: '',
    City: '',
    State: '',
    Zip: '',
    AssignedTo: child.assignedTo || '',
    assignedTo: child.assignedTo || '',
    
    // Task-level data
    TaskCompleted: child.taskCompleted || child.TaskCompleted,
    taskCompleted: child.taskCompleted || child.TaskCompleted,
    GuaranteedMiles: child.guaranteedMiles,
    guaranteedMiles: child.guaranteedMiles,
    CostOver: child.costOver,
    costOver: child.costOver,
    
    // Week-specific fields
    ...(weekType === 'future' && {
      AvgCost: child.avgCost,
      avgCost: child.avgCost,
      Wave: child.wave,
      ExpectedCollectionTime: child.expectedCollectionTime
    }),
    
    ...(weekType === 'previous' && {
      WK1FSRProdCost: child.wK1FSRProdCost,
      wK1FSRProdCost: child.wK1FSRProdCost,
      WK1StoreTravelCost: child.wK1StoreTravelCost,
      wK1StoreTravelCost: child.wK1StoreTravelCost,
      WK1StoreTravelOvgCost: child.wK1StoreTravelOvgCost,
      wK1StoreTravelOvgCost: child.wK1StoreTravelOvgCost,
      WK2FSRProdCost: child.wK2FSRProdCost,
      wK2FSRProdCost: child.wK2FSRProdCost,
      WK2StoreTravelCost: child.wK2StoreTravelCost,
      wK2StoreTravelCost: child.wK2StoreTravelCost,
      WK2StoreTravelOvgCost: child.wK2StoreTravelOvgCost,
      wK2StoreTravelOvgCost: child.wK2StoreTravelOvgCost,
      Quality: child.quality
    }),
    
    // Store task-specific data for dialog access
    storeNumber: child.storeNumber || parentRow.StoreNumber,
    storeName: child.storeName || parentRow.StoreName,
    taskNumber: child.taskNumber,
    taskName: child.taskName
  }));
  
  // Get updated data array
  const updatedData = [...currentData];
  updatedData.splice(parentIndex + 1, 0, ...childRows);
  
  // Update datasource
  this.dataSource.data = updatedData;
}

/**
 * Remove child rows from datasource
 */
private removeChildRowsFromDataSource(parentRow: any): void {
  const filteredData = this.dataSource.data.filter(row => 
    !(row.isChildRow && row.parentStoreNumber === parentRow.StoreNumber)
  );
  this.dataSource.data = filteredData;
}


/* Keep all your existing CSS and add/update these styles */

/* Parent row styling */
.parent-row {
  background: white;
  cursor: pointer;
  transition: background-color 0.2s;
}

.parent-row:hover {
  background-color: mintcream;
}

/* Child row styling - seamless continuation */
.child-row {
  background: #f8f9fa !important;
  border-left: 4px solid #2196f3;
  font-size: 13px;
  color: #555;
}

.child-row:hover {
  background-color: #e3f2fd !important;
}

/* First child row - no top border */
.child-row-first {
  border-top: none !important;
}

/* Last child row - add bottom border */
.child-row-last {
  border-bottom: 2px solid #2196f3 !important;
}

/* Child row cells - indent first column */
.child-row .mat-column-store_number {
  padding-left: 30px !important;
  position: relative;
}

.child-row .mat-column-store_number::before {
  content: '└─';
  position: absolute;
  left: 10px;
  color: #999;
  font-size: 14px;
}

/* Hide caret in child rows */
.child-row .caret {
  display: none !important;
}

/* Make task name prominent in child rows */
.child-row .mat-column-position_number {
  font-weight: 500;
  color: #333;
}

/* Child row assigned to styling */
.child-assigned {
  cursor: pointer;
}

.child-row .clickable-link {
  color: #1976d2;
  text-decoration: underline;
  cursor: pointer;
  font-weight: 500;
  transition: color 0.2s;
}

.child-row .clickable-link:hover {
  color: #0d47a1;
}

/* Remove old expanded-table styles */
.expanded-table {
  display: none; /* Hide the old separate table */
}

/* Detail row wrapper - now empty */
.detail-row {
  display: none;
}

/* Ensure consistent column widths for child rows */
.child-row .mat-cell {
  padding: 8px 5px;
}

/* Loading indicator - update positioning */
.row-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 15px;
  background: #f8f9fa;
  border-left: 4px solid #2196f3;
  margin: 0;
  font-size: 13px;
  color: #666;
}
