export interface ShelfNode {
id: number;
pId: number | null;
name: string;
checked: boolean;
children?: ShelfNode[];
value?: number;
optional?: string;
varlabel?: string;
var_type_id?: number;
shelf_var_lookup?: string;
no_display?: string;
mainMin?: string | number;
mainMax?: string | number;
main_soft_check?: string | number;
main_hard_check?: string | number;
taskMin?: string | number;
taskMax?: string | number;
task_soft_check?: string | number;
task_hard_check?: string | number;
mainOrdinal?: number;
taskOrdinal?: number;
task_number?: number;
disabled?: boolean;
isParent?: boolean;
open?: boolean;
}

export interface ReviewCategory {
ReviewCategoryNumber: number;
TaskNumber?: number;
Catg_Type?: string;
ReviewCategoryName: string;
KeycatNumber?: number;
KeycatName?: string;
Selected?: number | null;
QCUnderReq?: number | null;
QCUnderPercent?: number | null;
NumberOfWeeks?: number | null;
Stub_Name?: string;
Stub_Type?: string;
TranslationTask?: any;
}

export interface TaskShelfVar {
task_number: number;
prompt_level: number;
ShelfVarID: number;
min?: string | number;
max?: string | number;
soft_check?: string | number;
hard_check?: string | number;
ordinal?: number;
name: string;
}

export interface TreeOptions {
useCheckbox: boolean;
useTriState: boolean;
allowDrag?: boolean;
allowDrop?: boolean;
displayField: string;
childrenField: string;
hasChildrenField?: string;
}



## 2. **Service Layer (`services/shelf-task.service.ts`)**

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, Observable, of } from 'rxjs';
import { ShelfNode, ReviewCategory, TaskShelfVar } from '../models/shelf-task.models';

@Injectable({
  providedIn: 'root'
})
export class ShelfTaskService {
  private taskId: number = 0;
  private taskVersion: string = '';
  private lockoutId: string = '';
  private currentUser: string = '';

  // Tree data subjects
  private locationTreeSubject = new BehaviorSubject<ShelfNode[]>([]);
  private sectionTreeSubject = new BehaviorSubject<ShelfNode[]>([]);
  private shelfTreeSubject = new BehaviorSubject<ShelfNode[]>([]);
  private upcTreeSubject = new BehaviorSubject<ShelfNode[]>([]);

  // Review category subjects
  private reviewCategoriesSubject = new BehaviorSubject<ReviewCategory[]>([]);
  private selectedReviewCategoriesSubject = new BehaviorSubject<ReviewCategory[]>([]);

  // Observable streams
  locationTree$ = this.locationTreeSubject.asObservable();
  sectionTree$ = this.sectionTreeSubject.asObservable();
  shelfTree$ = this.shelfTreeSubject.asObservable();
  upcTree$ = this.upcTreeSubject.asObservable();
  reviewCategories$ = this.reviewCategoriesSubject.asObservable();
  selectedReviewCategories$ = this.selectedReviewCategoriesSubject.asObservable();

  constructor(private http: HttpClient) {}

  initializeTask(taskId: number, taskVersion: string, lockoutId: string, currentUser: string) {
    this.taskId = taskId;
    this.taskVersion = taskVersion;
    this.lockoutId = lockoutId;
    this.currentUser = currentUser;
  }

  loadShelfVar(grp: number): Observable<ShelfNode[]> {
    return this.http.post<ShelfNode[]>('/Task/GetTaskShelfVar', { 
      taskId: this.taskId, 
      grp: grp 
    });
  }

  loadAllTreeData() {
    // Load Location tree (grp: 1)
    this.loadShelfVar(1).subscribe(data => {
      const processedData = this.processTreeData(data);
      this.locationTreeSubject.next(processedData);
    });

    // Load Section tree (grp: 2)
    this.loadShelfVar(2).subscribe(data => {
      const processedData = this.processTreeData(data);
      this.sectionTreeSubject.next(processedData);
    });

    // Load Shelf tree (grp: 3)
    this.loadShelfVar(3).subscribe(data => {
      const processedData = this.processTreeData(data);
      this.shelfTreeSubject.next(processedData);
    });

    // Load UPC tree (grp: 4)
    this.loadShelfVar(4).subscribe(data => {
      const processedData = this.processTreeData(data);
      this.upcTreeSubject.next(processedData);
    });
  }

  loadReviewCategories(): Observable<{ReviewCategories: ReviewCategory[], CollectionCategories: ReviewCategory[]}> {
    return this.http.post<{ReviewCategories: ReviewCategory[], CollectionCategories: ReviewCategory[]}>(
      '/Task/GetReviewCategoryDetailsForShelf', 
      { task_number: this.taskId }
    );
  }

  saveShelfVarDetails(shelfVarData: string): Observable<any> {
    return this.http.post('/Task/SaveShelfVarDetails', {
      shelfVarData: shelfVarData,
      taskId: this.taskId
    });
  }

  saveReviewCategoryDetails(reviewCats: string): Observable<any> {
    return this.http.post('/Task/SaveReviewCategoryDetailsForShelf', {
      reviewCats: reviewCats,
      task_number: this.taskId
    });
  }

  private processTreeData(data: ShelfNode[]): ShelfNode[] {
    const nodeMap = new Map<number, ShelfNode>();
    const rootNodes: ShelfNode[] = [];

    // First pass: create all nodes
    data.forEach(item => {
      const node: ShelfNode = {
        ...item,
        children: [],
        isParent: false,
        disabled: this.isTaskLocked()
      };
      nodeMap.set(item.id, node);
    });

    // Second pass: build tree structure
    data.forEach(item => {
      const node = nodeMap.get(item.id)!;
      if (item.pId === null || item.pId === 0) {
        rootNodes.push(node);
      } else {
        const parent = nodeMap.get(item.pId);
        if (parent) {
          parent.children!.push(node);
          parent.isParent = true;
        }
      }
    });

    return rootNodes;
  }

  isTaskLocked(): boolean {
    return this.taskVersion === 'FNL' || this.lockoutId !== this.currentUser;
  }

  // Tree update methods
  updateLocationTree(data: ShelfNode[]) {
    this.locationTreeSubject.next(data);
  }

  updateSectionTree(data: ShelfNode[]) {
    this.sectionTreeSubject.next(data);
  }

  updateShelfTree(data: ShelfNode[]) {
    this.shelfTreeSubject.next(data);
  }

  updateUpcTree(data: ShelfNode[]) {
    this.upcTreeSubject.next(data);
  }

  updateReviewCategories(data: ReviewCategory[]) {
    this.reviewCategoriesSubject.next(data);
  }

  updateSelectedReviewCategories(data: ReviewCategory[]) {
    this.selectedReviewCategoriesSubject.next(data);
  }

  // Current values getters
  get currentLocationTree(): ShelfNode[] {
    return this.locationTreeSubject.value;
  }

  get currentSectionTree(): ShelfNode[] {
    return this.sectionTreeSubject.value;
  }

  get currentShelfTree(): ShelfNode[] {
    return this.shelfTreeSubject.value;
  }

  get currentUpcTree(): ShelfNode[] {
    return this.upcTreeSubject.value;
  }

  get currentReviewCategories(): ReviewCategory[] {
    return this.reviewCategoriesSubject.value;
  }

  get currentSelectedReviewCategories(): ReviewCategory[] {
    return this.selectedReviewCategoriesSubject.value;
  }
}


Main Shelf Task Component (components/shelf-task.component.ts)

import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subject, takeUntil } from 'rxjs';
import { ShelfTaskService } from '../services/shelf-task.service';
import { ShelfNode, ReviewCategory, TaskShelfVar } from '../models/shelf-task.models';

@Component({
  selector: 'app-shelf-task',
  templateUrl: './shelf-task.component.html',
  styleUrls: ['./shelf-task.component.scss']
})
export class ShelfTaskComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();

  // Tree data
  locationTree: ShelfNode[] = [];
  sectionTree: ShelfNode[] = [];
  shelfTree: ShelfNode[] = [];
  upcTree: ShelfNode[] = [];

  // Review categories
  reviewCategories: ReviewCategory[] = [];
  selectedReviewCategories: ReviewCategory[] = [];

  // UI state
  activeTab: string = 'location';
  activeNode: ShelfNode | null = null;
  showLimitsPanel: boolean = false;
  showChecksPanel: boolean = false;
  isTaskLocked: boolean = false;

  // Active section/shelf min/max tracking
  activeSectionMinMax: number | null = null;
  activeShelfMinMax: number | null = null;

  // Current active tab for context
  currActiveTab: string = 'trLocation';

  // Form values
  limitsForm = {
    min: '',
    max: '',
    soft: '',
    hard: ''
  };

  constructor(private shelfTaskService: ShelfTaskService) {}

  ngOnInit() {
    // Initialize with sample data (replace with actual initialization)
    this.initializeTask(8946, 'DRAFT', '', 'currentUser');
    
    this.subscribeToDataStreams();
    this.loadInitialData();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private initializeTask(taskId: number, taskVersion: string, lockoutId: string, currentUser: string) {
    this.shelfTaskService.initializeTask(taskId, taskVersion, lockoutId, currentUser);
    this.isTaskLocked = this.shelfTaskService.isTaskLocked();
  }

  private subscribeToDataStreams() {
    // Subscribe to tree data
    this.shelfTaskService.locationTree$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.locationTree = data);

    this.shelfTaskService.sectionTree$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.sectionTree = data);

    this.shelfTaskService.shelfTree$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.shelfTree = data);

    this.shelfTaskService.upcTree$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.upcTree = data);

    // Subscribe to review categories
    this.shelfTaskService.reviewCategories$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.reviewCategories = data);

    this.shelfTaskService.selectedReviewCategories$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => this.selectedReviewCategories = data);
  }

  private loadInitialData() {
    // Load all tree data
    this.shelfTaskService.loadAllTreeData();

    // Load review categories
    this.shelfTaskService.loadReviewCategories().subscribe(result => {
      this.shelfTaskService.updateReviewCategories(result.ReviewCategories);
      this.shelfTaskService.updateSelectedReviewCategories(result.CollectionCategories);
    });

    // Set initial active tab
    this.onTabChange('location');
  }

  onTabChange(tabName: string) {
    this.activeTab = tabName;
    this.currActiveTab = `tr${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`;
    
    // Reset active node and panels
    this.activeNode = null;
    this.hideAllPanels();

    // Set default node selection based on tab
    setTimeout(() => {
      this.selectDefaultNode(tabName);
    }, 100);
  }

  private selectDefaultNode(tabName: string) {
    let tree: ShelfNode[] = [];
    
    switch(tabName) {
      case 'location': tree = this.locationTree; break;
      case 'section': tree = this.sectionTree; break;
      case 'shelf': tree = this.shelfTree; break;
      case 'upc': tree = this.upcTree; break;
    }

    if (tree.length > 0) {
      const rootNode = tree[0];
      this.onNodeSelect(rootNode);
    }
  }

  onNodeSelect(node: ShelfNode) {
    this.activeNode = node;
    this.showHideVarDiv(node);
  }

  onNodeCheck(node: ShelfNode) {
    node.checked = !node.checked;
    
    // Handle special logic for specific nodes
    this.handleSpecialNodeLogic(node);
    
    // Update tree
    this.updateTreeData();
    
    // Show/hide panels
    this.showHideVarDiv(node);
  }

  private handleSpecialNodeLogic(node: ShelfNode) {
    // Handle Section tab special logic (nodes 11930, 11960)
    if ((node.id === 11930 || node.id === 11960) && this.activeTab === 'section') {
      const sectionTree = this.sectionTree;
      const node1 = this.findNodeById(sectionTree, 11930);
      const node2 = this.findNodeById(sectionTree, 11960);
      
      if (node1 && node2 && !node1.checked && !node2.checked) {
        node.checked = true;
      }
    }
  }

  private findNodeById(nodes: ShelfNode[], id: number): ShelfNode | null {
    for (let node of nodes) {
      if (node.id === id) return node;
      if (node.children) {
        const found = this.findNodeById(node.children, id);
        if (found) return found;
      }
    }
    return null;
  }

  private showHideVarDiv(treeNode: ShelfNode) {
    // Reset all panels first
    this.hideAllPanels();
    this.resetActiveSectionShelf();

    // Handle specific node types
    if (this.isShelfHeightNode(treeNode)) {
      this.showLimitsPanel = true;
      this.populateLimitsForm(treeNode);
      this.activeShelfMinMax = treeNode.id;
      return;
    }

    if (this.isSectionWidthNode(treeNode)) {
      this.showLimitsPanel = true;
      this.populateLimitsForm(treeNode);
      this.activeSectionMinMax = treeNode.id;
      return;
    }

    if (this.isMainVariableNode(treeNode)) {
      this.showLimitsPanel = true;
      this.showChecksPanel = true;
      this.populateFullForm(treeNode);
    }
  }

  private isShelfHeightNode(node: ShelfNode): boolean {
    return node.id === 22700; // Other Height in Shelf
  }

  private isSectionWidthNode(node: ShelfNode): boolean {
    const sectionWidthIds = [11160, 14825, 15995, 15490, 16910];
    return sectionWidthIds.includes(node.id);
  }

  private isMainVariableNode(node: ShelfNode): boolean {
    const mainVarIds = [200, 10100, 20000, 30100];
    return mainVarIds.includes(node.id);
  }

  private populateLimitsForm(node: ShelfNode) {
    this.limitsForm = {
      min: (node.taskMin || node.mainMin || '').toString(),
      max: (node.taskMax || node.mainMax || '').toString(),
      soft: '',
      hard: ''
    };
  }

  private populateFullForm(node: ShelfNode) {
    this.limitsForm = {
      min: (node.taskMin || node.mainMin || '').toString(),
      max: (node.taskMax || node.mainMax || '').toString(),
      soft: (node.task_soft_check || node.main_soft_check || '').toString(),
      hard: (node.task_hard_check || node.main_hard_check || '').toString()
    };
  }

  private hideAllPanels() {
    this.showLimitsPanel = false;
    this.showChecksPanel = false;
  }

  private resetActiveSectionShelf() {
    this.activeSectionMinMax = null;
    this.activeShelfMinMax = null;
  }

  onLimitChange(field: string, value: string) {
    if (!this.activeNode) return;

    // Validate the change
    if (!this.validateLimitChange(field, value)) {
      this.resetLimitValue(field);
      return;
    }

    // Update the active node
    this.updateNodeValue(this.activeNode, field, value);
    
    // Update the form
    (this.limitsForm as any)[field] = value;

    // Update tree data
    this.updateTreeData();
  }

  private validateLimitChange(field: string, value: string): boolean {
    const numValue = parseInt(value, 10);
    
    if (isNaN(numValue)) return false;

    // Validate based on current tab and field
    if (this.currActiveTab === 'trShelf' && this.activeShelfMinMax) {
      return this.validateShelfLimits(field, numValue);
    }

    if (this.currActiveTab === 'trSection' && this.activeSectionMinMax) {
      return this.validateSectionLimits(field, numValue);
    }

    return this.validateGeneralLimits(field, numValue);
  }

  private validateShelfLimits(field: string, value: number): boolean {
    if (field === 'min') {
      const minVal = this.getMinMaxValueForShelf(1);
      if (value > minVal) {
        alert('The value for Min must be less than the smallest selected width variable');
        return false;
      }
    }

    if (field === 'max') {
      if (value === 0) {
        alert('A value is required for Max');
        return false;
      }
      const maxVal = this.getMinMaxValueForShelf(2);
      if (value < maxVal) {
        alert('The value of Max must be greater than the largest selected width variable');
        return false;
      }
    }

    return true;
  }

  private validateSectionLimits(field: string, value: number): boolean {
    if (field === 'min') {
      const minVal = this.getMinMaxValueOfSection(1);
      if (value > minVal && minVal !== -1) {
        alert('The value for Min must be less than the smallest selected width variable');
        return false;
      }
    }

    if (field === 'max') {
      if (value === 0) {
        alert('A value is required for Max');
        return false;
      }
      const maxVal = this.getMinMaxValueOfSection(2);
      if (value < maxVal && maxVal !== -1) {
        alert('The value of Max must be greater than the largest selected width variable');
        return false;
      }
    }

    return true;
  }

  private validateGeneralLimits(field: string, value: number): boolean {
    const minVal = parseInt(this.limitsForm.min, 10) || 0;
    const softVal = parseInt(this.limitsForm.soft, 10) || 0;
    const hardVal = parseInt(this.limitsForm.hard, 10) || 0;
    const maxVal = parseInt(this.limitsForm.max, 10) || 0;

    if (field === 'soft' && value < minVal) {
      alert("'Soft Check' must be greater than or equal to the Min Limit");
      return false;
    }

    if (field === 'hard' && value < (softVal + 3)) {
      alert("The value for 'Hard Check' must be at least 3 greater than the value of 'Soft Check'");
      return false;
    }

    if (this.currActiveTab === 'trLocation' && field === 'hard' && value > maxVal) {
      alert("Max Limit must be greater than the Hard Check");
      return false;
    }

    return true;
  }

  private getMinMaxValueForShelf(type: 1 | 2): number {
    const shelfTree = this.shelfTree;
    const values: number[] = [];

    this.collectHeightValues(shelfTree, values);

    if (values.length === 0) return type === 1 ? 0 : 999;
    
    return type === 1 ? Math.min(...values) : Math.max(...values);
  }

  private collectHeightValues(nodes: ShelfNode[], values: number[]) {
    nodes.forEach(node => {
      if (node.name === 'Height' && node.children) {
        node.children.forEach(child => {
          if (child.checked && child.name !== 'Other Height' && child.value) {
            values.push(child.value);
          }
        });
      }
      if (node.children) {
        this.collectHeightValues(node.children, values);
      }
    });
  }

  private getMinMaxValueOfSection(type: 1 | 2): number {
    const sectionTree = this.sectionTree;
    let parentNode: ShelfNode | null = null;

    // Find the correct parent node based on activeSectionMinMax
    if (this.activeSectionMinMax === 11160) {
      parentNode = this.findNodeById(sectionTree, 10210); // Section Width under Presence of Section
    } else if (this.activeSectionMinMax === 15490) {
      parentNode = this.findNodeById(sectionTree, 15000); // Coffin Section Width
    } else if (this.activeSectionMinMax === 15995) {
      parentNode = this.findNodeById(sectionTree, 15500); // Upright Section Width
    } else if (this.activeSectionMinMax === 14825) {
      parentNode = this.findNodeById(sectionTree, 14000); // Shelf Section Width
    } else if (this.activeSectionMinMax === 16910) {
      parentNode = this.findNodeById(sectionTree, 16500); // Section Depth
    }

    if (!parentNode || !parentNode.children) return -1;

    const values: number[] = [];
    parentNode.children.forEach(child => {
      if (child.checked && 
          child.name !== 'Other Section Width' && 
          child.name !== 'Other Section Depth' && 
          child.value) {
        values.push(child.value);
      }
    });

    if (values.length === 0) return -1;
    
    return type === 1 ? Math.min(...values) : Math.max(...values);
  }

  private updateNodeValue(node: ShelfNode, field: string, value: string) {
    switch (field) {
      case 'min':
        node.taskMin = value;
        break;
      case 'max':
        node.taskMax = value;
        break;
      case 'soft':
        node.task_soft_check = value;
        break;
      case 'hard':
        node.task_hard_check = value;
        break;
    }
  }

  private resetLimitValue(field: string) {
    if (!this.activeNode) return;

    switch (field) {
      case 'min':
        this.limitsForm.min = (this.activeNode.taskMin || this.activeNode.mainMin || '').toString();
        break;
      case 'max':
        this.limitsForm.max = (this.activeNode.taskMax || this.activeNode.mainMax || '').toString();
        break;
      case 'soft':
        this.limitsForm.soft = (this.activeNode.task_soft_check || this.activeNode.main_soft_check || '').toString();
        break;
      case 'hard':
        this.limitsForm.hard = (this.activeNode.task_hard_check || this.activeNode.main_hard_check || '').toString();
        break;
    }
  }

  private updateTreeData() {
    // Update the appropriate tree based on current tab
    switch (this.activeTab) {
      case 'location':
        this.shelfTaskService.updateLocationTree([...this.locationTree]);
        break;
      case 'section':
        this.shelfTaskService.updateSectionTree([...this.sectionTree]);
        break;
      case 'shelf':
        this.shelfTaskService.updateShelfTree([...this.shelfTree]);
        break;
      case 'upc':
        this.shelfTaskService.updateUpcTree([...this.upcTree]);
        break;
    }
  }

  // Tree utility methods
  onAllowDrag = (node: ShelfNode): boolean => {
    // Implement drag restrictions based on parent nodes
    if (!node.children || node.children.length === 0) return false;
    
    const parent = this.findParentNode(node);
    if (!parent) return false;

    const allowedParents = ['Display Location', 'Department', 'Stocking Location', 'Shelf Type'];
    return allowedParents.includes(parent.name);
  }

  onAllowDrop = (dragNode: ShelfNode, dropNode: ShelfNode): boolean => {
    const dragParent = this.findParentNode(dragNode);
    const dropParent = this.findParentNode(dropNode);
    
    return dragParent?.name === dropParent?.name;
  }

  private findParentNode(node: ShelfNode): ShelfNode | null {
    // Implementation to find parent node
    // This would need to traverse the tree to find the parent
    return null; // Simplified for brevity
  }

  selectAllChildren(node: ShelfNode) {
    if (!node.children) return;

    node.checked = true;
    node.children.forEach(child => {
      child.checked = true;
    });

    this.updateTreeData();
  }

  // Save functionality
  saveShelfData() {
    if (!this.validateShelfData()) return;

    const taskShelfVarObj: TaskShelfVar[] = [];
    
    // Populate from all trees
    this.populateShelfVarObject(taskShelfVarObj, this.locationTree);
    this.populateShelfVarObject(taskShelfVarObj, this.sectionTree);
    this.populateShelfVarObject(taskShelfVarObj, this.shelfTree);
    this.populateShelfVarObject(taskShelfVarObj, this.upcTree);

    const shelfVarData = JSON.stringify(taskShelfVarObj);

    this.shelfTaskService.saveShelfVarDetails(shelfVarData).subscribe({
      next: (result) => {
        console.log('Shelf data saved successfully', result);
        this.saveReviewCategoryDetails();
      },
      error: (error) => {
        console.error('Error saving shelf data', error);
        alert('Error occurred while saving shelf data.');
      }
    });
  }

  private validateShelfData(): boolean {
    // Check that at least one location is selected
    const checkedLocationCount = this.countCheckedNodes(this.locationTree);
    
    if (checkedLocationCount === 0) {
      alert('Please select at least one Location!');
      return false;
    }

    return true;
  }

  private countCheckedNodes(nodes: ShelfNode[]): number {
    let count = 0;
    nodes.forEach(node => {
      if (node.checked) count++;
      if (node.children) {
        count += this.countCheckedNodes(node.children);
      }
    });
    return count;
  }

  private populateShelfVarObject(taskShelfVarObj: TaskShelfVar[], nodes: ShelfNode[]) {
    nodes.forEach(node => {
      if (node.checked) {
        const shelfVar: TaskShelfVar = {
          task_number: 8946, // This should come from service
          prompt_level: 0,
          ShelfVarID: node.id,
          min: node.taskMin,
          max: node.taskMax,
          soft_check: node.task_soft_check,
          hard_check: node.task_hard_check,
          ordinal: node.mainOrdinal,
          name: node.name
        };
        taskShelfVarObj.push(shelfVar);
      }

      if (node.children) {
        this.populateShelfVarObject(taskShelfVarObj, node.children);
      }
    });
  }

  private saveReviewCategoryDetails() {
    const reviewCats = JSON.stringify(this.selectedReviewCategories);
    
    this.shelfTaskService.saveReviewCategoryDetails(reviewCats).subscribe({
      next: (result) => {
        console.log('Review categories saved successfully', result);
        alert('Shelf data saved successfully!');
      },
      error: (error) => {
        console.error('Error saving review categories', error);
        alert('Error occurred while saving collection categories data for shelf.');
      }
    });
  }

  // Review category methods
  onReviewCategoryChange(category: ReviewCategory, field: string, value: any) {
    // Update the category
    const index = this.selectedReviewCategories.findIndex(c => 
      c.ReviewCategoryNumber === category.ReviewCategoryNumber);
    
    if (index !== -1) {
      (this.selectedReviewCategories[index] as any)[field] = value;
    } else if (value) {
      // Add new category if it doesn't exist and value is set
      this.selectedReviewCategories.push({
        ...category,
        [field]: value
      });
    }

    this.shelfTaskService.updateSelectedReviewCategories([...this.selectedReviewCategories]);
  }

  // Number-only input handler
  onNumberInput(event: KeyboardEvent): boolean {
    const charCode = event.which ? event.which : event.keyCode;
    if (charCode > 31 && (charCode < 48 || charCode > 57)) {
      return false;
    }
    return true;
  }
}
Main Template (shelf-task.component.html)
<div class="shelf-task-container">
  <!-- Tab Navigation -->
  <mat-tab-group [(selectedIndex)]="activeTabIndex" (selectedTabChange)="onTabChange($event.tab.textLabel.toLowerCase())">
    <mat-tab label="Location">
      <app-shelf-tree 
        [nodes]="locationTree"
        [disabled]="isTaskLocked"
        (nodeSelect)="onNodeSelect($event)"
        (nodeCheck)="onNodeCheck($event)"
        (selectAllChildren)="selectAllChildren($event)">
      </app-shelf-tree>
    </mat-tab>
    
    <mat-tab label="Section">
      <app-shelf-tree 
        [nodes]="sectionTree"
        [disabled]="isTaskLocked"
        (nodeSelect)="onNodeSelect($event)"
        (nodeCheck)="onNodeCheck($event)"
        (selectAllChildren)="selectAllChildren($event)">
      </app-shelf-tree>
    </mat-tab>
    
    <mat-tab label="Shelf">
      <app-shelf-tree 
        [nodes]="shelfTree"
        [disabled]="isTaskLocked"
        (nodeSelect)="onNodeSelect($event)"
        (nodeCheck)="onNodeCheck($event)"
        (selectAllChildren)="selectAllChildren($event)">
      </app-shelf-tree>
    </mat-tab>
    
    <mat-tab label="UPC">
      <app-shelf-tree 
        [nodes]="upcTree"
        [disabled]="isTaskLocked"
        (nodeSelect)="onNodeSelect($event)"
        (nodeCheck)="onNodeCheck($event)"
        (selectAllChildren)="selectAllChildren($event)">
      </app-shelf-tree>
    </mat-tab>
  </mat-tab-group>

  <!-- Limits and Checks Panel -->
  <div class="panels-container" *ngIf="showLimitsPanel || showChecksPanel">
    <mat-card class="limits-checks-card">
      <mat-card-header>
        <mat-card-title>Checks / Limits</mat-card-title>
      </mat-card-header>
      
      <mat-card-content>
        <!-- Limits Section -->
        <div class="limits-section" *ngIf="showLimitsPanel">
          <h3>Limits</h3>
          <mat-form-field appearance="fill">
            <mat-label>Min</mat-label>
            <input matInput 
                   type="number" 
                   [(ngModel)]="limitsForm.min"
                   (change)="onLimitChange('min', $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   [disabled]="isTaskLocked"
                   maxlength="3">
          </mat-form-field>

          <mat-form-field appearance="fill">
            <mat-label>Max</mat-label>
            <input matInput 
                   type="number" 
                   [(ngModel)]="limitsForm.max"
                   (change)="onLimitChange('max', $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   [disabled]="isTaskLocked"
                   maxlength="3">
          </mat-form-field>
        </div>

        <!-- Checks Section -->
        <div class="checks-section" *ngIf="showChecksPanel">
          <h3>Checks</h3>
          <mat-form-field appearance="fill">
            <mat-label>Soft</mat-label>
            <input matInput 
                   type="number" 
                   [(ngModel)]="limitsForm.soft"
                   (change)="onLimitChange('soft', $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   [disabled]="isTaskLocked"
                   maxlength="3">
          </mat-form-field>

          <mat-form-field appearance="fill">
            <mat-label>Hard</mat-label>
            <input matInput 
                   type="number" 
                   [(ngModel)]="limitsForm.hard"
                   (change)="onLimitChange('hard', $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   [disabled]="isTaskLocked"
                   maxlength="3">
          </mat-form-field>
        </div>
      </mat-card-content>
    </mat-card>
  </div>

  <!-- Review Categories Section -->
  <div class="review-categories-section">
    <app-review-category-grid
      [categories]="reviewCategories"
      [selectedCategories]="selectedReviewCategories"
      [disabled]="isTaskLocked"
      (categoryChange)="onReviewCategoryChange($event.category, $event.field, $event.value)">
    </app-review-category-grid>
  </div>

  <!-- Save Button -->
  <div class="actions-section">
    <button mat-raised-button 
            color="primary" 
            (click)="saveShelfData()"
            [disabled]="isTaskLocked">
      Save Shelf
    </button>
  </div>
</div>

Shelf Tree Component (components/shelf-tree.component.ts)

import { Component, Input, Output, EventEmitter, OnChanges, SimpleChanges } from '@angular/core';
import { TreeNode, ITreeOptions } from '@ali-hm/angular-tree-component';
import { ShelfNode } from '../models/shelf-task.models';

@Component({
  selector: 'app-shelf-tree',
  templateUrl: './shelf-tree.component.html',
  styleUrls: ['./shelf-tree.component.scss']
})
export class ShelfTreeComponent implements OnChanges {
  @Input() nodes: ShelfNode[] = [];
  @Input() disabled: boolean = false;
  @Output() nodeSelect = new EventEmitter<ShelfNode>();
  @Output() nodeCheck = new EventEmitter<ShelfNode>();
  @Output() selectAllChildren = new EventEmitter<ShelfNode>();

  treeOptions: ITreeOptions = {
    useCheckbox: true,
    useTriState: true,
    displayField: 'name',
    childrenField: 'children',
    hasChildrenField: 'isParent',
    allowDrag: true,
    allowDrop: true
  };

  ngOnChanges(changes: SimpleChanges) {
    if (changes['disabled']) {
      this.updateNodeDisabledState();
    }
  }

  private updateNodeDisabledState() {
    this.updateNodesRecursive(this.nodes);
  }

  private updateNodesRecursive(nodes: ShelfNode[]) {
    nodes.forEach(node => {
      node.disabled = this.disabled || node.optional !== 'Y';
      if (node.children) {
        this.updateNodesRecursive(node.children);
      }
    });
  }

  onNodeActivate(event: any) {
    const node: ShelfNode = event.node.data;
    this.nodeSelect.emit(node);
  }

  onNodeToggle(event: any) {
    const node: ShelfNode = event.node.data;
    if (!node.disabled) {
      this.nodeCheck.emit(node);
    }
  }

  onSelectAllChildren(node: ShelfNode) {
    if (!this.disabled) {
      this.selectAllChildren.emit(node);
    }
  }

  canDrag = (node: TreeNode): boolean => {
    return !this.disabled && this.hasValidDragParent(node.data);
  }

  canDrop = (dragNode: TreeNode, dropNode: TreeNode): boolean => {
    return !this.disabled && this.hasValidDropTarget(dragNode.data, dropNode.data);
  }

  private hasValidDragParent(node: ShelfNode): boolean {
    // Implement drag validation logic
    const allowedParents = ['Display Location', 'Department', 'Stocking Location', 'Shelf Type'];
    // This would need parent finding logic
    return true; // Simplified
  }

  private hasValidDropTarget(dragNode: ShelfNode, dropNode: ShelfNode): boolean {
    // Implement drop validation logic
    return true; // Simplified
  }

  isOtherSectionWidth(node: ShelfNode): boolean {
    return node.name === 'Other Section Width' && node.var_type_id === 2;
  }

  isOtherHeight(node: ShelfNode): boolean {
    return node.name === 'Other Height' && node.var_type_id === 2;
  }

  onCustomInputChange(node: ShelfNode, field: string, value: string) {
    (node as any)[field] = value;
    this.nodeCheck.emit(node);
  }
}

Shelf Tree Template (shelf-tree.component.html)

<div class="tree-container">
  <tree-root 
    [nodes]="nodes" 
    [options]="treeOptions"
    (activate)="onNodeActivate($event)"
    (toggleExpanded)="onNodeToggle($event)">
    
    <ng-template #treeNodeTemplate let-node let-index="index">
      <div class="tree-node-content">
        <!-- Checkbox -->
        <input type="checkbox" 
               [checked]="node.data.checked"
               [disabled]="node.data.disabled || disabled"
               (change)="onNodeToggle($event)"
               class="node-checkbox">

        <!-- Node Name -->
        <span class="node-name" 
              [class.disabled]="node.data.disabled || disabled"
              (click)="onNodeActivate($event)">
          {{ node.data.name }}
        </span>

        <!-- Select All Children Button -->
        <button *ngIf="node.data.isParent && !disabled" 
                mat-button 
                class="select-all-btn"
                (click)="onSelectAllChildren(node.data)">
          <b>(Select all Child variables)</b>
        </button>

        <!-- Custom Input for Other Section Width -->
        <div *ngIf="isOtherSectionWidth(node.data) && node.data.checked" 
             class="custom-input-container">
          <mat-form-field appearance="fill" class="custom-input">
            <mat-label>Min</mat-label>
            <input matInput 
                   type="number"
                   [value]="node.data.taskMin"
                   (change)="onCustomInputChange(node.data, 'taskMin', $event.target.value)"
                   [disabled]="disabled"
                   [attr.min]="node.data.mainMin"
                   [attr.max]="node.data.mainMax">
          </mat-form-field>
          
          <mat-form-field appearance="fill" class="custom-input">
            <mat-label>Max</mat-label>
            <input matInput 
                   type="number"
                   [value]="node.data.taskMax"
                   (change)="onCustomInputChange(node.data, 'taskMax', $event.target.value)"
                   [disabled]="disabled"
                   [attr.min]="node.data.mainMin"
                   [attr.max]="node.data.mainMax">
          </mat-form-field>
        </div>

        <!-- Custom Input for Other Height -->
        <div *ngIf="isOtherHeight(node.data) && node.data.checked" 
             class="custom-input-container">
          <mat-form-field appearance="fill" class="custom-input">
            <mat-label>Min</mat-label>
            <input matInput 
                   type="number"
                   [value]="node.data.taskMin"
                   (change)="onCustomInputChange(node.data, 'taskMin', $event.target.value)"
                   [disabled]="disabled"
                   [attr.min]="node.data.mainMin"
                   [attr.max]="node.data.mainMax">
          </mat-form-field>
          
          <mat-form-field appearance="fill" class="custom-input">
            <mat-label>Max</mat-label>
            <input matInput 
                   type="number"
                   [value]="node.data.taskMax"
                   (change)="onCustomInputChange(node.data, 'taskMax', $event.target.value)"
                   [disabled]="disabled"
                   [attr.min]="node.data.mainMin"
                   [attr.max]="node.data.mainMax">
          </mat-form-field>
        </div>
      </div>
    </ng-template>
  </tree-root>
</div>

Review Category Grid Component (components/review-category-grid.component.ts)

import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';
import { ReviewCategory } from '../models/shelf-task.models';

@Component({
  selector: 'app-review-category-grid',
  templateUrl: './review-category-grid.component.html',
  styleUrls: ['./review-category-grid.component.scss']
})
export class ReviewCategoryGridComponent implements OnInit {
  @Input() categories: ReviewCategory[] = [];
  @Input() selectedCategories: ReviewCategory[] = [];
  @Input() disabled: boolean = false;
  @Output() categoryChange = new EventEmitter<{category: ReviewCategory, field: string, value: any}>();

  displayedColumns: string[] = [
    'ReviewCategoryName', 
    'KeycatNumber', 
    'KeycatName', 
    'Selected', 
    'QCUnderReq', 
    'QCUnderPercent', 
    'NumberOfWeeks'
  ];

  selectedDisplayedColumns: string[] = [
    'CategoryName',
    'CatgDetail', 
    'CategoryID', 
    'QCUnderReq', 
    'QCUnderPercent', 
    'NumberOfWeeks'
  ];

  reviewCategories: ReviewCategory[] = [];
  keycats: { [key: number]: ReviewCategory[] } = {};

  ngOnInit() {
    this.processCategories();
  }

  ngOnChanges() {
    this.processCategories();
  }

  private processCategories() {
    this.reviewCategories = this.categories.filter(cat => 
      !cat.KeycatNumber || cat.KeycatNumber === 0
    );

    this.keycats = {};
    this.categories.forEach(cat => {
      if (cat.KeycatNumber && cat.KeycatNumber > 0) {
        if (!this.keycats[cat.ReviewCategoryNumber]) {
          this.keycats[cat.ReviewCategoryNumber] = [];
        }
        this.keycats[cat.ReviewCategoryNumber].push(cat);
      }
    });
  }

  onCategorySelected(category: ReviewCategory, selected: boolean) {
    if (this.disabled) return;

    if (selected) {
      // Check if any keycats are already selected
      const hasSelectedKeycats = this.hasSelectedKeycats(category.ReviewCategoryNumber);
      if (hasSelectedKeycats) {
        alert("You can't select a Category when a KeyCat from it is selected");
        return;
      }
    }

    this.categoryChange.emit({
      category: category,
      field: 'Selected',
      value: selected ? 1 : null
    });
  }

  onQCUnderChanged(category: ReviewCategory, qcUnder: boolean) {
    if (this.disabled) return;

    if (qcUnder) {
      // Check if any keycats are already selected
      const hasSelectedKeycats = this.hasSelectedKeycats(category.ReviewCategoryNumber);
      if (hasSelectedKeycats) {
        alert("You can't select a Category when a KeyCat from it is selected");
        return;
      }

      // Auto-select the category and set default weeks
      this.categoryChange.emit({
        category: category,
        field: 'Selected',
        value: 1
      });

      this.categoryChange.emit({
        category: category,
        field: 'NumberOfWeeks',
        value: 5
      });
    } else {
      this.categoryChange.emit({
        category: category,
        field: 'NumberOfWeeks',
        value: null
      });

      this.categoryChange.emit({
        category: category,
        field: 'QCUnderPercent',
        value: null
      });
    }

    this.categoryChange.emit({
      category: category,
      field: 'QCUnderReq',
      value: qcUnder ? 1 : null
    });
  }

  onPercentChanged(category: ReviewCategory, percent: number) {
    if (this.disabled) return;

    this.categoryChange.emit({
      category: category,
      field: 'QCUnderPercent',
      value: percent || null
    });
  }

  onWeeksChanged(category: ReviewCategory, weeks: number) {
    if (this.disabled) return;

    this.categoryChange.emit({
      category: category,
      field: 'NumberOfWeeks',
      value: weeks || null
    });
  }

  onKeycatSelected(keycat: ReviewCategory, selected: boolean) {
    if (this.disabled) return;

    if (selected) {
      // Check if parent category is selected
      const hasSelectedParent = this.hasSelectedParentCategory(keycat.ReviewCategoryNumber);
      if (hasSelectedParent) {
        alert("You can't select a KeyCat when its Category is selected");
        return;
      }
    }

    this.categoryChange.emit({
      category: keycat,
      field: 'Selected',
      value: selected ? 1 : null
    });
  }

  onKeycatQCUnderChanged(keycat: ReviewCategory, qcUnder: boolean) {
    if (this.disabled) return;

    if (qcUnder) {
      // Check if parent category is selected
      const hasSelectedParent = this.hasSelectedParentCategory(keycat.ReviewCategoryNumber);
      if (hasSelectedParent) {
        alert("You can't select a KeyCat when its Category is selected");
        return;
      }

      // Auto-select the keycat and set default weeks
      this.categoryChange.emit({
        category: keycat,
        field: 'Selected',
        value: 1
      });

      this.categoryChange.emit({
        category: keycat,
        field: 'NumberOfWeeks',
        value: 5
      });
    } else {
      this.categoryChange.emit({
        category: keycat,
        field: 'NumberOfWeeks',
        value: null
      });

      this.categoryChange.emit({
        category: keycat,
        field: 'QCUnderPercent',
        value: null
      });
    }

    this.categoryChange.emit({
      category: keycat,
      field: 'QCUnderReq',
      value: qcUnder ? 1 : null
    });
  }

  private hasSelectedKeycats(reviewCategoryNumber: number): boolean {
    return this.selectedCategories.some(cat => 
      cat.ReviewCategoryNumber === reviewCategoryNumber && 
      cat.KeycatNumber && 
      cat.KeycatNumber > 0
    );
  }

  private hasSelectedParentCategory(reviewCategoryNumber: number): boolean {
    return this.selectedCategories.some(cat => 
      cat.ReviewCategoryNumber === reviewCategoryNumber && 
      cat.Catg_Type === 'R'
    );
  }

  isSelected(category: ReviewCategory): boolean {
    return this.selectedCategories.some(selected => 
      selected.ReviewCategoryNumber === category.ReviewCategoryNumber &&
      selected.KeycatNumber === category.KeycatNumber &&
      selected.Selected === 1
    );
  }

  isQCUnderSelected(category: ReviewCategory): boolean {
    return this.selectedCategories.some(selected => 
      selected.ReviewCategoryNumber === category.ReviewCategoryNumber &&
      selected.KeycatNumber === category.KeycatNumber &&
      selected.QCUnderReq === 1
    );
  }

  getPercent(category: ReviewCategory): number | null {
    const selected = this.selectedCategories.find(s => 
      s.ReviewCategoryNumber === category.ReviewCategoryNumber &&
      s.KeycatNumber === category.KeycatNumber
    );
    return selected?.QCUnderPercent || null;
  }

  getWeeks(category: ReviewCategory): number | null {
    const selected = this.selectedCategories.find(s => 
      s.ReviewCategoryNumber === category.ReviewCategoryNumber &&
      s.KeycatNumber === category.KeycatNumber
    );
    return selected?.NumberOfWeeks || null;
  }

  isPercentDisabled(category: ReviewCategory): boolean {
    return this.disabled || !this.isQCUnderSelected(category);
  }

  isWeeksDisabled(category: ReviewCategory): boolean {
    return this.disabled || !this.isQCUnderSelected(category);
  }

  // Number input validation
  onNumberInput(event: KeyboardEvent): boolean {
    const charCode = event.which ? event.which : event.keyCode;
    if (charCode > 31 && (charCode < 48 || charCode > 57)) {
      return false;
    }
    return true;
  }
}
Review Category Grid Template
<div class="review-categories-container">
  <mat-card>
    <mat-card-header>
      <mat-card-title>Categories / Keycats</mat-card-title>
    </mat-card-header>
    
    <mat-card-content>
      <table mat-table [dataSource]="reviewCategories" class="categories-table">
        <ng-container matColumnDef="ReviewCategoryName">
          <th mat-header-cell *matHeaderCellDef>Review Category</th>
          <td mat-cell *matCellDef="let category">
            <strong>{{ category.ReviewCategoryName }}</strong>
          </td>
        </ng-container>

        <ng-container matColumnDef="Selected">
          <th mat-header-cell *matHeaderCellDef>Selected</th>
          <td mat-cell *matCellDef="let category">
            <mat-checkbox 
              [checked]="isSelected(category)"
              [disabled]="disabled"
              (change)="onCategorySelected(category, $event.checked)">
            </mat-checkbox>
          </td>
        </ng-container>

        <ng-container matColumnDef="QCUnderReq">
          <th mat-header-cell *matHeaderCellDef>QC Under</th>
          <td mat-cell *matCellDef="let category">
            <mat-checkbox 
              [checked]="isQCUnderSelected(category)"
              [disabled]="disabled"
              (change)="onQCUnderChanged(category, $event.checked)">
            </mat-checkbox>
          </td>
        </ng-container>

        <ng-container matColumnDef="QCUnderPercent">
          <th mat-header-cell *matHeaderCellDef>Pass/Fail%</th>
          <td mat-cell *matCellDef="let category">
            <input type="number" 
                   [value]="getPercent(category)"
                   [disabled]="isPercentDisabled(category)"
                   (change)="onPercentChanged(category, $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   class="percent-input"
                   maxlength="2">
          </td>
        </ng-container>

        <ng-container matColumnDef="NumberOfWeeks">
          <th mat-header-cell *matHeaderCellDef>Weeks</th>
          <td mat-cell *matCellDef="let category">
            <input type="number" 
                   [value]="getWeeks(category)"
                   [disabled]="isWeeksDisabled(category)"
                   (change)="onWeeksChanged(category, $event.target.value)"
                   (keypress)="onNumberInput($event)"
                   class="weeks-input"
                   maxlength="2">
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: displayedColumns;" 
            [class.expandable-row]="keycats[row.ReviewCategoryNumber]?.length > 0"
            (click)="row.expanded = !row.expanded">
        </tr>

        <!-- Expanded Keycats -->
        <tr mat-row *matRowDef="let row; columns: ['expandedDetail']; when: isExpansionDetailRow"
            class="expanded-row" [@detailExpand]="row.expanded ? 'expanded' : 'collapsed'">
          <td mat-cell [attr.colspan]="displayedColumns.length">
            <div class="keycats-container" *ngIf="keycats[row.ReviewCategoryNumber]">
              <table mat-table [dataSource]="keycats[row.ReviewCategoryNumber]" class="keycats-table">
                <!-- Keycat columns similar to above but for keycats -->
                <ng-container matColumnDef="KeycatName">
                  <th mat-header-cell *matHeaderCellDef>Keycat Name</th>
                  <td mat-cell *matCellDef="let keycat">{{ keycat.KeycatName }}</td>
                </ng-container>

                <ng-container matColumnDef="KeycatSelected">
                  <th mat-header-cell *matHeaderCellDef>Selected</th>
                  <td mat-cell *matCellDef="let keycat">
                    <mat-checkbox 
                      [checked]="isSelected(keycat)"
                      [disabled]="disabled"
                      (change)="onKeycatSelected(keycat, $event.checked)">
                    </mat-checkbox>
                  </td>
                </ng-container>

                <!-- Additional keycat columns... -->
                
                <tr mat-header-row *matHeaderRowDef="['KeycatName', 'KeycatSelected', 'QCUnderReq', 'QCUnderPercent', 'NumberOfWeeks']"></tr>
                <tr mat-row *matRowDef="let row; columns: ['KeycatName', 'KeycatSelected', 'QCUnderReq', 'QCUnderPercent', 'NumberOfWeeks'];"></tr>
              </table>
            </div>
          </td>
        </tr>
      </table>
    </mat-card-content>
  </mat-card>

  <!-- Selected Categories Display -->
  <mat-card class="selected-categories">
    <mat-card-header>
      <mat-card-title>Selected Categories</mat-card-title>
    </mat-card-header>
    
    <mat-card-content>
      <table mat-table [dataSource]="selectedCategories" class="selected-table">
        <!-- Selected categories columns -->
        <tr mat-header-row *matHeaderRowDef="selectedDisplayedColumns"></tr>
        <tr mat-row *matRowDef="let row; columns: selectedDisplayedColumns;"></tr>
      </table>
    </mat-card-content>
  </mat-card>
</div>
