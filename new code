common service 
// Centralized API methods
getIriWeeks(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetIriWeek`)
    .pipe(catchError(this.handleError<any[]>('getIriWeeks', [])));
}

getTerritories(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetTerritory`)
    .pipe(catchError(this.handleError<any[]>('getTerritories', [])));
}

searchStores(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetStore`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStores', [])));
}

searchStates(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetState`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStates', [])));
}

searchCities(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCity`, payload)
    .pipe(catchError(this.handleError<any[]>('searchCities', [])));
}

searchClusters(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCluster`, payload)
    .pipe(catchError(this.handleError<any[]>('searchClusters', [])));
}

searchTasks(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetTask`, payload)
    .pipe(catchError(this.handleError<any[]>('searchTasks', [])));
}

getGridData(payload: GetGridDataFilter): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetGridData`, payload)
    .pipe(catchError(this.handleError<any[]>('getGridData', [])));
}

private handleError<T>(operation = 'operation', result?: T) {
  return (error: any): Observable<T> => {
    console.error(`${operation} failed:`, error);
    return of(result as T);
  };
}

 // MISSING FUNCTION 1: Apply Filters
  applyFilters(filters: GetGridDataFilter): void {
     const currentCountry = this.getCurrentCountry();
    
    if (!currentCountry) {
      filters.countryId = '1';
      filters.iriWeek = '2405'
      filters.territoryId='52'
      // throw new Error('Please select a country first');
    }else{
        // Ensure country is set
    filters.countryId = currentCountry;
    }
    
  
    

    this.filtersSubject.next(filters);
      this.currentFiltersSubject.next({
        countryId: filters.countryId,
      iri_week: filters.iriWeek,
      territory_id: filters.territoryId,
      area: filters.area,
      store_number: filters.storeNumber,
      store_name: filters.storeName,
      state: filters.state,
      city: filters.city,
      position_number: filters.positionNumber,
      task_number: filters.taskNumber,
      emp_id: filters.empId,
      fsr_hour: filters.fsrHour,
      fsr_over_25hrs: filters.fsrOver25hrs,
      fsr_over_6hrs: filters.fsrOver6hrs,
      assigned_stores: filters.assignedStores,
      unassigned_stores: filters.unassignedStores,
      sample: filters.sample,
      nonsample: filters.nonSample,
      multi_fsr_store: filters.multiFsrStore,
      vacation: filters.vacation,
      temporary: filters.temporary,
      fsr_hour_operator: "NA"
      })
    // Call GetGridData API with filters
    this.getGridData(filters).subscribe({
      next: (data) => {
        this.gridDataSubject.next(data);
      },
      error: (error) => {
        console.error('Error applying filters:', error);
        this.gridDataSubject.next([]);
      }
    });
  }


  clearFilters(): void {
    const defaultFilters = new GetGridDataFilter();
    this.filtersSubject.next(defaultFilters);
    this.gridDataSubject.next([]);
  }

setCountry(countryId: string): void {
    this.countrySubject.next(countryId);
  }

 
  getCurrentCountry(): string {
    return this.countrySubject.value;
  }

dashbord-layout.component.ts

import { SnackbarService } from './../../shared/snackbar.service';
import { HttpClient } from '@angular/common/http';
import { Component, OnInit, OnDestroy, Inject } from '@angular/core';
import { FormControl } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { firstValueFrom, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { countryModel, GetGridDataFilter, StoreFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';
import * as XLSX from "xlsx";
@Component({
  selector: 'app-dashbord-layout',
  templateUrl: './dashbord-layout.component.html',
  styleUrls: ['./dashbord-layout.component.css']
})
export class DashbordLayoutComponent implements OnInit, OnDestroy {

  private destroy$ = new Subject<void>();
  countrylist: countryModel[] = [];
  employeedata: any[] = [];
  countryctrl = new FormControl();
  isFiltersExpanded = false; // Changed from sidebar to top filters
  currentIRIWeek: any;
  loggeduser: string;
  isGeneratingWorkOrder = false;
  isSendingWorkOrder = false;
  isWoEmailed = true;          
  pdfSessionId: string = '';    
  territoryList: any[] = [];
  constructor(
    private commonService: CommonService,
    private snackbar: SnackbarService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
    private dialog:MatDialog
  ) { 
    this.loggeduser = localStorage.getItem("loggedUserId");
  }

  async ngOnInit(): Promise<void> {
    // Remove sidebar state subscription since we're using top filters
    this.commonService.groupsStatus$.subscribe(userGroups => {    
      if(userGroups['isgTechnologyGroup']) { 
        this.countryctrl.enable();
      } else { 
        this.countryctrl.disable();
      }   
    });

    this.currentIRIWeek = await firstValueFrom(
      this.http.get<any>(this.baseUrl + 'api/TaskAssinment/GetCurrentIRIWeek')
    );   
    
    try {
      this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
       if (this.employeedata.length > 0) {
        const defaultCountryId = '1';
        this.countryctrl.setValue(defaultCountryId);
        this.commonService.setCountry(defaultCountryId);
      }
    } catch(error) {
      console.error('Error fetching employee data:', error);
    }

    try {
      this.countrylist = await this.commonService.getcountry();
    } catch {
      console.error('Error fetching country data');
    }      
    
    this.employeedata.filter((x) => {
      this.countryctrl.setValue(x.countryId,{emitEvent:false});
      this.commonService.setCountry(x.countryId);
    });
    this.countryctrl.valueChanges
          .pipe(takeUntil(this.destroy$))
          .subscribe(countryId => {
            if (countryId) {
              this.commonService.setCountry(countryId);
            }
          });

  await this.loadTerritoryList();
    // Initialize default filters
    this.initializeDefaultFilters();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // Changed from toggleSidebar to toggleFilters
  toggleFilters(): void {
    this.isFiltersExpanded = !this.isFiltersExpanded;
  }

  onFiltersChanged(filters: any): void {
    this.commonService.applyFilters(filters);
  }

  onClearFilters(): void {
     this.commonService.clearFilters();
  }

  selectedcountry(event: any) {
    if (event.isUserInput && event.source.value) {
      this.commonService.setCountry(event.source.value);
    }
  }

  private initializeDefaultFilters(): void {
    const defaultFilters = new GetGridDataFilter();
    // Set default values based on employee data
    if (this.employeedata.length > 0) {
      defaultFilters.countryId = this.employeedata['countryId'] || '1';
      defaultFilters.territoryId = this.employeedata['fieldTerritoryNumber']?.toString() || '52';
    }
    
    // this.commonService.initializeDefaultFilters(defaultFilters);
  }

  ExportFetaDetailsToCSV(){
    const payLoad:GetGridDataFilter ={
      countryId: "1",
      countryName: '',
      lanId: this.loggeduser,
      iriWeek: '2404',
      iriWeekViewOnly: '',
      area: '23',
      territoryId: '52',
      territoryName: '',
      fromDate: '',
      toDate: '',
      storeNumber: '',
      storeName: '',
      state: '',
      city: '',
      taskNumber: '',
      taskName: '',
      positionNumber: '',
      positionName: '',
      empId: '',
      firstName: '',
      lastName: '',
      empName: '',
      fsrOver25hrs: 'false',
      fsrOver6hrs: 'false',
      fsrHour: '',
      fsrHourOperator: 'NA',
      assignedStores: 'false',
      unassignedStores: 'false',
      sample: 'false',
      nonSample: 'false',
      multiFsrStore: 'false',
      vacation: 'false',
      action: '',
      comment: '',
      fmEmail: '',
      fmEmpId: '',
      assignmentMode: '',
      temporary: 'false'
    }

    
    this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/ExportFetaDetailsToCSV',payLoad).pipe(takeUntil(this.destroy$)).subscribe( { 
          next: 
          (response) => {  
            if(!response){
              this.snackbar.openSnackBar("No Data Found","error")
            }
            

              const now = new Date();

              const year = now.getFullYear();
              const month = String(now.getMonth() + 1).padStart(2, '0');
              const day = String(now.getDate()).padStart(2, '0');

              let hours = now.getHours();
              const minutes = String(now.getMinutes()).padStart(2, '0');
              const seconds = String(now.getSeconds()).padStart(2, '0');
              hours = hours % 12 || 12;
              const formattedHours = String(hours).padStart(2, '0');

              const formattedDateTime = `${year}-${month}-${day}_${formattedHours}_${minutes}_${seconds}`;


            const columnNames = response.map(item => ({
              ['Store Number']:item.StoreNumber,
              ['Store Name']:item.StoreName,
              ['Store Address']:item.AddrLine1,
              ['Store City']:item.City,
              ['Store State']:item.State,
              ['Store Zip']:item.Zip,
              ['Task Name']:item.TaskName,
              ['Assigned To']:item.AssignedTo,
              ['Csr Info']:item.CsrInfo,
                Wave:item.Wave,
              ['Expected Collection Time']:item.ExpectedCollectionTime,
          }))

          const worksheet = XLSX.utils.json_to_sheet(columnNames);

          const headerRow = Object.keys(columnNames[0]); for (let colIndex = 0; colIndex < headerRow.length; colIndex++) {
              const cellAddress = XLSX.utils.encode_cell({ r: 0, c: colIndex });
              if (!worksheet[cellAddress]) continue;
              worksheet[cellAddress].s = {
                  font: { bold: true }
              };
          }

          const colWidths = headerRow.map(header => {
              const maxLength = Math.max(header.length, ...columnNames.map(row => (row[header] ? row[header].toString().length : 0)));
              return { wch: maxLength + 2 };
          });
          worksheet['!cols'] = colWidths;

          const workbook = XLSX.utils.book_new()
          XLSX.utils.book_append_sheet(workbook, worksheet, `Task_Assignment_Details`)
          XLSX.writeFile(workbook, `Task_Assignment_Details_${formattedDateTime}.xlsx`)
            },
            error: 
            (error) => { console.error(error); },
            });   

  }

   private async loadTerritoryList(): Promise<void> {
    try {
      this.territoryList = await firstValueFrom(
        this.http.get<any[]>(
          this.baseUrl + 'api/TaskAssinment/GetTerritory'
        )
      );
    } catch (error) {
      console.error('Error loading territory list:', error);
      this.snackbar.openSnackBar('Error loading territory information','error');
    }
  }

dashbord-layout.component.html
<div class="dashboard-layout">
  <!-- Toolbar -->
  <mat-toolbar class="mat-toolbar-primary">
    <button mat-icon-button (click)="toggleFilters()" aria-label="Toggle filters">
      <mat-icon>filter_list</mat-icon>
    </button>
    <h1 class="toolbar-title">Assignments Dashboard</h1>
    <span class="toolbar-spacer"></span>
    
    <!-- Country Selector -->
    <div class="country-field">
      <mat-form-field appearance="standard">
        <mat-select [formControl]="countryctrl" placeholder="Select country">
          <mat-option *ngFor="let country of countrylist" 
                      [value]="country.countryID" 
                      (onSelectionChange)="selectedcountry($event)">
            {{country.countryName}}
          </mat-option>
        </mat-select>
      </mat-form-field>        
    </div>
    
    <button mat-icon-button aria-label="Edit" matTooltip="Generate Work Order" 
          > 
      <mat-icon>edit_square</mat-icon>
    </button>
    <button mat-icon-button aria-label="Send" matTooltip="Email Work Order" 
        >
      <mat-icon>send</mat-icon>
    </button>
    <button mat-icon-button aria-label="Download" matTooltip="Export Grid Data" (click)=" ExportFetaDetailsToCSV();$event.stopPropagation()">
      <mat-icon>download</mat-icon>
    </button>
  </mat-toolbar>

  <!-- TOP HORIZONTAL FILTER BAR -->
  <section class="filter-top-bar" [class.expanded]="isFiltersExpanded">
    <app-filter-sidebar 
      (filtersChanged)="onFiltersChanged($event)"
      (clearFilters)="onClearFilters()">
    </app-filter-sidebar>
  </section>

  <!-- Main Content -->
  <div class="main-content">
    <div class="content-wrapper">
      <app-store-table></app-store-table>
    </div>
  </div>
</div>

filter-sidebar.component.ts

import { HttpClient } from '@angular/common/http';
import { Component, ElementRef, EventEmitter, Inject, OnDestroy, OnInit, Output, ViewChild } from '@angular/core';
import { FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { catchError, debounceTime, distinctUntilChanged, firstValueFrom, map, Observable, of, startWith, Subject, switchMap, takeUntil, tap } from 'rxjs';
import { StoreFilter, FilterOptions, GetGridDataFilter } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-filter-sidebar',
  templateUrl: './filter-sidebar.component.html',
  styleUrls: ['./filter-sidebar.component.css']
})
export class FilterSidebarComponent implements OnInit, OnDestroy {
  @Output() filtersChanged = new EventEmitter<GetGridDataFilter>();
  @Output() clearFilters = new EventEmitter<void>();

  filterForm!: FormGroup;
  showAdvancedFilters = false;
  showSpinner = false;
  
  // Data arrays
  employeedata: any[] = [];
  iriWeeks: any[] = [];
  territories: any[] = [];
  filteredStores: any[] = [];
  filteredState: any[] = [];
  filteredCity: any[] = [];
  filteredCluster: any[] = [];
  filteredTask: any[] = [];
  filteredFSR: any[] = [];

  // Selected values
  selectedStoreNumber = '';
  selectedState = '';
  selectedCity = '';
  selectedCluster = '';
  selectedTask = '';
  selectedFsrId = '';
  areaNBRctrl = new FormControl();
  private unsubscribe$ = new Subject<void>();
  private loggeduser: string;

  constructor(
    private fb: FormBuilder,
    private commonService: CommonService,
    public http: HttpClient,
    @Inject('BASE_URL') public baseUrl: string,
  ) {
    this.initializeForm();
    this.loggeduser = localStorage.getItem("loggedUserId") || '';
  }

  async ngOnInit(): Promise<void> {
    try {
      this.employeedata = await firstValueFrom(this.commonService.getEmployee(this.loggeduser));
      await this.getIriWeek();
      await this.getTerritory();
      this.setupFormSubscriptions();
      // Apply default filters after initialization
      this.applyDefaultFilters();
    } catch (error) {
      console.error('Error initializing filter component:', error);
    }
  }

  private initializeForm(): void {
    this.filterForm = this.fb.group({
      iriWeek: [''],
      territory: [''],
      store: [''],
      state: [''],
      city: [''],
      cluster: [''],
      task: [''],
      fsr: [''],
      fsrHour: [''],
      storeAssignment: ['all'], // assigned, unassigned, all
      sampleType: ['all'], // sample, nonSample, all
      multiFsrStore: [false]
    });
  }

  // FIXED: Get IRI Week with proper subscription pattern
  private getIriWeek(): void {
    this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetIriWeek')
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe({
        next: (response) => {
          this.iriWeeks = response;
          // Set default to second item (index 1) as in your original code
          if (this.iriWeeks.length > 1) {
            this.filterForm.get('iriWeek')?.setValue(this.iriWeeks?.[0]?.['iri_week'], { emitEvent: false });
          }
        },
        error: (error) => { 
          console.error('Error fetching IRI weeks:', error); 
        }
      });
  }

  // FIXED: Get Territory with proper subscription pattern
  private getTerritory(): void {
    this.showSpinner = true;
    this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe({
        next: (response) => {
          this.territories = response;
          // Set default territory based on employee data
          const defaultTerritory = this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'];
          this.filterForm.get('territory')?.setValue(defaultTerritory, { emitEvent: false });
          this.areaNBRctrl.setValue( this.territories?.[0]?.['area'])
          this.showSpinner = false;
        },
        error: (error) => { 
          console.error('Error fetching territories:', error);
          this.showSpinner = false; 
        }
      });
  }

  private setupFormSubscriptions(): void {
    // Store autocomplete
    this.filterForm.get('store')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getStore(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(stores => {
      this.filteredStores = stores || [];
      this.showSpinner = false;
    });

    // State autocomplete
    this.filterForm.get('state')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getState(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(states => {
      this.filteredState = states || [];
      this.showSpinner = false;
    });

    // City autocomplete
    this.filterForm.get('city')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCity(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(cities => {
      this.filteredCity = cities || [];
      this.showSpinner = false;
    });

    // Cluster autocomplete
    this.filterForm.get('cluster')?.valueChanges.pipe(
      debounceTime(300),
      tap(() => (this.showSpinner = true)),
      switchMap(searchText => this.getCluster(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(clusters => {
      this.filteredCluster = clusters || [];
      this.showSpinner = false;
    });

    // Task autocomplete
    this.filterForm.get('task')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getTask(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(tasks => {
      this.filteredTask = tasks || [];
    });

    // FSR autocomplete
    this.filterForm.get('fsr')?.valueChanges.pipe(
      debounceTime(300),
      switchMap(searchText => this.getFsr(searchText)),
      takeUntil(this.unsubscribe$)
    ).subscribe(fsrs => {
      this.filteredFSR = fsrs || [];
    });
  }

 
  getStore(searchText: string) {
    if (!searchText || searchText.length < 3) {
      return of([]);
    }

    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetStore', payload)
      .pipe(catchError(() => of([])));
  }

  getState(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetState', payload)
      .pipe(catchError(() => of([])));
  }

  getCity(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCity', payload)
      .pipe(catchError(() => of([])));
  }

  getCluster(searchText: string) {
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetCluster', payload)
      .pipe(catchError(() => of([])));
  }

  getTask(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetTask', payload)
      .pipe(catchError(() => of([])));
  }

  getFsr(searchText: string) {
    if (!searchText || searchText.length <= 0) { return of([]); }
    
    const payload = {
      IriWeek: Number(this.filterForm.get('iriWeek')?.value),
      TerritoryId: Number(this.filterForm.get('territory')?.value),
      SearchText: searchText
    };
    
    return this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetFsr', payload)
      .pipe(catchError(() => of([])));
  }

  // Event handlers for IRI Week and Territory changes
  onIriWeekChange(): void {
    // Clear dependent fields when IRI week changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  onTerritoryChange(): void {
    // this.areaNBRctrl.setValue(ter.area)
    // Clear dependent fields when territory changes
    this.filterForm.patchValue({
      store: '',
      state: '',
      city: '',
      cluster: '',
      task: '',
      fsr: ''
    });
    this.clearSelectedValues();
  }

  // Selection event handlers
  onStoreSelected(event: any) {
    const selectedStore = this.filteredStores.find(store => store.store_name === event.option.value);
    this.selectedStoreNumber = selectedStore?.store_number || '';
  }

  onStateSelected(event: any) {
    const selectedState = this.filteredState.find(state => state.state === event.option.value);
    this.selectedState = selectedState?.state || '';
  }

  onCitySelected(event: any) {
    const selectedCity = this.filteredCity.find(city => city.city === event.option.value);
    this.selectedCity = selectedCity?.city || '';
  }

  onClusterSelected(event: any) {
    const selectedCluster = this.filteredCluster.find(cluster => cluster.position_name === event.option.value);
    this.selectedCluster = selectedCluster?.position_number || '';
  }

  onTaskSelected(event: any) {
    const selectedTask = this.filteredTask.find(task => task.task_name === event.option.value);
    this.selectedTask = selectedTask?.task_number || '';
  }

  onFsrSelected(event: any) {
    const selectedFsr = this.filteredFSR.find(fsr => fsr.emp_name === event.option.value);
    this.selectedFsrId = selectedFsr?.emp_id || '';
  }

  // Control methods
  toggleAdvancedFilters(): void {
    this.showAdvancedFilters = !this.showAdvancedFilters;
  }


  onApplyFilters(): void {

    const formValue = this.filterForm.value;
    
    const filters = new GetGridDataFilter();
    filters.countryId = "1"
    filters.lanId=this.loggeduser;
    filters.iriWeek = formValue.iriWeek || '';
    filters.territoryId = formValue.territory || '';
    filters.storeNumber = this.selectedStoreNumber;
    filters.storeName = formValue.store || '';
    filters.state = this.selectedState;
    filters.city = this.selectedCity;
    filters.positionNumber = this.selectedCluster;
    filters.taskNumber = this.selectedTask;
    filters.empId = this.selectedFsrId;
    filters.fsrHour = formValue.fsrHour || '';
    filters.area = this.areaNBRctrl.value||'23';
    filters.fsrOver25hrs='false';
    filters.fsrOver6hrs='false';
    filters.fsrHourOperator= 'NA';
    filters.temporary='false'
    // Handle radio button selections
    if (formValue.storeAssignment === 'assigned') {
      filters.assignedStores = 'true';
      filters.unassignedStores = 'false';
    } else if (formValue.storeAssignment === 'unassigned') {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'true';
    } else {
      filters.assignedStores = 'false';
      filters.unassignedStores = 'false';
    }

    if (formValue.sampleType === 'sample') {
      filters.sample = 'true';
      filters.nonSample = 'false';
    } else if (formValue.sampleType === 'nonSample') {
      filters.sample = 'false';
      filters.nonSample = 'true';
    } else {
      filters.sample = 'false';
      filters.nonSample = 'false';
    }

    filters.multiFsrStore = formValue.multiFsrStore ? 'true' : 'false';
    
    this.filtersChanged.emit(filters);
  }

  // MISSING FUNCTION: Clear Filters
  onClearFilters(): void {
    this.filterForm.reset({
      iriWeek: this.iriWeeks.length > 1 ? this.iriWeeks?.[0]?.['iri_week'] : '',
      territory: this.employeedata?.['fieldTerritoryNumber'] == 0 || 
                              !this.employeedata?.['fieldTerritoryNumber']
                              ? this.territories?.[0]?.['territory_id']
                              : this.employeedata?.['territory_id'],
      storeAssignment: 'all',
      sampleType: 'all',
      multiFsrStore: false
    });
    this.clearSelectedValues();
    this.clearFilters.emit();
  }

  // MISSING FUNCTION: Apply Default Filters on Load
  private applyDefaultFilters(): void {
    // Wait a moment for form to be properly initialized
    setTimeout(() => {
      this.onApplyFilters();
    }, 500);
  }

  private clearSelectedValues(): void {
    this.selectedStoreNumber = '';
    this.selectedState = '';
    this.selectedCity = '';
    this.selectedCluster = '';
    this.selectedTask = '';
    this.selectedFsrId = '';
  }

  // Clear individual controls
  clearStrCtrl() { 
    this.filterForm.get('store')?.reset(); 
    this.selectedStoreNumber = '';
  }
  clearStaCtrl() { 
    this.filterForm.get('state')?.reset(); 
    this.selectedState = '';
  }
  clearcityCtrl() { 
    this.filterForm.get('city')?.reset(); 
    this.selectedCity = '';
  }
  clearTaskCtrl() { 
    this.filterForm.get('task')?.reset(); 
    this.selectedTask = '';
  }
  clearFsrCtrl() { 
    this.filterForm.get('fsr')?.reset(); 
    this.selectedFsrId = '';
  }

  ngOnDestroy(): void {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}


filter-sidebar.component.html

<div class="filter-topbar">
  <div class="filter-container">
    <form [formGroup]="filterForm" class="filter-form">
      
      <!-- Row 1: Main Filters -->
      <div class="filter-row main-filters">
        <!-- IRI Week -->
        <div class="filter-field">
          <label class="form-label">IRI Week</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="iriWeek" (selectionChange)="onIriWeekChange()">
              <mat-option *ngFor="let week of iriWeeks" [value]="week.iri_week">
                {{week.iri_week_viewOnly}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Territory -->
        <div class="filter-field">
          <label class="form-label">Territory</label>
          <mat-form-field appearance="outline">
            <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
              <mat-option [value]="'-1'">ALL</mat-option>
              <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
                {{territory.territory_name}}
              </mat-option>
            </mat-select>
          </mat-form-field>
        </div>

        <!-- Store -->
        <div class="filter-field">
          <label class="form-label">Store</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="storeAuto" formControlName="store" placeholder="Search stores...">
            <button mat-button *ngIf="filterForm.get('store')?.value" matSuffix mat-icon-button (click)="clearStrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #storeAuto="matAutocomplete" (optionSelected)="onStoreSelected($event)">
              <mat-option *ngFor="let store of filteredStores" [value]="store.store_name" [matTooltip]="store.store_name">
                {{store.store_name}} ({{store.store_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- FSR (Field Service Representative) -->
        <div class="filter-field">
          <label class="form-label">FSR</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="fsrAuto" formControlName="fsr" placeholder="Search FSR...">
            <button mat-button *ngIf="filterForm.get('fsr')?.value" matSuffix mat-icon-button (click)="clearFsrCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #fsrAuto="matAutocomplete" (optionSelected)="onFsrSelected($event)">
              <mat-option *ngFor="let fsr of filteredFSR" [value]="fsr.emp_name" [matTooltip]="fsr.emp_name">
                {{fsr.emp_name}} ({{fsr.emp_id}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
          <button mat-raised-button color="primary" (click)="onApplyFilters()">
            Apply Filters
          </button>
          <button mat-stroked-button (click)="onClearFilters()">
            Clear Filters
          </button>
        </div>
      </div>

      <!-- Row 2: Advanced Filters -->
      <div class="filter-row advanced-filters" [style.display]="showAdvancedFilters ? 'flex' : 'none'">
        <!-- State -->
        <div class="filter-field">
          <label class="form-label">State</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="stateAuto" formControlName="state">
            <button mat-button *ngIf="filterForm.get('state')?.value" matSuffix mat-icon-button (click)="clearStaCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #stateAuto="matAutocomplete" (optionSelected)="onStateSelected($event)">
              <mat-option *ngFor="let state of filteredState" [value]="state.state">
                {{state.state}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- City -->
        <div class="filter-field">
          <label class="form-label">City</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="cityAuto" formControlName="city">
            <button mat-button *ngIf="filterForm.get('city')?.value" matSuffix mat-icon-button (click)="clearcityCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #cityAuto="matAutocomplete" (optionSelected)="onCitySelected($event)">
              <mat-option *ngFor="let city of filteredCity" [value]="city.city">
                {{city.city}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Cluster -->
        <div class="filter-field">
          <label class="form-label">Cluster</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="clusterAuto" formControlName="cluster">
            <mat-autocomplete #clusterAuto="matAutocomplete" (optionSelected)="onClusterSelected($event)">
              <mat-option *ngFor="let cluster of filteredCluster" [value]="cluster.position_name">
                {{cluster.position_name}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>

        <!-- Task -->
        <div class="filter-field">
          <label class="form-label">Task</label>
          <mat-form-field appearance="outline">
            <input matInput [matAutocomplete]="taskAuto" formControlName="task">
            <button mat-button *ngIf="filterForm.get('task')?.value" matSuffix mat-icon-button (click)="clearTaskCtrl()">
              <mat-icon>cancel</mat-icon>
            </button>
            <mat-autocomplete #taskAuto="matAutocomplete" (optionSelected)="onTaskSelected($event)">
              <mat-option *ngFor="let task of filteredTask" [value]="task.task_name">
                {{task.task_name}} ({{task.task_number}})
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
        </div>
      </div>

      <!-- Row 3: FSR Hours & Toggle Options -->
      <div class="filter-row options-filters" [style.display]="showAdvancedFilters ? 'flex' : 'none'">
        <!-- FSR Hours -->
        <div class="filter-field">
          <label class="form-label">FSR Hours</label>
          <mat-form-field appearance="outline">
            <input matInput formControlName="fsrHour" type="number" placeholder="Enter hours...">
          </mat-form-field>
        </div>

        <!-- Assigned/Unassigned Stores Toggle -->
        <div class="toggle-field">
          <label class="form-label">Store Assignment</label>
          <mat-radio-group formControlName="storeAssignment" class="radio-group">
            <mat-radio-button value="assigned">Assigned Stores</mat-radio-button>
            <mat-radio-button value="unassigned">Unassigned Stores</mat-radio-button>
            <mat-radio-button value="all">All Stores</mat-radio-button>
          </mat-radio-group>
        </div>

        <!-- Sample/Non-Sample Toggle -->
        <div class="toggle-field">
          <label class="form-label">Sample Type</label>
          <mat-radio-group formControlName="sampleType" class="radio-group">
            <mat-radio-button value="sample">Sample</mat-radio-button>
            <mat-radio-button value="nonSample">Non-Sample</mat-radio-button>
            <mat-radio-button value="all">All Types</mat-radio-button>
          </mat-radio-group>
        </div>

        <!-- Multi FSR Store Checkbox -->
        <div class="checkbox-field">
          <label class="form-label">Options</label>
          <mat-checkbox formControlName="multiFsrStore">Multi FSR Store</mat-checkbox>
        </div>
      </div>

      <!-- Advanced Filters Toggle -->
      <div class="advanced-toggle">
        <button mat-button type="button" (click)="toggleAdvancedFilters()" class="toggle-button">
          <mat-icon>{{showAdvancedFilters ? 'expand_less' : 'expand_more'}}</mat-icon>
          {{showAdvancedFilters ? 'Hide' : 'Show'}} Advanced Filters
        </button>
      </div>
    </form>
  </div>
</div>

store-table.component.html

<div class="table-container">
  <mat-card class="table-card">
    <!-- <mat-card-header>
      <mat-card-title>Store Assignment Data</mat-card-title>
      <mat-card-subtitle>{{dataSource.data.length}} stores found</mat-card-subtitle>
    </mat-card-header>
     -->
    <mat-card-content>
      <div class="table-wrapper">
        <!-- FIXED: Using your working table structure -->
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2">
          
          <!-- Store Number Column with Expansion -->
          <ng-container matColumnDef="store_number">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">
                <button 
            mat-icon-button 
            [disabled]="isExpandingAll"
            (click)="expandAllRows()" 
            [title]="allExpanded ? 'Collapse All' : 'Expand All'"
            class="expand-all-btn">
            <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
          </button>
              Store #
            </mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell">
               <span class="caret" 
                    id="caretIcon" 
                    [class.clicked]="isRowExpanded(element)">â–¼</span>
              <span class="store-number">{{element.StoreNumber}}</span>
              <span *ngIf="!element.hasDetails">&nbsp;&nbsp;&nbsp;&nbsp;</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Store Name Column -->
          <ng-container matColumnDef="store_name">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">Store Name</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-name-cell">
              <div class="store-info">
                <span class="store-name" (click)="openProximityDataDialog(element);$event.stopPropagation();">{{element.StoreName}}</span>
              </div>
            </mat-cell>
          </ng-container>

          <!-- Store Address Column -->
          <ng-container matColumnDef="addr_line1">
            <mat-header-cell *matHeaderCellDef class="mat-header-style">Store Address</mat-header-cell>
            <mat-cell *matCellDef="let element" class="address-cell">
              {{element.AddrLine1}}
            </mat-cell>
          </ng-container>

          <!-- City Column -->
          <ng-container matColumnDef="city">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">City</mat-header-cell>
            <mat-cell *matCellDef="let element" class="city-cell">{{element.City}}</mat-cell>
          </ng-container>

          <!-- State Column -->
          <ng-container matColumnDef="state">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">State</mat-header-cell>
            <mat-cell *matCellDef="let element" class="state-cell">
              <span class="state-badge">{{element.State}}</span>
            </mat-cell>
          </ng-container>

          <!-- Zip Column -->
          <ng-container matColumnDef="zip">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">Zip</mat-header-cell>
            <mat-cell *matCellDef="let element" class="zip-cell">{{element.Zip}}</mat-cell>
          </ng-container>

          <!-- Assigned To Column -->
          <ng-container matColumnDef="assigned_to">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">Assigned To</mat-header-cell>
            <mat-cell *matCellDef="let element" class="assigned-cell">
              <span class="assignment-badge" [ngClass]="getAssignmentClass(element.AssignedTo)">
                {{element.AssignedTo}}
              </span>
            </mat-cell>
          </ng-container>

          <!-- Average Collection Time Column -->
          <ng-container matColumnDef="expected_collection_time">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">Avg Coll Time</mat-header-cell>
            <mat-cell *matCellDef="let element" class="collection-time-cell">
              {{formatCollectionTime(element.ExpectedCollectionTime)}}
            </mat-cell>
          </ng-container>

          <!-- Cluster Column -->
          <ng-container matColumnDef="position_name">
            <mat-header-cell *matHeaderCellDef  class="mat-header-style">Cluster</mat-header-cell>
            <mat-cell *matCellDef="let element" class="cluster-cell">
              {{getClusterDisplay(element.PositionName)}}
            </mat-cell>
          </ng-container>

          <!-- FIXED: Header and Data Rows (like your working example) -->
          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row 
            *matRowDef="let row; columns: displayedColumns; let i = index"
            [ngClass]="{'selected-row': row === selectedRow}"
            class="table-row"
            [cdkDetailRow]="row" 
            [cdkDetailRowTpl]="tpl"
            (toggleChange)="GetSubgridData($event, row)"
            (dataLoadRequest)="onDataLoadRequest($event)"
            matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator 
        [pageSizeOptions]="[5, 10, 20, 50]" 
        showFirstLastButtons
        class="table-paginator">
      </mat-paginator>

      <!--  Inner Table Template  -->
         <ng-template #tpl let-element let-subgridData="subgridData" let-isLoading="isLoading">
        <div class="mat-row detail-row" style="overflow: hidden;">
          
          <!-- Loading indicator for this specific row -->
          <div *ngIf="isLoading" class="row-loading">
            <mat-spinner diameter="20"></mat-spinner>
            <span>Loading data for {{element.StoreName}}...</span>
          </div>
          
          <!-- Data table for this specific row -->
          <table class="expanded-table" *ngIf="!isLoading"> 
            <tr> 
             <th>Task Name</th>
              <th>Assigned To</th>              
              <th>CSR Info</th>
              <th>Wave</th>
              <th>Avg Coll Time</th>
            </tr>
            <tr *ngFor="let item of subgridData;">
              <td> {{item.TaskName}}</td>
              <td>{{item.AssignedTo}} </td>              
              <td>{{item.CsrInfo}} </td>
              <td >
                {{item.Wave}}       
              </td>
              <td >
                {{item.ExpectedCollectionTime}}</td>
             
            </tr>       
          </table>
        </div>
      </ng-template>
      <!-- <ng-template #tpl let-element>
        <div class="mat-row detail-row" [@detailExpand] style="overflow: hidden;">
          <table class="expanded-table"> 
            <tr> 
              <th>Task Name</th>
              <th>Assigned To</th>              
              <th>CSR Info</th>
              <th>Wave</th>
              <th>Avg Coll Time</th>
             
            </tr>
            <tr *ngFor="let item of SubgridData">
              <td> {{item.TaskName}}</td>
              <td>{{item.AssignedTo}} </td>              
              <td>{{item.CsrInfo}} </td>
              <td >
                {{item.Wave}}       
              </td>
              <td >
                {{item.ExpectedCollectionTime}}</td>
             
            </tr>       
          </table>
        </div>
      </ng-template> -->
    </mat-card-content>
  </mat-card>
</div>

store-table.component.ts

import { trigger, state, style, transition, animate } from '@angular/animations';
import { SelectionModel } from '@angular/cdk/collections';
import { HttpClient } from '@angular/common/http';
import { AfterViewInit, Component, Inject, OnDestroy, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatTable, MatTableDataSource } from '@angular/material/table';
import { catchError, of, Subject, takeUntil } from 'rxjs';
import { ProximityDialogComponent } from 'src/app/dialog/proximity-dialog/proximity-dialog.component';
import { CdkDetailRowDirective } from 'src/app/shared/cdk-detail-row.directive';
import { GetGridDataFilter, Store } from 'src/app/shared/common.model';
import { CommonService } from 'src/app/shared/common.service';

@Component({
  selector: 'app-store-table',
  templateUrl: './store-table.component.html',
  styleUrls: ['./store-table.component.css'],
  animations: [
    trigger('detailExpand', [
      state('collapsed', style({height: '0px', minHeight: '0'})),
      state('expanded', style({height: '*'})),
      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
    ]),
  ],
})
export class StoreTableComponent implements OnInit, OnDestroy,AfterViewInit {
   @ViewChild(MatTable, { static: false }) table:MatTable<any>;
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort) sort!: MatSort;
@ViewChildren(CdkDetailRowDirective) detailRows!: QueryList<CdkDetailRowDirective>;
  isExpandingAll = false;
  allExpanded = false;
  expandedRowsData = new Map<string, any[]>();
  expandedRow: CdkDetailRowDirective | undefined;
  selectedRow:any=null;
  private unsubscribe$ = new Subject<void>();

  displayedColumns: string[] = ['store_number','store_name', 'addr_line1', 'city', 'state', 'zip', 'assigned_to', 'expected_collection_time', 'position_name'];
  dataSource = new MatTableDataSource<Store>([]);
  selection = new SelectionModel<Store>(true, []);
  GetGridDataFilter:GetGridDataFilter 
  private destroy$ = new Subject<void>();
  loggeduser:string
  isExpansionDetailRow = (index, row) => row.hasOwnProperty('detailRow');
   
  constructor(private commonService: CommonService,
  public http: HttpClient,
  @Inject('BASE_URL') public baseUrl: string,
  private dialog:MatDialog) {this.loggeduser = localStorage.getItem("loggedUserId"); }

  ngOnInit(): void {
    this.commonService.gridData$
      .pipe(takeUntil(this.destroy$))
      .subscribe(stores => {
       this.dataSource=new MatTableDataSource<any>([]);
         this.dataSource = new MatTableDataSource<any>(stores);
        this.dataSource.paginator = this.paginator;
        this.dataSource.sort = this.sort;
         this.resetExpansionState();
      });
  }
getGridData(){
// this.showSpinner= true
 const payLoad:GetGridDataFilter ={
   countryId: "1",
   countryName: '',
   lanId: this.loggeduser,
   iriWeek: '2404',
   iriWeekViewOnly: '',
   area: '23',
   territoryId: '52',
   territoryName: '',
   fromDate: '',
   toDate: '',
   storeNumber: '',
   storeName: '',
   state: '',
   city: '',
   taskNumber: '',
   taskName: '',
   positionNumber: '',
   positionName: '',
   empId: '',
   firstName: '',
   lastName: '',
   empName: '',
   fsrOver25hrs: 'false',
   fsrOver6hrs: 'false',
   fsrHour: '',
   fsrHourOperator: 'NA',
   assignedStores: 'false',
   unassignedStores: 'false',
   sample: 'false',
   nonSample: 'false',
   multiFsrStore: 'false',
   vacation: 'false',
   action: '',
   comment: '',
   fmEmail: '',
   fmEmpId: '',
   assignmentMode: '',
   temporary: 'false'
 }
    this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetGridData',payLoad).pipe(takeUntil(this.unsubscribe$)).subscribe( { 
      next: 
      (response) => {                  
        this.dataSource=new MatTableDataSource<any>([]);
         this.dataSource = new MatTableDataSource<any>(response);
        this.dataSource.paginator = this.paginator;
        this.dataSource.sort = this.sort;
       },
       error: 
       (error) => { console.error(error); },
      });   
}

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }

  /** Selects all rows if they are not all selected; otherwise clear selection. */
 

  /** The label for the checkbox on the passed row */
  checkboxLabel(row?: Store): string {
    if (!row) {
      return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
    }
    return `${this.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.id}`;
  }


  /** Get full address string */
  getFullAddress(store: Store): string {
    return `${store.addr_line1}, ${store.city}, ${store.state} ${store.zip}`;
  }

  trackByStoreNumber(index: number, item: any): any {
  return item.storeNumber || item.StoreNumber || index;
}

async expandAllRows(): Promise<void> {
    if (this.isExpandingAll) {
      return;
    }
    
    this.isExpandingAll = true;
    
    try {
      if (this.allExpanded) {
        this.collapseAllRows();
      } else {
        await this.expandAllRowsWithData();
      }
      
      this.allExpanded = !this.allExpanded;
      
    } catch (error) {
      console.error('Error in expandAllRows:', error);
    } finally {
      this.isExpandingAll = false;
    }
  }

  // FIXED: Expand rows with proper data assignment
  private async expandAllRowsWithData(): Promise<void> {
    console.log('Starting to expand all rows with data...');
    
    const currentPageData = this.getCurrentPageData();
    const detailRowsArray = this.detailRows?.toArray() || [];
    
    if (detailRowsArray.length === 0) {
      console.warn('No detail row directives found');
      return;
    }

    // Load all data first
    console.log('Loading data for all rows...');
    const dataLoadPromises = currentPageData.map(rowData => 
      this.loadSubgridDataForRow(rowData).catch(error => {
        console.error(`Error loading data for ${rowData.StoreNumber}:`, error);
        return []; // Return empty array on error
      })
    );

    const allRowData = await Promise.all(dataLoadPromises);
    console.log('All data loaded, expanding rows...');

    // Now expand each row with its specific data
    for (let i = 0; i < Math.min(currentPageData.length, detailRowsArray.length); i++) {
      const detailRowDirective = detailRowsArray[i];
      const rowData = allRowData[i];
      
      if (detailRowDirective && detailRowDirective.canExpand()) {
        try {
          // Expand with specific data for this row
          detailRowDirective.expandWithData(rowData);
          console.log(`Expanded row ${i + 1} with ${rowData.length} detail records`);
          
          // Small delay for UI smoothness
          await this.delay(25);
          
        } catch (error) {
          console.error(`Error expanding row ${i}:`, error);
        }
      }
    }
    
    console.log('Finished expanding all rows');
  }

  // UPDATED: Collapse all rows
  private collapseAllRows(): void {
    console.log('Collapsing all rows...');
    
    const detailRowsArray = this.detailRows?.toArray() || [];
    
    detailRowsArray.forEach((detailRow, index) => {
      if (detailRow.isExpanded) {
        detailRow.collapse();
        console.log(`Collapsed row ${index + 1}`);
      }
    });
    
    this.selectedRow = null;
    this.expandedRow = undefined;
    
    console.log('All rows collapsed');
  }

  // UPDATED: Handle individual data load requests
  onDataLoadRequest(event: {directive: CdkDetailRowDirective, rowData: any}): void {
    const { directive, rowData } = event;
    
    // Check if we have cached data
    const storeKey = rowData.StoreNumber || rowData.store_number;
    if (this.expandedRowsData.has(storeKey)) {
      directive.setSubgridData(this.expandedRowsData.get(storeKey) || []);
    } else {
      // Load data from API
      this.loadSubgridDataForRow(rowData)
        .then(data => {
          directive.setSubgridData(data);
        })
        .catch(error => {
          console.error('Error loading subgrid data:', error);
          directive.setSubgridData([]);
        });
    }
  }

  // UPDATED: Load subgrid data method
  private loadSubgridDataForRow(row: any): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const storeKey = row.StoreNumber || row.store_number;
      
      // Check cache first
      if (this.expandedRowsData.has(storeKey)) {
        resolve(this.expandedRowsData.get(storeKey) || []);
        return;
      }

      const payload = {
        IriWeek: row.IriWeek || row.iri_week,
        StoreNumber: storeKey
      };

      this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetSubgridData', payload)
        .pipe(takeUntil(this.unsubscribe$))
        .subscribe({
          next: (response) => {
            this.expandedRowsData.set(storeKey, response);
            resolve(response);
          },
          error: (error) => {
            console.error(`Error loading data for store ${storeKey}:`, error);
            reject(error);
          }
        });
    });
  }

  // SIMPLIFIED: Individual row expansion
  GetSubgridData(cdkDetailRow: CdkDetailRowDirective, row: any): void {
    console.log('Individual row toggle:', row.StoreNumber, 'Expanded:', cdkDetailRow.isExpanded);
    
    // Close previously expanded row if different
    if (this.expandedRow && this.expandedRow !== cdkDetailRow && this.expandedRow.isExpanded) {
      this.expandedRow.collapse();
    }
    
    this.expandedRow = cdkDetailRow.isExpanded ? cdkDetailRow : undefined;
    this.selectedRow = cdkDetailRow.isExpanded ? row : null;

    this.updateCaretIcon(cdkDetailRow, cdkDetailRow.isExpanded);
  }

  // UPDATED: Update caret icon
  updateCaretIcon(cdkDetailRow: CdkDetailRowDirective, isExpanded: boolean): void {
    setTimeout(() => {
      const rowElement = cdkDetailRow.viewContainerRef.element.nativeElement.parentElement;
      const caretIcon = rowElement?.querySelector('.caret');
      
      if (caretIcon) {
        if (isExpanded) {
          caretIcon.classList.add('clicked');
        } else {
          caretIcon.classList.remove('clicked');
        }
      }
    }, 0);
  }

  // UTILITY METHODS
  private getCurrentPageData(): any[] {
    if (!this.paginator) {
      return this.dataSource.data;
    }
    
    const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
    const endIndex = startIndex + this.paginator.pageSize;
    return this.dataSource.data.slice(startIndex, endIndex);
  }

  private resetExpansionState(): void {
    this.allExpanded = false;
    this.expandedRowsData.clear();
    this.selectedRow = null;
    this.expandedRow = undefined;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // TEMPLATE HELPERS
  isRowExpanded(row: any): boolean {
    return this.selectedRow === row;
  }

  getAssignmentClass(assignedTo: string): string {
    return assignedTo === 'NOT ASSIGNED' ? 'not-assigned' : 'assigned';
  }

  formatCollectionTime(time: string): string {
    return time || 'Not specified';
  }

  getClusterDisplay(positionName: string): string {
    return positionName || 'N/A';
  }


  UpdateTableWidth(){
  const tablewidth = document.getElementById('table'); 
  if(this.displayedColumns.length == 20){
    tablewidth.style.width = 150+'%' ;      
  }
 }

 isExpanded(store: any): boolean {
  return this.selectedRow === store ;
}

openProximityDataDialog(data:any){
    const dialogRef = this.dialog.open(ProximityDialogComponent,{
      width: '40vw',
      maxWidth: '40vw',
      minWidth: '600px',
      // height: '55vh',
      maxHeight: '55vh',
      minHeight:'250px',
      data:data,
      disableClose: true,
    })
  }

}
