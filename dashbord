 async expandAllRows(): Promise<void> {
    if (this.isExpandingAll) {
      return;
    }
    
    this.isExpandingAll = true;
    
    try {
      if (this.allExpanded) {
        this.collapseAllRows();
      } else {
        await this.expandAllRowsWithData();
      }
      
      this.allExpanded = !this.allExpanded;
      
    } catch (error) {
      console.error('Error in expandAllRows:', error);
    } finally {
      this.isExpandingAll = false;
    }
  }

  // FIXED: Expand rows with proper data assignment
  private async expandAllRowsWithData(): Promise<void> {
    console.log('Starting to expand all rows with data...');
    
    const currentPageData = this.getCurrentPageData();
    const detailRowsArray = this.detailRows?.toArray() || [];
    
    if (detailRowsArray.length === 0) {
      console.warn('No detail row directives found');
      return;
    }

    // Load all data first
    console.log('Loading data for all rows...');
    const dataLoadPromises = currentPageData.map(rowData => 
      this.loadSubgridDataForRow(rowData).catch(error => {
        console.error(`Error loading data for ${rowData.StoreNumber}:`, error);
        return []; // Return empty array on error
      })
    );

    const allRowData = await Promise.all(dataLoadPromises);
    console.log('All data loaded, expanding rows...');

    // Now expand each row with its specific data
    for (let i = 0; i < Math.min(currentPageData.length, detailRowsArray.length); i++) {
      const detailRowDirective = detailRowsArray[i];
      const rowData = allRowData[i];
      
      if (detailRowDirective && detailRowDirective.canExpand()) {
        try {
          // Expand with specific data for this row
          detailRowDirective.expandWithData(rowData);
          console.log(`Expanded row ${i + 1} with ${rowData.length} detail records`);
          
          // Small delay for UI smoothness
          await this.delay(25);
          
        } catch (error) {
          console.error(`Error expanding row ${i}:`, error);
        }
      }
    }
    
    console.log('Finished expanding all rows');
  }

  // UPDATED: Collapse all rows
  private collapseAllRows(): void {
    console.log('Collapsing all rows...');
    
    const detailRowsArray = this.detailRows?.toArray() || [];
    
    detailRowsArray.forEach((detailRow, index) => {
      if (detailRow.isExpanded) {
        detailRow.collapse();
        console.log(`Collapsed row ${index + 1}`);
      }
    });
    
    this.selectedRow = null;
    this.expandedRow = undefined;
    
    console.log('All rows collapsed');
  }

  // UPDATED: Handle individual data load requests
  onDataLoadRequest(event: {directive: CdkDetailRowDirective, rowData: any}): void {
    const { directive, rowData } = event;
    
    // Check if we have cached data
    const storeKey = rowData.StoreNumber || rowData.store_number;
    if (this.expandedRowsData.has(storeKey)) {
      directive.setSubgridData(this.expandedRowsData.get(storeKey) || []);
    } else {
      // Load data from API
      this.loadSubgridDataForRow(rowData)
        .then(data => {
          directive.setSubgridData(data);
        })
        .catch(error => {
          console.error('Error loading subgrid data:', error);
          directive.setSubgridData([]);
        });
    }
  }

  // UPDATED: Load subgrid data method
  private loadSubgridDataForRow(row: any): Promise<any[]> {
    return new Promise((resolve, reject) => {
      const storeKey = row.StoreNumber || row.store_number;
      
      // Check cache first
      if (this.expandedRowsData.has(storeKey)) {
        resolve(this.expandedRowsData.get(storeKey) || []);
        return;
      }

      const payload = {
        IriWeek: row.IriWeek || row.iri_week,
        StoreNumber: storeKey
      };

      this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetSubgridData', payload)
        .pipe(takeUntil(this.unsubscribe$))
        .subscribe({
          next: (response) => {
            this.expandedRowsData.set(storeKey, response);
            resolve(response);
          },
          error: (error) => {
            console.error(`Error loading data for store ${storeKey}:`, error);
            reject(error);
          }
        });
    });
  }

  // SIMPLIFIED: Individual row expansion
  GetSubgridData(cdkDetailRow: CdkDetailRowDirective, row: any): void {
    console.log('Individual row toggle:', row.StoreNumber, 'Expanded:', cdkDetailRow.isExpanded);
    
    // Close previously expanded row if different
    if (this.expandedRow && this.expandedRow !== cdkDetailRow && this.expandedRow.isExpanded) {
      this.expandedRow.collapse();
    }
    
    this.expandedRow = cdkDetailRow.isExpanded ? cdkDetailRow : undefined;
    this.selectedRow = cdkDetailRow.isExpanded ? row : null;

    this.updateCaretIcon(cdkDetailRow, cdkDetailRow.isExpanded);
  }

  // UPDATED: Update caret icon
  updateCaretIcon(cdkDetailRow: CdkDetailRowDirective, isExpanded: boolean): void {
    setTimeout(() => {
      const rowElement = cdkDetailRow.viewContainerRef.element.nativeElement.parentElement;
      const caretIcon = rowElement?.querySelector('.caret');
      
      if (caretIcon) {
        if (isExpanded) {
          caretIcon.classList.add('clicked');
        } else {
          caretIcon.classList.remove('clicked');
        }
      }
    }, 0);
  }

  // UTILITY METHODS
  private getCurrentPageData(): any[] {
    if (!this.paginator) {
      return this.dataSource.data;
    }
    
    const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
    const endIndex = startIndex + this.paginator.pageSize;
    return this.dataSource.data.slice(startIndex, endIndex);
  }

  private resetExpansionState(): void {
    this.allExpanded = false;
    this.expandedRowsData.clear();
    this.selectedRow = null;
    this.expandedRow = undefined;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // TEMPLATE HELPERS
  isRowExpanded(row: any): boolean {
    return this.selectedRow === row;
  }

  getAssignmentClass(assignedTo: string): string {
    return assignedTo === 'NOT ASSIGNED' ? 'not-assigned' : 'assigned';
  }

  formatCollectionTime(time: string): string {
    return time || 'Not specified';
  }

  getClusterDisplay(positionName: string): string {
    return positionName || 'N/A';
  }
}
3. Updated Store Table HTML (FIXED TEMPLATE)
xml
<!-- store-table.component.html - UPDATED TEMPLATE WITH INDIVIDUAL DATA -->

<div class="table-container">
  <mat-card class="table-card">
    <mat-card-header>
      <mat-card-title>Store Assignment Data</mat-card-title>
      <mat-card-subtitle>{{dataSource.data.length}} stores found</mat-card-subtitle>
    </mat-card-header>
    
    <mat-card-content>
      <div class="table-controls">
        <button 
          mat-icon-button 
          [disabled]="isExpandingAll || dataSource.data.length === 0"
          (click)="expandAllRows()" 
          [title]="allExpanded ? 'Collapse All Rows' : 'Expand All Rows'"
          class="expand-all-btn">
          <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
        </button>
        
        <span class="expand-status" *ngIf="isExpandingAll">
          <mat-spinner diameter="16"></mat-spinner>
          <span>{{allExpanded ? 'Collapsing' : 'Loading data and expanding'}} rows...</span>
        </span>
        
        <span class="expand-info" *ngIf="!isExpandingAll">
          {{allExpanded ? 'All rows expanded' : 'Click to expand all rows'}}
        </span>
      </div>

      <div class="table-wrapper">
        <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2">
          
          <!-- All column definitions remain the same... -->
          <ng-container matColumnDef="store_number">
            <mat-header-cell *matHeaderCellDef mat-sort-header class="mat-header-style">Store #</mat-header-cell>
            <mat-cell *matCellDef="let element" class="store-number-cell" id="dropdown">
              <span class="caret" 
                    id="caretIcon" 
                    [class.clicked]="isRowExpanded(element)">â–¼</span>
              <span class="store-number">{{element.StoreNumber}}</span>
            </mat-cell>
          </ng-container>

          <!-- Other columns... (same as before) -->

          <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
          <mat-row 
            *matRowDef="let row; columns: displayedColumns; let i = index"
            [ngClass]="{'selected-row': row === selectedRow}"
            class="table-row"
            [cdkDetailRow]="row" 
            [cdkDetailRowTpl]="tpl"
            (toggleChange)="GetSubgridData($event, row)"
            (dataLoadRequest)="onDataLoadRequest($event)"
            matRipple>
          </mat-row>
        </mat-table>
      </div>
      
      <mat-paginator 
        [pageSizeOptions]="[5, 10, 20, 50]" 
        showFirstLastButtons
        class="table-paginator">
      </mat-paginator>

      <!-- FIXED: Template with individual data access -->
      <ng-template #tpl let-element let-subgridData="subgridData" let-isLoading="isLoading">
        <div class="mat-row detail-row" style="overflow: hidden;">
          
          <!-- Loading indicator for this specific row -->
          <div *ngIf="isLoading" class="row-loading">
            <mat-spinner diameter="20"></mat-spinner>
            <span>Loading data for {{element.StoreName}}...</span>
          </div>
          
          <!-- Data table for this specific row -->
          <table class="expanded-table" *ngIf="!isLoading"> 
            <tr> 
              <th>T #</th>
              <th>Collector</th>              
              <th>Store #</th>
              <th>Name</th>
              <th>Address</th>
              <th>Collected</th>
              <th>Height</th>
              <th>Width</th>
              <th>Depth</th>            
              <th>Processed</th>
            </tr>
            <tr *ngFor="let item of subgridData; trackBy: trackByStoreNumber">
              <td>{{item.territory || element.Territory || 'N/A'}}</td>
              <td>{{item.collectorName || element.CollectorName || 'N/A'}}</td>              
              <td>{{item.storeNumber || element.StoreNumber}}</td>
              <td style="max-width: 283px; white-space: normal;">
                {{item.storeName || element.StoreName}}                
              </td>
              <td style="max-width: 283px; white-space: normal;">
                {{item.storeAddress || element.AddrLine1}}
              </td>
              <td>{{item.collected || element.Collected || 'N/A'}}</td>
              <td>{{item.height || element.Height || 'N/A'}}</td>
              <td>{{item.width || element.Width || 'N/A'}}</td>
              <td>{{item.depth || element.Depth || 'N/A'}}</td>
              <td>{{item.processed || element.Processed || 'N/A'}}</td>
            </tr>
            <tr *ngIf="!subgridData || subgridData.length === 0">
              <td colspan="10" style="text-align: center; padding: 20px; color: #666;">
                No detail data available for {{element.StoreName}}
              </td>
            </tr>
          </table>
        </div>
      </ng-template>
    </mat-card-content>
  </mat-card>
</div>
4. Add TrackBy Function (PERFORMANCE OPTIMIZATION)
typescript
// store-table.component.ts - ADD TRACKBY FUNCTION

// ADD: TrackBy function for better performance
trackByStoreNumber(index: number, item: any): any {
  return item.storeNumber || item.StoreNumber || index;
}
5. Updated Store Table CSS (ADD LOADING STYLES)
css
/* store-table.component.css - ADD LOADING STYLES */

.row-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 20px;
  background: #f8f9fa;
  border: 1px dashed #dee2e6;
  margin: 10px 20px;
  border-radius: 4px;
  font-size: 14px;
  color: #666;
}

/* Add loading state for directive */
.expanded.loading {
  opacity: 0.7;
}
