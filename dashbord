Complete Analysis: Generate Work Order & Email Work Order Implementation
Overview of Functionality
From the code analysis, there are two main features:

Generate Work Order - Creates PDF work orders for FM and FSRs

Email Work Order - Sends the generated work orders via email

1. Generate Work Order Functionality
Parameters Required for CreateWorkOrder Controller Method:
typescript
// Parameters sent to CreateWorkOrder endpoint
interface CreateWorkOrderParams {
  countryId: string;         // Current selected country
  iri_week: string;          // Selected IRI week
  territory_id: string;      // Selected territory
  comment: string;           // Additional comments from user
  fm_emp_id: string;         // Field Manager Employee ID (from territory data)
  fm_email: string;          // Field Manager Email (from territory data)
  area: string;              // Area ID (default 23)
  
  // Filter parameters (used for filtering data)
  store_number: string;      // Optional store filter
  state: string;             // Optional state filter
  city: string;              // Optional city filter
  position_number: string;   // Optional cluster filter
  task_number: string;       // Optional task filter
  emp_id: string;            // Optional FSR filter
  fsr_over_25hrs: string;    // Boolean filter
  fsr_over_6hrs: string;     // Boolean filter
  assigned_stores: string;   // Boolean filter
  unassigned_stores: string; // Boolean filter
  sample: string;            // Boolean filter
  nonsample: string;         // Boolean filter
  multi_fsr_store: string;   // Boolean filter
  vacation: string;          // Boolean filter
  temporary: string;         // Boolean filter
  fsr_hour: string;          // FSR hour filter
  fsr_hour_operator: string; // Operator for FSR hour (>, =, <, NA)
}
Controller API Endpoint:
csharp
[HttpPost]
public string CreateWorkOrder(string param)
{
    // Returns pdfSessionId for the generated work order
}
2. Email Work Order Functionality
Parameters Required for SendWorkOrderEmail Controller Method:
typescript
interface SendWorkOrderEmailParams {
  pdfSessionId: string;  // Session ID returned from CreateWorkOrder
}
Controller API Endpoint:
csharp
[HttpPost]
public void SendWorkOrderEmail(string pdfSessionId)
{
    // Sends email to FM and FSRs with work order attachments
}
3. Angular Implementation for Your Dashboard
Add to Common Service
typescript
// common.service.ts - ADD WORK ORDER METHODS

export class CommonService {
  
  // Existing methods...

  // Generate Work Order
  createWorkOrder(params: any): Observable<string> {
    return this.http.post<string>(
      this.baseUrl + 'api/TaskAssignment/CreateWorkOrder', 
      { param: JSON.stringify(params) },
      { 
        headers: { 'Content-Type': 'application/json; charset=utf-8' }
      }
    );
  }

  // Email Work Order
  sendWorkOrderEmail(pdfSessionId: string): Observable<any> {
    return this.http.post(
      this.baseUrl + 'api/TaskAssignment/SendWorkOrderEmail',
      { pdfSessionId: pdfSessionId },
      { 
        headers: { 'Content-Type': 'application/json; charset=utf-8' }
      }
    );
  }
}
Add to Dashboard Layout Component
typescript
// dashboard-layout.component.ts - ADD WORK ORDER FUNCTIONALITY

export class DashbordLayoutComponent implements OnInit, OnDestroy {
  
  // Existing properties...
  isWoEmailed = true;           // Track if work order has been emailed
  pdfSessionId: string = '';    // Store session ID from generated work order
  territoryList: any[] = [];    // Territory data with FM info
  
  // Work order generation state
  isGeneratingWorkOrder = false;
  isSendingWorkOrder = false;

  constructor(
    private commonService: CommonService,
    private http: HttpClient,
    private snackBar: MatSnackBar,
    @Inject('BASE_URL') public baseUrl: string,
  ) { 
    // Existing constructor code...
  }

  async ngOnInit(): Promise<void> {
    // Existing ngOnInit code...
    
    // Load territory list for FM information
    await this.loadTerritoryList();
  }

  // Load territory data with Field Manager information
  private async loadTerritoryList(): Promise<void> {
    try {
      this.territoryList = await firstValueFrom(
        this.http.post<any[]>(
          this.baseUrl + 'api/TaskAssignment/GetTerritory',
          { countryId: this.commonService.getCurrentCountry() }
        )
      );
    } catch (error) {
      console.error('Error loading territory list:', error);
      this.showError('Error loading territory information');
    }
  }

  // Generate Work Order
  async onGenerateWorkOrder(): Promise<void> {
    if (!this.isWoEmailed) {
      this.showError('Previously created work order is not emailed to employees yet.');
      return;
    }

    const comment = await this.getWorkOrderComment();
    if (comment === null) return; // User cancelled

    this.isGeneratingWorkOrder = true;

    try {
      // Get current filter values
      const currentFilters = this.getCurrentFilters();
      
      // Get FM information from territory
      const currentTerritory = this.territoryList.find(
        t => t.territory_id === currentFilters.territory_id
      );

      const params = {
        ...currentFilters,
        comment: comment,
        fm_emp_id: currentTerritory?.fm_emp_id || '',
        fm_email: currentTerritory?.fm_email || ''
      };

      console.log('Generating work order with params:', params);

      this.showInfo('Work orders for FM and FSRs are being generated, it may take few minutes.');

      this.pdfSessionId = await firstValueFrom(
        this.commonService.createWorkOrder(params)
      );

      this.isWoEmailed = false;
      this.showSuccess('Work order generated successfully.');

    } catch (error) {
      console.error('Error generating work order:', error);
      this.showError('Error while generating work order.');
    } finally {
      this.isGeneratingWorkOrder = false;
    }
  }

  // Email Work Order
  async onEmailWorkOrder(): Promise<void> {
    if (this.isWoEmailed) {
      this.showError('There are no work orders to be emailed, please generate a new one.');
      return;
    }

    if (!this.pdfSessionId) {
      this.showError('No work order session found. Please generate a work order first.');
      return;
    }

    this.isSendingWorkOrder = true;

    try {
      await firstValueFrom(
        this.commonService.sendWorkOrderEmail(this.pdfSessionId)
      );

      this.isWoEmailed = true;
      this.showSuccess('Work order emails have been queued.');

    } catch (error) {
      console.error('Error sending work order emails:', error);
      this.showError('Error while sending work order emails.');
    } finally {
      this.isSendingWorkOrder = false;
    }
  }

  // Get current filter values from filter component
  private getCurrentFilters(): any {
    // Get current filters from your filter service/component
    const currentCountry = this.commonService.getCurrentCountry();
    
    return {
      countryId: currentCountry,
      area: '23', // Default area
      iri_week: '', // Get from filter component
      territory_id: '', // Get from filter component
      store_number: '',
      state: '',
      city: '',
      position_number: '',
      task_number: '',
      emp_id: '',
      fsr_over_25hrs: 'false',
      fsr_over_6hrs: 'false',
      assigned_stores: 'false',
      unassigned_stores: 'false',
      sample: 'false',
      nonsample: 'false',
      multi_fsr_store: 'false',
      vacation: 'false',
      temporary: 'false',
      fsr_hour: '',
      fsr_hour_operator: 'NA'
    };
  }

  // Get work order comment from user
  private getWorkOrderComment(): Promise<string | null> {
    return new Promise((resolve) => {
      const dialogRef = this.dialog.open(WorkOrderCommentDialog, {
        width: '400px',
        disableClose: true
      });

      dialogRef.afterClosed().subscribe(result => {
        resolve(result);
      });
    });
  }

  // Utility methods for notifications
  private showSuccess(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 4000,
      panelClass: ['success-snackbar']
    });
  }

  private showError(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      panelClass: ['error-snackbar']
    });
  }

  private showInfo(message: string): void {
    this.snackBar.open(message, 'Close', {
      duration: 4000,
      panelClass: ['info-snackbar']
    });
  }
}
Update Dashboard Layout HTML
xml
<!-- dashboard-layout.component.html - ADD WORK ORDER BUTTONS -->

<mat-toolbar class="mat-toolbar-primary">
  <!-- Existing toolbar content... -->
  
  <span class="toolbar-spacer"></span>
  
  <!-- Country Selector -->
  <div class="country-field">
    <mat-form-field appearance="outline">
      <mat-select [formControl]="countryctrl" placeholder="Select country">
        <mat-option *ngFor="let country of countrylist" 
                    [value]="country.countryID" 
                    (onSelectionChange)="selectedcountry($event)">
          {{country.countryName}}
        </mat-option>
      </mat-select>
    </mat-form-field>        
  </div>
  
  <!-- Work Order Buttons -->
  <button mat-icon-button 
          [disabled]="isGeneratingWorkOrder"
          (click)="onGenerateWorkOrder()" 
          title="Generate Work Order"
          class="work-order-btn">
    <mat-icon>create</mat-icon>
  </button>
  
  <button mat-icon-button 
          [disabled]="isSendingWorkOrder || isWoEmailed"
          (click)="onEmailWorkOrder()" 
          title="Email Work Order"
          class="work-order-btn">
    <mat-icon>send</mat-icon>
  </button>
  
  <!-- Export Button -->
  <button mat-icon-button 
          (click)="onExportData()" 
          title="Export Grid Data"
          class="work-order-btn">
    <mat-icon>download</mat-icon>
  </button>
</mat-toolbar>
Create Work Order Comment Dialog
typescript
// work-order-comment-dialog.component.ts

import { Component } from '@angular/core';
import { MatDialogRef } from '@angular/material/dialog';

@Component({
  selector: 'app-work-order-comment-dialog',
  template: `
    <h2 mat-dialog-title>Enter Additional Communication</h2>
    <mat-dialog-content>
      <mat-form-field appearance="outline" style="width: 100%;">
        <mat-label>Additional Comments</mat-label>
        <textarea matInput 
                  [(ngModel)]="comment"
                  maxlength="500"
                  placeholder="Only 500 characters"
                  rows="6">
        </textarea>
        <mat-hint>{{comment.length}}/500 characters</mat-hint>
      </mat-form-field>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button (click)="onCancel()">Cancel</button>
      <button mat-button color="primary" (click)="onConfirm()">OK</button>
    </mat-dialog-actions>
  `
})
export class WorkOrderCommentDialog {
  comment = '';

  constructor(
    public dialogRef: MatDialogRef<WorkOrderCommentDialog>
  ) {}

  onCancel(): void {
    this.dialogRef.close(null);
  }

  onConfirm(): void {
    this.dialogRef.close(this.comment);
  }
}
Add CSS Styles
css
/* dashboard-layout.component.css - ADD WORK ORDER STYLES */

.work-order-btn {
  color: #00b0f0;
  margin-left: 8px;
}

.work-order-btn:hover:not(:disabled) {
  background-color: rgba(0, 176, 240, 0.1);
}

.work-order-btn:disabled {
  color: #ccc;
}

/* Snackbar styles */
.success-snackbar {
  background-color: #4caf50;
  color: white;
}

.error-snackbar {
  background-color: #f44336;
  color: white;
}

.info-snackbar {
  background-color: #ff9800;
  color: white;
}
4. Key Implementation Notes
State Management:
isWoEmailed: Tracks whether the generated work order has been sent

pdfSessionId: Stores the session ID returned from work order generation

Work order must be generated before it can be emailed

User Flow:
User clicks "Generate Work Order"

System prompts for additional comments

System generates PDF work order using current filters

System returns session ID and enables email button

User clicks "Email Work Order"

System sends emails to FM and FSRs

Email button becomes disabled until next generation

Filter Integration:
The work order uses the same filter parameters as your main grid search, so you'll need to get current filter values from your filter component.

Error Handling:
Proper loading states for both operations

User-friendly error messages via snackbar

Validation before allowing email sending

This implementation matches the original functionality while using modern Angular patterns and Material Design components!
