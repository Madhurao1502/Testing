<div class="shelf-task-container" style="display: flex; gap: 20px;">
  <div class="tree-container" style="flex: 1; max-width: 60%;">
    <mat-tab-group [(selectedIndex)]="selectedTabIndex" 
  (selectedIndexChange)="onTabChangeByIndex($event)">
    <mat-tab label="Location">
      <app-shelf-task-tree [nodes]="locationTree" [disabled]="isLocked"
        (nodeCheck)="toggleNodeCheck($event)" (nodeSelect)="selectNode($event)"
        (selectAllChildren)="checkAllChildren($event)"></app-shelf-task-tree>
    </mat-tab>
    <mat-tab label="Section">
      <app-shelf-task-tree [nodes]="sectionTree" [disabled]="isLocked"
        (nodeCheck)="toggleNodeCheck($event)" (nodeSelect)="selectNode($event)"
        (selectAllChildren)="checkAllChildren($event)"></app-shelf-task-tree>
    </mat-tab>
    <mat-tab label="Shelf">
      <app-shelf-task-tree [nodes]="shelfTree" [disabled]="isLocked"
        (nodeCheck)="toggleNodeCheck($event)" (nodeSelect)="selectNode($event)"
        (selectAllChildren)="checkAllChildren($event)"></app-shelf-task-tree>
    </mat-tab>
    <mat-tab label="UPC">
      <app-shelf-task-tree [nodes]="upcTree" [disabled]="isLocked"
        (nodeCheck)="toggleNodeCheck($event)" (nodeSelect)="selectNode($event)"
        (selectAllChildren)="checkAllChildren($event)"></app-shelf-task-tree>
    </mat-tab>
  </mat-tab-group> 
  </div>

  <div class="limits-container" style="flex: 0 0 300px;" *ngIf="showLimitsPanel">
    <div *ngIf="showLimitsPanel">
      <form [formGroup]="limitsForm">
        <mat-form-field *ngIf="activeTab === 'location'">
          <mat-label>Min</mat-label>
          <input matInput formControlName="min" [disabled]="isLocked" />
        </mat-form-field>
        <mat-form-field *ngIf="activeTab === 'location'">
          <mat-label>Max</mat-label>
          <input matInput formControlName="max" [disabled]="isLocked" />
        </mat-form-field>

        <mat-form-field *ngIf="showChecksPanel">
          <mat-label>Soft Check</mat-label>
          <input matInput formControlName="soft" [disabled]="isLocked" />
        </mat-form-field>
        <mat-form-field *ngIf="showChecksPanel">
          <mat-label>Hard Check</mat-label>
          <input matInput formControlName="hard" [disabled]="isLocked" />
        </mat-form-field>
      </form>
    </div>
  </div>

@Component({
  selector: 'app-shelf-task',
  templateUrl: './shelf-task.component.html',
  styleUrls: ['./shelf-task.component.css']
})
export class ShelfTaskComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
@Input() taskId!: number;
  @Input() taskVersion!: string;
  @Input() lockoutId!: string;

  activeTab = 'location';
  currTabCode = 'trLocation';

  // Trees
  locationTree: ShelfNode[] = [];
  sectionTree: ShelfNode[] = [];
  shelfTree: ShelfNode[] = [];
  upcTree: ShelfNode[] = [];

  activeNode: ShelfNode | null = null;
  showLimitsPanel = false;
  showChecksPanel = false;

  activeSectionLimitId: number | null = null;
  activeShelfLimitId: number | null = null;
  
  // Categories
  reviewCategories: ReviewCategory[] = [];
  selectedCategories: ReviewCategory[] = [];
  isLocked = false;

  limitsForm: FormGroup;
  loggedUser: string;
  tabNames = ['location', 'section', 'shelf', 'upc'];
  selectedTabIndex = 0;
  constructor(public http: HttpClient,
      @Inject('BASE_URL') public baseUrl: string,
      private router: Router,
       private fb: FormBuilder,
      private activatedRoute: ActivatedRoute,
      private dialog: MatDialog,
      public service: CommonService,
      private _snackBar: SnackbarService) { this.loggedUser = localStorage.getItem('loggedUserId'); 
      this.limitsForm = this.fb.group({
      min: ['', [Validators.pattern(/^\d+$/)]],
      max: ['', [Validators.pattern(/^\d+$/)]],
      soft: ['', [Validators.pattern(/^\d+$/)]],
      hard: ['', [Validators.pattern(/^\d+$/)]]
    });
     }

  ngOnInit() {
    this.selectedTabIndex = this.tabNames.indexOf(this.activeTab);
     this.service.initializeTask(this.taskId, this.taskVersion, this.lockoutId, localStorage.getItem('loggedUserId')!);
    this.isLocked = this.service.isTaskLocked();
    this.service.loadAllTreeData();
    this.service.locationTree$.pipe(takeUntil(this.destroy$)).subscribe(data =>{
      this.locationTree = data
      if(this.locationTree.length>0){
        const firstNode = this.locationTree[0]
        firstNode.checked=true;
        this.updatePanelsForNode(firstNode)
      }
    });
    this.service.sectionTree$.pipe(takeUntil(this.destroy$)).subscribe(data =>{
      this.sectionTree = data
      if(this.sectionTree.length>0){
        const firstNode = this.sectionTree[0]
        firstNode.checked=true;
        this.updatePanelsForNode(firstNode)
      }
    });
    this.service.shelfTree$.pipe(takeUntil(this.destroy$)).subscribe(data => {      
      this.shelfTree = data
      if(this.shelfTree.length>0){
        const firstNode = this.shelfTree[0]
        firstNode.checked=true;
        this.updatePanelsForNode(firstNode)
      }
    });
    this.service.upcTree$.pipe(takeUntil(this.destroy$)).subscribe(data =>{
      this.upcTree = data
      if(this.upcTree.length>0){
        const firstNode = this.upcTree[0]
        firstNode.checked=true;
        this.updatePanelsForNode(firstNode)
      }
    });
    this.service.reviewCategories$.pipe(takeUntil(this.destroy$)).subscribe(data =>     
       this.reviewCategories = data
    
    );
    this.service.selectedReviewCategories$.pipe(takeUntil(this.destroy$)).subscribe(data =>
       this.selectedCategories = data
  
      );

    

    this.limitsForm.valueChanges.pipe(takeUntil(this.destroy$)).subscribe(() => this.onLimitsFormChange());
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  onTabChangeByIndex(index: number) {
  this.selectedTabIndex = index;
  this.activeTab = this.tabNames[index];
  this.onTabChange(this.activeTab);  
}

  onTabChange(tab: string) {
    this.activeTab = tab;
    this.currTabCode = 'tr' + tab.charAt(0).toUpperCase() + tab.slice(1);
    this.activeNode = null;
    this.showLimitsPanel = false;
    this.showChecksPanel = false;

    setTimeout(() => {
      const firstNode = this.getTreeForActiveTab()[0];
      if (firstNode) {
        this.selectNode(firstNode);
      }
    }, 100);
  }



  getTreeForActiveTab(): ShelfNode[] {
    switch (this.activeTab) {
      case 'location': return this.locationTree;
      case 'section': return this.sectionTree;
      case 'shelf': return this.shelfTree;
      case 'upc': return this.upcTree;
      default: return [];
    }
  }

  selectNode(node: ShelfNode) {
    this.activeNode = node;
    this.updatePanelsForNode(node);
  }

  toggleNodeCheck(node: ShelfNode) {
    if (this.isLocked || node.disabled) return;
    node.checked = !node.checked;
    this.handleSpecialNodeLogic(node);
    this.setCheckedForAllChildren(node,node.checked)
    this.updateTreeData();
    this.updatePanelsForNode(node);
  }

  private setCheckedForAllChildren(node:ShelfNode,checked:boolean){
    if(!node.children) return;
    node.children.forEach(child=>{
      if(!child.disabled){
        child.checked =checked;
        this.setCheckedForAllChildren(child,checked)
      }
    })
  }

  private handleSpecialNodeLogic(node: ShelfNode) {
    if ((node.id === 11930 || node.id === 11960) && this.activeTab === 'section') {
      const sTree = this.sectionTree;
      const node1 = this.findNodeById(sTree, 11930);
      const node2 = this.findNodeById(sTree, 11960);
      if (node1 && node2 && !node1.checked && !node2.checked) {
        node.checked = true; // prevent both unchecked
      }
    }
  }

   checkAllChildren(node: ShelfNode) {
    if (!node.children || this.isLocked) return; 
    this.setCheckedForAllChildren(node,true)
    this.updateTreeData()
    this.updatePanelsForNode(node)

    node.open=false;
    setTimeout(() => {
      node.open=true;
    }, 100);
  }

  private updatePanelsForNode(node: ShelfNode) {
    this.showLimitsPanel = false;
    this.showChecksPanel = false;
    this.activeShelfLimitId = null;
    this.activeSectionLimitId = null;

    if (node.id === 22700) {
      // Shelf: Other height node
      if (node.checked) {
        this.showLimitsPanel = true;
        this.setLimitsForm(node);
        this.activeShelfLimitId = node.id;
      }
      return;
    }

    const sectionLimits = [11160, 15490, 15995, 14825, 16910];
    if (sectionLimits.includes(node.id)) {
      if (node.checked) {
        this.showLimitsPanel = true;
        this.setLimitsForm(node);
        this.activeSectionLimitId = node.id;
      }
      return;
    }

    const specialIds = [200, 10100, 20000, 30100];
    if (specialIds.includes(node.id)) {
      this.showLimitsPanel = true;
      this.showChecksPanel = true;
      this.setFullForm(node);
    }
  }

  private setLimitsForm(node: ShelfNode) {
    this.limitsForm.patchValue({
      min: node.taskMin ?? node.mainMin ?? '',
      max: node.taskMax ?? node.mainMax ?? '',
      soft: '',
      hard: ''
    }, { emitEvent: false });
  }

  private setFullForm(node: ShelfNode) {
    this.limitsForm.patchValue({
      min: node.taskMin ?? node.mainMin ?? '',
      max: node.taskMax ?? node.mainMax ?? '',
      soft: node.task_soft_check ?? node.main_soft_check ?? '',
      hard: node.task_hard_check ?? node.main_hard_check ?? ''
    }, { emitEvent: false });
  }

  private onLimitsFormChange() {
    if (!this.activeNode) return;
    if (this.limitsForm.invalid) return;

    if (this.activeShelfLimitId)
      if (!this.validateShelfLimits(this.limitsForm.value)) return;

    if (this.activeSectionLimitId)
      if (!this.validateSectionLimits(this.limitsForm.value)) return;

    if (['location', 'section', 'shelf', 'upc'].includes(this.activeTab) && !this.activeShelfLimitId && !this.activeSectionLimitId) {
      if (!this.validateGeneralLimits(this.limitsForm.value)) return;
    }

    this.updateNodeLimits(this.activeNode, this.limitsForm.value);
    this.updateTreeData();
  }

  private validateShelfLimits(vals: any): boolean {
    const minVal = this.getShelfMinVal();
    const maxVal = this.getShelfMaxVal();
    const min = Number(vals.min);
    const max = Number(vals.max);

    if (!isNaN(min) && min > minVal) {
      alert(`Min must be less or equal than smallest selected shelf width (${minVal})`);
      this.resetFormField('min');
      return false;
    }
    if (!max || max <= maxVal) {
      alert(`Max must be greater than largest selected shelf width (${maxVal})`);
      this.resetFormField('max');
      return false;
    }
    return true;
  }

  private validateSectionLimits(vals: any): boolean {
    const minVal = this.getSectionMinVal();
    const maxVal = this.getSectionMaxVal();
    const min = Number(vals.min);
    const max = Number(vals.max);

    if (!isNaN(min) && min > minVal && minVal !== -1) {
      alert(`Min must be less than smallest selected section width (${minVal})`);
      this.resetFormField('min');
      return false;
    }
    if (!max || max <= maxVal && maxVal !== -1) {
      alert(`Max must be greater than largest selected section width (${maxVal})`);
      this.resetFormField('max');
      return false;
    }
    return true;
  }

  private validateGeneralLimits(vals: any): boolean {
    const min = Number(vals.min);
    const soft = Number(vals.soft);
    const hard = Number(vals.hard);
    const max = Number(vals.max);

    if (soft < min) {
      alert('Soft check must be >= Min');
      this.resetFormField('soft');
      return false;
    }
    if (hard < soft + 3) {
      alert('Hard check must be at least 3 more than soft check');
      this.resetFormField('hard');
      return false;
    }
    if (this.activeTab === 'location' && hard > max) {
      alert('Hard check must be <= Max');
      this.resetFormField('hard');
      return false;
    }
    return true;
  }

  private getShelfMinVal(): number {
    let vals: number[] = [];
    this.collectValuesForShelf(this.shelfTree, vals, true, ['Height'], 'checked');
    return vals.length ? Math.min(...vals) : 0;
  }

  private getShelfMaxVal(): number {
    let vals: number[] = [];
    this.collectValuesForShelf(this.shelfTree, vals, true, ['Height'], 'checked');
    return vals.length ? Math.max(...vals) : 999;
  }

  private collectValuesForShelf(nodes: ShelfNode[], collector: number[], requireChecked: boolean, varNames: string[], valueField: keyof ShelfNode) {
    for (const node of nodes) {
      if (varNames.includes(node.name)) {
        if (node.children) {
          for (const child of node.children) {
            if ((!requireChecked || child.checked) && child.name !== 'Other Height' && typeof child.value === 'number') {
              collector.push(child.value);
            }
          }
        }
      }
      if (node.children) {
        this.collectValuesForShelf(node.children, collector, requireChecked, varNames, valueField);
      }
    }
  }

  private getSectionMinVal(): number {
    const parent = this.findSectionLimitParent();
    if (!parent) return -1;
    const vals = parent.children?.filter(c => c.checked && !c.name.startsWith('Other'))?.map(c => Number(c.value)) ?? [];
    return vals.length ? Math.min(...vals) : -1;
  }
  private getSectionMaxVal(): number {
    const parent = this.findSectionLimitParent();
    if (!parent) return -1;
    const vals = parent.children?.filter(c => c.checked && !c.name.startsWith('Other'))?.map(c => Number(c.value)) ?? [];
    return vals.length ? Math.max(...vals) : -1;
  }
  private findSectionLimitParent(): ShelfNode | null {
    if (!this.sectionTree) return null;
    const map = {
      11160: 10210,
      15490: 15000,
      15995: 15500,
      14825: 14000,
      16910: 16500
    };
    const parentId = this.activeSectionLimitId ? map[this.activeSectionLimitId] : null;
    if (!parentId) return null;
    return this.findNodeById(this.sectionTree, parentId);
  }

  private findNodeById(nodes: ShelfNode[], id: number): ShelfNode | null {
    for (const node of nodes) {
      if (node.id === id) return node;
      if (node.children) {
        const found = this.findNodeById(node.children, id);
        if (found) return found;
      }
    }
    return null;
  }

  private updateNodeLimits(node: ShelfNode, vals: any) {
    if (vals.min !== undefined) node.taskMin = vals.min;
    if (vals.max !== undefined) node.taskMax = vals.max;
    if (vals.soft !== undefined) node.main_soft_check = vals.soft;
    if (vals.hard !== undefined) node.task_hard_check = vals.hard;
  }

  private resetFormField(field: string) {
    if (!this.activeNode) return;
    const val = this.fieldValueFromNode(this.activeNode, field);
    this.limitsForm.patchValue({ [field]: val ?? '' }, { emitEvent: false });
  }

  private fieldValueFromNode(node: ShelfNode, field: string): any {
    return {
      min: node.taskMin ?? node.mainMin ?? '',
      max: node.taskMax ?? node.mainMax ?? '',
      soft: node.main_soft_check ?? node.main_soft_check ?? '',
      hard: node.task_hard_check ?? node.main_hard_check ?? ''
    }[field];
  }

  updateTreeData() {
    switch (this.activeTab) {
      case 'location':
        this.service.updateLocationTree(this.locationTree);
        break;
      case 'section':
        this.service.updateSectionTree(this.sectionTree);
        break;
      case 'shelf':
        this.service.updateShelfTree(this.shelfTree);
        break;
      case 'upc':
        this.service.updateUpcTree(this.upcTree);
        break;
    }
  }

  saveData() {
    if (!this.validateBeforeSave()) return;

    const taskVars: TaskShelfVar[] = [];
    ['locationTree', 'sectionTree', 'shelfTree', 'upcTree'].forEach(treeName => {
      const tree = (this as any)[treeName] as ShelfNode[];
      this.addCheckedNodesToSave(tree, taskVars);
    });

    const shelfDataJson = JSON.stringify(taskVars);
    this.service.saveShelfVarDetails(shelfDataJson).subscribe({
      next: () => this.saveCategories(),
      error: () => alert('Error saving shelf data.')
    });
  }

  private addCheckedNodesToSave(nodes: ShelfNode[], collector: TaskShelfVar[]) {
    for (const node of nodes) {
      if (node.checked) {
        collector.push({
          task_number: this.taskId,
          prompt_level: 0,
          ShelfVarID: node.id,
          min: node.taskMin,
          max: node.taskMax,
          soft_check: node.task_soft_check,
          hard_check: node.task_hard_check,
          ordinal: node.mainOrdinal,
          name: node.name
        });
      }
      if (node.children) this.addCheckedNodesToSave(node.children, collector);
    }
  }

  private saveCategories() {
    const catsJson = JSON.stringify(this.selectedCategories);
    this.service.saveReviewCategoryDetails(catsJson).subscribe({
      next: () => alert('Saved successfully'),
      error: () => alert('Error saving categories')
    });
  }

  private validateBeforeSave(): boolean {
    const anyChecked = this.locationTree.some(n => n.checked) 
      || this.sectionTree.some(n => n.checked)
      || this.shelfTree.some(n => n.checked)
      || this.upcTree.some(n => n.checked);
    if (!anyChecked) {
      alert('Select at least one location');
      return false;
    }
    return true;
  }


<ul class="shelf-tree-list">
  <ng-container *ngFor="let node of nodes">
    <li>
      <div class="node-content">
        <button class="select-all" *ngIf="node.children?.length"
                (click)="node.open = !node.open; $event.stopPropagation()">
          {{ node.open ? '-' : '+' }}
        </button>

        <input type="checkbox" [checked]="node.checked" [disabled]="node.disabled || disabled"
               (change)="toggleCheck(node)" (click)="$event.stopPropagation()" />
        <span [class.disabled]="node.disabled || disabled" (click)="selectNode(node)">{{ node.name }}</span>

        <button *ngIf="node.children?.length && !disabled && !node.disabled"
                (click)="onSelectAllChildrenClick(node, $event)"> <b>(Select all Child variables)</b></button>
      </div>

      <app-shelf-task-tree *ngIf="node.children?.length && node.open"
        [nodes]="node.children"
        [disabled]="disabled"
        (nodeCheck)="nodeCheck.emit($event)"
        (nodeSelect)="nodeSelect.emit($event);"
        (selectAllChildren)="selectAllChildren.emit($event)">
      </app-shelf-task-tree>
    </li>
  </ng-container>
</ul>

import { Component, EventEmitter, Inject, Input, OnChanges, OnInit, Output, SimpleChanges } from '@angular/core';
import {  ShelfNode } from '../shared/common.model';
import { HttpClient } from '@angular/common/http';
import { MatDialog } from '@angular/material/dialog';
import { Router, ActivatedRoute } from '@angular/router';
import { Subject, takeUntil } from 'rxjs';
import { CommonService } from '../shared/common.service';
import { SnackbarService } from '../shared/snackbar.service';
import { ITreeOptions, TreeNode } from '@ali-hm/angular-tree-component';

@Component({
  selector: 'app-shelf-task-tree',
  templateUrl: './shelf-task-tree.component.html',
  styleUrls: ['./shelf-task-tree.component.css']
})
export class ShelfTaskTreeComponent implements OnInit  {
 
  showSpinner: boolean;
  loggedUser: string;
  private unsubscribe$ = new Subject<void>();
  constructor( public http: HttpClient,
          @Inject('BASE_URL') public baseUrl: string,
          private router: Router,
          private activatedRoute: ActivatedRoute,
          private dialog: MatDialog,
          public service: CommonService,
          private _snackBar: SnackbarService, 
    ) {  this.loggedUser = localStorage.getItem("loggedUserId");}

@Input() nodes: ShelfNode[] = [];
  @Input() disabled = false;
  @Output() nodeCheck = new EventEmitter<ShelfNode>();
  @Output() nodeSelect = new EventEmitter<ShelfNode>();
  @Output() selectAllChildren = new EventEmitter<ShelfNode>();

  ngOnInit(): void {}

  toggleCheck(node: ShelfNode) {
    if (this.disabled || node.disabled) return;
    node.checked = !node.checked;
    this.nodeCheck.emit(node);
  }

  selectNode(node: ShelfNode) {
    if (this.disabled) return;
    this.nodeSelect.emit(node);
  }

  onSelectAllChildrenClick(node: ShelfNode, event: Event) {
    event.stopPropagation();
    if (this.disabled) return;
    this.selectAllChildren.emit(node);
  }
}

</div>


.node-content > button:first-of-type {
    background: none;
    border: none;
    font-size: large;
    margin: -3px;
}
.node-content > button.select-all {
    background: none;
    border: none;
    font-size: large;
    margin: -3px;

}
****
.shelf-task-container {
  display: flex;
  gap: 20px;
  padding: 16px;
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  background: #fafafa;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgb(0 0 0 / 0.1);
  min-height: 400px;
}

/* Tree container */
.tree-container {
  flex: 1 1 60%;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 12px;
  background: white;
  overflow-y: auto;
  max-height: 600px;
}

/* Limits container (min/max etc) */
.limits-container {
  flex: 0 0 300px;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 12px 16px;
  background: white;
  box-shadow: inset 0 0 5px rgb(0 0 0 / 0.05);
}

/* Shelf tree list styles */
.shelf-tree-list {
  list-style: none;
  padding-left: 12px;
  margin: 0;
}

/* Each tree node styles */
.shelf-tree-list li {
  margin-bottom: 6px;
  font-size: 14px;
  user-select: none;
}

/* Node content section */
.node-content {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Expand/collapse toggle button */
.node-content button {
  background: none;
  border: none;
  font-weight: bold;
  cursor: pointer;
  width: 25px;
  height: 25px;
  color: #444;
}

.node-content button:hover {
  color: #007bff;
  background: #eaf4ff;
  border-radius: 3px;
}

/* Disabled node text style */
.node-content span.disabled {
  color: #aaa;
  cursor: not-allowed;
}

/* Select all children button */
.node-content button.select-all {
  font-weight: normal;
  font-size: 12px;
  color: #007bff;
  cursor: pointer;
  background: none;
  border: none;
  padding: 0;
  text-decoration: underline;
}

.node-content button.select-all:hover {
  color: #004a9f;
}

/* Style inputs in the limits panel */
mat-form-field {
  width: 100%;
  margin-bottom: 12px;
}
