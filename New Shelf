import { CommonService } from './../../shared/common.service';
import { Component, Inject, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialog } from '@angular/material/dialog';
import { HttpClient } from '@angular/common/http';
import { MatTableDataSource } from '@angular/material/table';
import { SelectionModel } from '@angular/cdk/collections';
import {
  catchError,
  debounceTime,
  distinctUntilChanged,
  firstValueFrom,
  map,
  Observable,
  of,
  Subject,
  switchMap,
  takeUntil,
} from 'rxjs';

export interface AssignmentDialogData {
  storeNumber: string;
  storeName: string;
  taskNumber?: string;
  taskName?: string;
  iriWeek: string;
  territoryId: string;
  positionNumber?: string;
  positionName?: string;
  city?: string;
  address?: string;
  mode: 'StoreLevel' | 'TaskLevel' | 'ClusterLevel';
}

interface NameOption {
  emp_name: string;
  emp_id: string;
  FirstName: string;
  LastName: string;
  value: string;
  id: string;
}

interface DialogResult {
  hasChanges: boolean;
  data?: any;
}

interface ProximityFsr {
  empId: string;
  firstName: string;
  lastName: string;
  time: string;
  toll: number;
  totalCost: number;
  costRank: number;
  email: string;
  fsrPhoneNum: string;
}

interface TaskAssignmentRow {
  storeNumber: string;
  storeName: string;
  positionName: string;
  address: string;
  city: string;
  assignedTo: string;
  taskName: string;
  taskNumber?: string;
  isAllTask: boolean;
  tasks?: any[]; // Sub-grid task data
}

@Component({
  selector: 'app-assignment-dialog',
  templateUrl: './assignment-dialog.component.html',
  styleUrls: ['./assignment-dialog.component.css'],
})
export class AssignmentDialogComponent implements OnInit, OnDestroy {
  // Form & Data Management
  filterForm: FormGroup;
  territories: any[] = [];
  
  // Three separate tables
  proximityDataSource = new MatTableDataSource<ProximityFsr>([]);
  fsrDataSource = new MatTableDataSource<any>([]);
  taskAssignmentDataSource = new MatTableDataSource<TaskAssignmentRow>([]);
  
  // Selection for task assignment table
  taskSelection = new SelectionModel<TaskAssignmentRow>(true, []);

  // UI State Management
  isLoading = false;
  showSpinner = false;
  isLoadingProximity = false;
  isLoadingTaskAssignment = false;

  // Autocomplete
  filteredFirstNames: Observable<NameOption[]>;
  filteredLastNames: Observable<NameOption[]>;

  // Track Changes
  private hasChanges = false;
  private destroy$ = new Subject<void>();
  selectedFirstNameId: string = '';
  selectedLastNameId: string = '';

  // Display Columns for three tables
  proximityColumns: string[] = ['empId', 'empName', 'cost', 'time', 'toll', 'phone', 'email', 'action'];
  displayedColumns: string[] = [];
  taskAssignmentColumns: string[] = ['select', 'position', 'storeNumber', 'storeName', 'address', 'city', 'assignedTo', 'task'];

  // Task data cache
  private taskData: any[] = [];

  constructor(
    private dialogRef: MatDialogRef<AssignmentDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: AssignmentDialogData,
    private fb: FormBuilder,
    private http: HttpClient,
    private commonService: CommonService,
    private dialog: MatDialog,
    @Inject('BASE_URL') private baseUrl: string
  ) {
    this.filterForm = this.fb.group({
      territory: [data.territoryId],
      firstName: [''],
      lastName: [''],
    });
  }

  async ngOnInit(): Promise<void> {
    await this.loadTerritories();
    this.setupAutocomplete();
    await this.loadCurrentAssignment();
    await this.loadProximityData();
    await this.loadTaskAssignmentData();
    this.initializeDisplayedColumns();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  getDialogTitle(): string {
    const location =
      this.data.mode === 'ClusterLevel'
        ? `Cluster: ${this.data.positionNumber} | Store: ALL`
        : `Store: ${this.data.storeName} (${this.data.storeNumber})`;

    const task = this.data.taskName
      ? ` | Task: ${this.data.taskName}`
      : ' | Task: ALL';

    return `Assignment for ${location}${task}`;
  }

  private initializeDisplayedColumns(): void {
    this.displayedColumns = this.getDisplayedColumns();
  }

  private getDisplayedColumns(): string[] {
    const columns = [];

    // Add action columns based on mode
    if (this.data.mode === 'StoreLevel') {
      columns.push('assign_all', 'unassign_all');
    } else if (this.data.mode === 'TaskLevel') {
      columns.push('assign', 'unassign');
    } else if (this.data.mode === 'ClusterLevel') {
      columns.push('assign_to_cluster', 'unassign_from_cluster');
    }

    // Add info columns
    columns.push('name', 'address', 'assigned_hrs', 'max_hrs', 'cluster', 'contact');

    return columns;
  }

  showColumn(columnName: string): boolean {
    return this.displayedColumns.includes(columnName);
  }

  // ============================================================
  // Load Proximity Data (First Table) - NEW
  // ============================================================
  private async loadProximityData(): Promise<void> {
    this.isLoadingProximity = true;
    try {
      const response = await firstValueFrom(
        this.http.post<any[]>(this.baseUrl + 'api/TaskAssinment/GetProximityData', {
          StoreNumber: this.data.storeNumber,
        })
      );

      if (response && response.length > 0) {
        // Check for non-sample C store
        if (response.NonSampleCStore !== 'NON SAMPLE C STORE') {
          const mappedData = response.map((item) => ({
            empId: item.EmpId || item.empId,
            firstName: item.FirstName || item.firstName,
            lastName: item.LastName || item.lastName,
            time: item.Time || item.time,
            toll: item.Toll || item.toll,
            totalCost: item.TotalCost || item.totalCost,
            costRank: item.CostRank || item.costRank,
            email: item.fsrEmailID || item.fsrEmailIDPersonal,
            fsrPhoneNum: item.fsrPhoneNumPersonal || item.fsrPhoneNumShipping,
          }));

          const sortedData = mappedData.sort((a, b) => (a.costRank || 0) - (b.costRank || 0));
          this.proximityDataSource.data = sortedData;
        }
      }
    } catch (error) {
      console.error('Error loading proximity data:', error);
    } finally {
      this.isLoadingProximity = false;
    }
  }

  // ============================================================
  // Load Task Assignment Data (Third Table) - NEW
  // ============================================================
  private async loadTaskAssignmentData(): Promise<void> {
    this.isLoadingTaskAssignment = true;
    try {
      // Load task data if needed
      await this.loadTaskDataIfNeeded();

      const rows: TaskAssignmentRow[] = [];

      // Add "ALL" row
      rows.push({
        storeNumber: this.data.storeNumber,
        storeName: this.data.storeName,
        positionName: this.data.positionName || '',
        address: this.data.address || '',
        city: this.data.city || '',
        assignedTo: 'ALL',
        taskName: 'ALL',
        isAllTask: true,
        tasks: this.taskData,
      });

      // Add individual task rows if available
      if (this.taskData && this.taskData.length > 0) {
        this.taskData.forEach((task) => {
          rows.push({
            storeNumber: task.storeNumber || this.data.storeNumber,
            storeName: task.storeName || this.data.storeName,
            positionName: task.positionName || this.data.positionName || '',
            address: task.addrLine1 || this.data.address || '',
            city: task.city || this.data.city || '',
            assignedTo: task.assignedTo || '',
            taskName: task.taskName,
            taskNumber: task.taskNumber,
            isAllTask: false,
          });
        });
      }

      this.taskAssignmentDataSource.data = rows;
    } catch (error) {
      console.error('Error loading task assignment data:', error);
    } finally {
      this.isLoadingTaskAssignment = false;
    }
  }

  private async loadTaskDataIfNeeded(): Promise<void> {
    try {
      // For StoreLevel and TaskLevel, we need to fetch task data for the specific store
      if (this.data.mode === 'StoreLevel' || this.data.mode === 'TaskLevel') {
        const params = {
          IriWeek: this.data.iriWeek,
          StoreNumber: this.data.storeNumber,
        };

        const response = await firstValueFrom(
          this.http.post<any>(this.baseUrl + 'api/TaskAssinment/GetSubgridData', params)
        );

        // Handle both response formats
        if (response && response.data && Array.isArray(response.data)) {
          this.taskData = response.data;
        } else if (Array.isArray(response)) {
          this.taskData = response;
        } else {
          this.taskData = [];
        }
      }
    } catch (error) {
      console.error('Error loading task data:', error);
      this.taskData = [];
    }
  }

  // ============================================================
  // Checkbox Selection Logic - NEW
  // ============================================================
  isAllSelected(): boolean {
    const numSelected = this.taskSelection.selected.length;
    const numRows = this.taskAssignmentDataSource.data.length;
    return numSelected === numRows;
  }

  masterToggle(): void {
    if (this.isAllSelected()) {
      this.taskSelection.clear();
    } else {
      this.taskAssignmentDataSource.data.forEach((row) => this.taskSelection.select(row));
    }
  }

  onRowSelectionChange(row: TaskAssignmentRow): void {
    // If user selects the "ALL" row, disable other rows
    if (row.isAllTask && this.taskSelection.isSelected(row)) {
      // Clear all selections except "ALL"
      this.taskSelection.clear();
      this.taskSelection.select(row);
    } else if (!row.isAllTask && this.taskSelection.isSelected(row)) {
      // If user selects a task-level row, deselect "ALL" row
      const allRow = this.taskAssignmentDataSource.data.find((r) => r.isAllTask);
      if (allRow && this.taskSelection.isSelected(allRow)) {
        this.taskSelection.deselect(allRow);
      }
    }
  }

  isRowDisabled(row: TaskAssignmentRow): boolean {
    // Disable task-level rows if "ALL" row is selected
    const allRow = this.taskAssignmentDataSource.data.find((r) => r.isAllTask);
    if (allRow && this.taskSelection.isSelected(allRow) && !row.isAllTask) {
      return true;
    }
    return false;
  }

  private async loadTerritories(): Promise<void> {
    try {
      this.territories = await firstValueFrom(
        this.http.get<any[]>(this.baseUrl + 'api/TaskAssinment/GetTerritory')
      );
    } catch (error) {
      console.error('Error loading territories:', error);
      this.showSpinner = true;
    }
  }

  private async loadCurrentAssignment(): Promise<void> {
    this.isLoading = true;
    try {
      const params = {
        IriWeek: this.data.iriWeek,
        StoreNumber: this.data.storeNumber,
        TaskNumber: this.data.taskNumber || '',
        AssignmentMode: this.data.mode,
        PositionNumber: this.data.positionNumber || '',
        CountryId: this.commonService.getCurrentCountry(),
      };

      const response = await firstValueFrom(
        this.http.post<any[]>(
          this.baseUrl + 'api/TaskAssinment/GetCurrentAssignment',
          params
        )
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error loading current assignment:', error);
      this.fsrDataSource.data = [];
    } finally {
      this.isLoading = false;
    }
  }

  async searchFsrs(): Promise<void> {
    this.isLoading = true;
    try {
      const formValue = this.filterForm.value;

      const params = {
        IriWeek: this.data.iriWeek,
        TerritoryId: formValue.territory,
        FirstName: formValue.firstName?.FirstName || '',
        LastName: formValue.lastName?.FirstName || '',
        PositionNumber: this.data.positionNumber || '',
        countryId: this.commonService.getCurrentCountry(),
        Area: '23',
      };

      const response = await firstValueFrom(
        this.http.post<any[]>(
          this.baseUrl + 'api/TaskAssinment/GetFsrForAssignment',
          params
        )
      );

      this.fsrDataSource.data = response;
    } catch (error) {
      console.error('Error searching FSRs:', error);
      this.fsrDataSource.data = [];
      alert('Error searching for FSRs. Please try again.');
    } finally {
      this.isLoading = false;
    }
  }

  // ============================================================
  // Assign from Proximity Table (First Table) - NEW
  // ============================================================
  async assignFromProximity(fsr: ProximityFsr): Promise<void> {
    await this.assignTaskWithSelection(fsr, 'proximity');
  }

  // ============================================================
  // Assign from FSR Table (Second Table) - MODIFIED
  // ============================================================
  async assignTask(fsr: any, action: number): Promise<void> {
    const actionNames: { [key: number]: string } = {
      1: 'assign current task to',
      2: 'assign all tasks to',
      3: 'unassign current task from',
      4: 'unassign all tasks from',
      5: 'assign to cluster',
      6: 'unassign from cluster',
    };

    const message = `Are you sure you want to ${actionNames[action]} ${fsr.FirstName} ${fsr.LastName}?`;

    if (!confirm(message)) return;

    this.showSpinner = true;
    try {
      const params = {
        iri_week: this.data.iriWeek,
        territory_id: this.filterForm.get('territory')?.value,
        store_number: this.data.storeNumber,
        emp_id: fsr.emp_id,
        task_number: this.data.taskNumber || '',
        position_number: this.data.positionNumber || '',
        action: action,
        assignment_mode: this.data.mode,
        countryId: this.commonService.getCurrentCountry(),
      };

      await firstValueFrom(
        this.http.post(this.baseUrl + 'api/TaskAssinment/SaveAssignment', params)
      );
      this.hasChanges = true;
      await this.loadCurrentAssignment();
      await this.loadTaskAssignmentData();
      this.filterForm.patchValue({ firstName: '', lastName: '' });

      alert('Assignment saved successfully.');
    } catch (error) {
      console.error('Error saving assignment:', error);
      alert('Error while saving assignment.');
    } finally {
      this.showSpinner = false;
    }
  }

  // ============================================================
  // Unified Assign Logic with Task Selection - NEW
  // ============================================================
  private async assignTaskWithSelection(fsr: any, source: 'proximity' | 'fsr'): Promise<void> {
    const selectedRows = this.taskSelection.selected;

    if (selectedRows.length === 0) {
      alert('Please select at least one task to assign.');
      return;
    }

    const fsrName = source === 'proximity' 
      ? `${fsr.firstName} ${fsr.lastName}` 
      : `${fsr.FirstName} ${fsr.LastName}`;
    const empId = source === 'proximity' ? fsr.empId : fsr.emp_id;

    // Check if "ALL" is selected
    const allSelected = selectedRows.some((row) => row.isAllTask);

    let confirmMessage = '';
    let action = 0;

    if (allSelected) {
      confirmMessage = `Are you sure you want to assign ${fsrName} to all tasks?`;
      action = 2; // Assign all
    } else {
      const taskNames = selectedRows.map((row) => row.taskName).join(', ');
      confirmMessage = `Are you sure you want to assign ${fsrName} to ${taskNames}?`;
      action = 1; // Assign specific task
    }

    if (!confirm(confirmMessage)) return;

    this.showSpinner = true;
    try {
      // If assigning all or specific tasks
      if (allSelected) {
        // Assign all tasks
        const params = {
          iri_week: this.data.iriWeek,
          territory_id: this.filterForm.get('territory')?.value,
          store_number: this.data.storeNumber,
          emp_id: empId,
          task_number: '',
          position_number: this.data.positionNumber || '',
          action: 2, // Assign all
          assignment_mode: 'StoreLevel',
          countryId: this.commonService.getCurrentCountry(),
        };

        await firstValueFrom(
          this.http.post(this.baseUrl + 'api/TaskAssinment/SaveAssignment', params)
        );
      } else {
        // Assign specific tasks
        for (const row of selectedRows) {
          const params = {
            iri_week: this.data.iriWeek,
            territory_id: this.filterForm.get('territory')?.value,
            store_number: row.storeNumber,
            emp_id: empId,
            task_number: row.taskNumber || '',
            position_number: this.data.positionNumber || '',
            action: 1, // Assign specific task
            assignment_mode: 'TaskLevel',
            countryId: this.commonService.getCurrentCountry(),
          };

          await firstValueFrom(
            this.http.post(this.baseUrl + 'api/TaskAssinment/SaveAssignment', params)
          );
        }
      }

      this.hasChanges = true;
      await this.loadCurrentAssignment();
      await this.loadTaskAssignmentData();
      this.taskSelection.clear();
      this.filterForm.patchValue({ firstName: '', lastName: '' });

      alert('Assignment saved successfully.');
    } catch (error) {
      console.error('Error saving assignment:', error);
      alert('Error while saving assignment.');
    } finally {
      this.showSpinner = false;
    }
  }

  private setupAutocomplete(): void {
    this.filteredFirstNames = this.filterForm
      .get('firstName')!
      .valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged((prev, curr) => {
          if (typeof prev === 'object' && typeof curr === 'object') {
            return prev?.id === curr?.id;
          }
          return prev === curr;
        }),
        switchMap((value) => {
          if (typeof value === 'string' && value.length >= 2) {
            return this.searchFirstNames(value);
          } else {
            return of([]);
          }
        }),
        takeUntil(this.destroy$)
      );

    this.filteredLastNames = this.filterForm
      .get('lastName')!
      .valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged((prev, curr) => {
          if (typeof prev === 'object' && typeof curr === 'object') {
            return prev?.id === curr?.id;
          }
          return prev === curr;
        }),
        switchMap((value) => {
          if (typeof value === 'string' && value.length >= 2) {
            return this.searchLastNames(value);
          } else {
            return of([]);
          }
        }),
        takeUntil(this.destroy$)
      );
  }

  private searchFirstNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'first_name',
    };

    return this.http
      .post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map((response) =>
          response.map((item) => ({
            emp_name: item.emp_name,
            emp_id: item.emp_id,
            FirstName: item.FirstName,
            LastName: item.LastName,
            value: item.emp_name,
            id: item.emp_id,
          }))
        ),
        catchError((error) => {
          console.error('Error fetching first names:', error);
          return of([]);
        })
      );
  }

  private searchLastNames(searchText: string): Observable<NameOption[]> {
    const params = {
      IriWeek: this.data.iriWeek,
      TerritoryId: this.filterForm.get('territory')?.value || this.data.territoryId,
      SearchText: searchText,
      NameType: 'last_name',
    };

    return this.http
      .post<any[]>(this.baseUrl + 'api/TaskAssinment/GetName', params)
      .pipe(
        map((response) =>
          response.map((item) => ({
            emp_name: item.emp_name,
            emp_id: item.emp_id,
            FirstName: item.FirstName,
            LastName: item.LastName,
            value: item.emp_name,
            id: item.emp_id,
          }))
        ),
        catchError((error) => {
          console.error('Error fetching last names:', error);
          return of([]);
        })
      );
  }

  onFirstNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedFirstNameId = selectedOption.id;
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  onLastNameSelected(event: any): void {
    const selectedOption = event.option.value as NameOption;
    this.selectedLastNameId = selectedOption.id;
    setTimeout(() => {
      this.searchFsrs();
    }, 100);
  }

  displayFn(option: NameOption): string {
    return option && option.FirstName ? option.FirstName : '';
  }

  onTerritoryChange(): void {
    this.filterForm.patchValue({
      firstName: '',
      lastName: '',
    });
    this.selectedFirstNameId = '';
    this.selectedLastNameId = '';
    this.fsrDataSource.data = [];
  }

  onClose(): void {
    const result: DialogResult = {
      hasChanges: this.hasChanges,
    };
    this.dialogRef.close(result);
  }

  getDisplayedColumns2(): string[] {
    return this.displayedColumns;
  }
}

<h2 mat-dialog-title class="title-style" cdkDrag cdkDragRootElement=".cdk-overlay-pane" cdkDragHandle>
  <span>{{ getDialogTitle() }}</span>
</h2>

<mat-dialog-content class="assignment-dialog-content">
  
  <!-- ============================================================ -->
  <!-- TABLE 1: Proximity FSR Table (Closest FSRs) - NEW -->
  <!-- ============================================================ -->
  <div class="table-section proximity-section">
    <h3 class="section-title">
      <mat-icon>location_on</mat-icon>
      Closest FSRs
    </h3>
    
    <div *ngIf="isLoadingProximity" class="loading-container">
      <mat-spinner diameter="30"></mat-spinner>
      <span>Loading proximity data...</span>
    </div>

    <div class="table-wrapper" *ngIf="!isLoadingProximity && proximityDataSource.data.length > 0">
      <table mat-table [dataSource]="proximityDataSource" class="proximity-table mat-elevation-z2">
        
        <!-- Employee ID Column -->
        <ng-container matColumnDef="empId">
          <th mat-header-cell *matHeaderCellDef class="col-emp-id">Employee ID</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.empId }}</td>
        </ng-container>

        <!-- Employee Name Column -->
        <ng-container matColumnDef="empName">
          <th mat-header-cell *matHeaderCellDef class="col-emp-name">Name</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.firstName }} {{ fsr.lastName }}</td>
        </ng-container>

        <!-- Cost Column -->
        <ng-container matColumnDef="cost">
          <th mat-header-cell *matHeaderCellDef class="col-cost">Cost</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.totalCost | currency }}</td>
        </ng-container>

        <!-- Travel Time Column -->
        <ng-container matColumnDef="time">
          <th mat-header-cell *matHeaderCellDef class="col-time">Travel Time</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.time }}</td>
        </ng-container>

        <!-- Toll Column -->
        <ng-container matColumnDef="toll">
          <th mat-header-cell *matHeaderCellDef class="col-toll">Toll</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.toll | currency }}</td>
        </ng-container>

        <!-- Phone Column -->
        <ng-container matColumnDef="phone">
          <th mat-header-cell *matHeaderCellDef class="col-phone">Phone</th>
          <td mat-cell *matCellDef="let fsr">{{ fsr.fsrPhoneNum }}</td>
        </ng-container>

        <!-- Email Column -->
        <ng-container matColumnDef="email">
          <th mat-header-cell *matHeaderCellDef class="col-email">Email</th>
          <td mat-cell *matCellDef="let fsr">
            <a href="mailto:{{ fsr.email }}" class="email-link">{{ fsr.email }}</a>
          </td>
        </ng-container>

        <!-- Action Column - NEW -->
        <ng-container matColumnDef="action">
          <th mat-header-cell *matHeaderCellDef class="col-action">Action</th>
          <td mat-cell *matCellDef="let fsr">
            <button 
              mat-stroked-button 
              color="primary" 
              (click)="assignFromProximity(fsr)"
              class="assign-btn"
              [disabled]="taskSelection.selected.length === 0">
              <mat-icon>person_add</mat-icon>
              Assign
            </button>
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="proximityColumns; sticky: true"></tr>
        <tr mat-row *matRowDef="let row; columns: proximityColumns;"></tr>
      </table>
    </div>

    <div *ngIf="!isLoadingProximity && proximityDataSource.data.length === 0" class="no-data">
      No proximity data available for this store.
    </div>
  </div>

  <mat-divider></mat-divider>

  <!-- ============================================================ -->
  <!-- TABLE 2: Current Assignment / Search FSR Table (Existing) -->
  <!-- ============================================================ -->
  <div class="table-section fsr-section">
    <h3 class="section-title">
      <mat-icon>search</mat-icon>
      Search & Assign FSRs
    </h3>

    <!-- Filter Section -->
    <div class="filter-section" [formGroup]="filterForm">
      <div class="filter-row">
        <mat-form-field appearance="outline" class="small-field">
          <mat-label>IRI Week</mat-label>
          <input matInput [value]="data.iriWeek" readonly />
        </mat-form-field>

        <mat-form-field appearance="outline" class="medium-field">
          <mat-label>Territory</mat-label>
          <mat-select formControlName="territory" (selectionChange)="onTerritoryChange()">
            <mat-option *ngFor="let territory of territories" [value]="territory.territory_id">
              {{ territory.territory_name }}
            </mat-option>
          </mat-select>
        </mat-form-field>
      </div>

      <div class="filter-row">
        <!-- First Name Autocomplete -->
        <mat-form-field appearance="outline" class="medium-field">
          <mat-label>First Name</mat-label>
          <input
            matInput
            formControlName="firstName"
            placeholder="Search by first name..."
            [matAutocomplete]="firstNameAuto"
          />
          <mat-autocomplete
            #firstNameAuto="matAutocomplete"
            (optionSelected)="onFirstNameSelected($event)"
            [displayWith]="displayFn"
          >
            <mat-option *ngFor="let option of filteredFirstNames | async" [value]="option">
              {{ option.FirstName }} {{ option.LastName }}
            </mat-option>
          </mat-autocomplete>
        </mat-form-field>

        <!-- Last Name Autocomplete -->
        <mat-form-field appearance="outline" class="medium-field">
          <mat-label>Last Name</mat-label>
          <input
            matInput
            formControlName="lastName"
            placeholder="Search by last name..."
            [matAutocomplete]="lastNameAuto"
          />
          <mat-autocomplete
            #lastNameAuto="matAutocomplete"
            (optionSelected)="onLastNameSelected($event)"
            [displayWith]="displayFn"
          >
            <mat-option *ngFor="let option of filteredLastNames | async" [value]="option">
              {{ option.FirstName }} {{ option.LastName }}
            </mat-option>
          </mat-autocomplete>
        </mat-form-field>

        <!-- Search Button -->
        <button 
          mat-raised-button 
          color="primary" 
          (click)="searchFsrs()" 
          [disabled]="isLoading"
          class="search-btn">
          <mat-icon>search</mat-icon>
          Search
        </button>
      </div>
    </div>

    <!-- Loading Indicator -->
    <div *ngIf="isLoading" class="loading-container">
      <mat-spinner diameter="30"></mat-spinner>
      <span>Loading FSRs...</span>
    </div>

    <!-- FSR Table -->
    <div class="table-wrapper" *ngIf="!isLoading">
      <table mat-table [dataSource]="fsrDataSource" class="fsr-table mat-elevation-z2">
        
        <!-- Action Columns (conditional based on mode) -->
        <ng-container matColumnDef="assign_all" *ngIf="showColumn('assign_all')">
          <mat-header-cell *matHeaderCellDef class="col-action">Assign All</mat-header-cell>
          <mat-cell *matCellDef="let fsr">
            <button
              mat-stroked-button
              color="primary"
              (click)="assignTask(fsr, 2)"
              class="action-button">
              Assign All
            </button>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="unassign_all" *ngIf="showColumn('unassign_all')">
          <mat-header-cell *matHeaderCellDef class="col-action">Unassign All</mat-header-cell>
          <mat-cell *matCellDef="let fsr">
            <button
              mat-stroked-button
              color="warn"
              (click)="assignTask(fsr, 4)"
              class="action-button">
              Unassign All
            </button>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="assign" *ngIf="showColumn('assign')">
          <mat-header-cell *matHeaderCellDef class="col-action">Assign</mat-header-cell>
          <mat-cell *matCellDef="let fsr">
            <button
              mat-stroked-button
              color="primary"
              (click)="assignTask(fsr, 1)"
              class="action-button">
              Assign
            </button>
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="unassign" *ngIf="showColumn('unassign')">
          <mat-header-cell *matHeaderCellDef class="col-action">Unassign</mat-header-cell>
          <mat-cell *matCellDef="let fsr">
            <button
              mat-stroked-button
              color="warn"
              (click)="assignTask(fsr, 3)"
              class="action-button">
              Unassign
            </button>
          </mat-cell>
        </ng-container>

        <!-- FSR Information Columns -->
        <ng-container matColumnDef="name">
          <mat-header-cell *matHeaderCellDef class="col-name">Name</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-name">
            {{ fsr.LastName }}, {{ fsr.FirstName }}
          </mat-cell>
        </ng-container>

        <ng-container matColumnDef="address">
          <mat-header-cell *matHeaderCellDef class="col-address">Address</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-address">{{ fsr.AddrLine1 }}</mat-cell>
        </ng-container>

        <ng-container matColumnDef="assigned_hrs">
          <mat-header-cell *matHeaderCellDef class="col-assigned-hrs">Assigned Hrs</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-assigned-hrs">{{ fsr.AssignedHrs }}</mat-cell>
        </ng-container>

        <ng-container matColumnDef="max_hrs">
          <mat-header-cell *matHeaderCellDef class="col-max-hrs">Max Hours</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-max-hrs">{{ fsr.MaxHrs }}</mat-cell>
        </ng-container>

        <ng-container matColumnDef="cluster">
          <mat-header-cell *matHeaderCellDef class="col-cluster">Cluster</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-cluster">{{ fsr.PositionName }}</mat-cell>
        </ng-container>

        <ng-container matColumnDef="contact">
          <mat-header-cell *matHeaderCellDef class="col-contact">Contact</mat-header-cell>
          <mat-cell *matCellDef="let fsr" class="col-contact">
            <div class="contact-item">{{ fsr.phone }}</div>
            <div class="contact-item">
              <a href="mailto:{{ fsr.Email }}" class="contact-link">{{ fsr.Email }}</a>
            </div>
          </mat-cell>
        </ng-container>

        <mat-header-row *matHeaderRowDef="getDisplayedColumns2(); sticky: true"></mat-header-row>
        <mat-row *matRowDef="let row; columns: getDisplayedColumns2()"></mat-row>
      </table>

      <div *ngIf="fsrDataSource.data.length === 0 && !isLoading" class="no-data">
        No FSRs found. Please adjust your search criteria.
      </div>
    </div>
  </div>

  <mat-divider></mat-divider>

  <!-- ============================================================ -->
  <!-- TABLE 3: Task Assignment Selection Table - NEW -->
  <!-- ============================================================ -->
  <div class="table-section task-assignment-section">
    <h3 class="section-title">
      <mat-icon>assignment</mat-icon>
      Select Tasks to Assign
    </h3>

    <div *ngIf="isLoadingTaskAssignment" class="loading-container">
      <mat-spinner diameter="30"></mat-spinner>
      <span>Loading task data...</span>
    </div>

    <div class="table-wrapper" *ngIf="!isLoadingTaskAssignment">
      <table mat-table [dataSource]="taskAssignmentDataSource" class="task-assignment-table mat-elevation-z2">
        
        <!-- Checkbox Column -->
        <ng-container matColumnDef="select">
          <th mat-header-cell *matHeaderCellDef class="col-checkbox">
            <mat-checkbox 
              (change)="$event ? masterToggle() : null"
              [checked]="taskSelection.hasValue() && isAllSelected()"
              [indeterminate]="taskSelection.hasValue() && !isAllSelected()">
            </mat-checkbox>
          </th>
          <td mat-cell *matCellDef="let row" class="col-checkbox">
            <mat-checkbox
              (click)="$event.stopPropagation()"
              (change)="$event ? taskSelection.toggle(row) : null; onRowSelectionChange(row)"
              [checked]="taskSelection.isSelected(row)"
              [disabled]="isRowDisabled(row)">
            </mat-checkbox>
          </td>
        </ng-container>

        <!-- Position Column -->
        <ng-container matColumnDef="position">
          <th mat-header-cell *matHeaderCellDef class="col-position">Position</th>
          <td mat-cell *matCellDef="let row">{{ row.positionName || 'N/A' }}</td>
        </ng-container>

        <!-- Store Number Column -->
        <ng-container matColumnDef="storeNumber">
          <th mat-header-cell *matHeaderCellDef class="col-store-number">Store #</th>
          <td mat-cell *matCellDef="let row">{{ row.storeNumber }}</td>
        </ng-container>

        <!-- Store Name Column -->
        <ng-container matColumnDef="storeName">
          <th mat-header-cell *matHeaderCellDef class="col-store-name">Store Name</th>
          <td mat-cell *matCellDef="let row">{{ row.storeName }}</td>
        </ng-container>

        <!-- Address Column -->
        <ng-container matColumnDef="address">
          <th mat-header-cell *matHeaderCellDef class="col-address">Address</th>
          <td mat-cell *matCellDef="let row">{{ row.address }}</td>
        </ng-container>

        <!-- City Column -->
        <ng-container matColumnDef="city">
          <th mat-header-cell *matHeaderCellDef class="col-city">City</th>
          <td mat-cell *matCellDef="let row">{{ row.city }}</td>
        </ng-container>

        <!-- Assigned To Column -->
        <ng-container matColumnDef="assignedTo">
          <th mat-header-cell *matHeaderCellDef class="col-assigned-to">Assigned To</th>
          <td mat-cell *matCellDef="let row">{{ row.assignedTo || 'Not Assigned' }}</td>
        </ng-container>

        <!-- Task Column -->
        <ng-container matColumnDef="task">
          <th mat-header-cell *matHeaderCellDef class="col-task">Task</th>
          <td mat-cell *matCellDef="let row" [ngClass]="{'all-task-cell': row.isAllTask}">
            <strong *ngIf="row.isAllTask">{{ row.taskName }}</strong>
            <span *ngIf="!row.isAllTask">{{ row.taskName }}</span>
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="taskAssignmentColumns; sticky: true"></tr>
        <tr mat-row 
            *matRowDef="let row; columns: taskAssignmentColumns;"
            [ngClass]="{'all-task-row': row.isAllTask, 'disabled-row': isRowDisabled(row)}"
            (click)="!isRowDisabled(row) ? taskSelection.toggle(row) : null; onRowSelectionChange(row)">
        </tr>
      </table>

      <div *ngIf="taskAssignmentDataSource.data.length === 0" class="no-data">
        No tasks available for assignment.
      </div>
    </div>

    <div class="selection-info" *ngIf="taskSelection.selected.length > 0">
      <mat-icon>info</mat-icon>
      <span>{{ taskSelection.selected.length }} task(s) selected</span>
    </div>
  </div>

</mat-dialog-content>

<mat-dialog-actions align="end" class="dialog-actions">
  <button mat-button (click)="onClose()">
    <mat-icon>close</mat-icon>
    Close
  </button>
</mat-dialog-actions>

<!-- Loading Spinner Overlay -->
<div class="spinner-overlay" *ngIf="showSpinner">
  <mat-spinner></mat-spinner>
  <p>Processing assignment...</p>
</div>


/* ============================================================ */
/* Dialog Container & Layout */
/* ============================================================ */
.assignment-dialog-content {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 20px;
  min-width: 900px;
  max-height: 75vh;
  overflow-y: auto;
}

.title-style {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 16px 24px;
  margin: -24px -24px 0 -24px;
  cursor: move;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 18px;
  font-weight: 500;
}

/* ============================================================ */
/* Table Sections */
/* ============================================================ */
.table-section {
  background: #ffffff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.section-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  font-weight: 600;
  color: #333;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 2px solid #f0f0f0;
}

.section-title mat-icon {
  color: #667eea;
  font-size: 24px;
  width: 24px;
  height: 24px;
}

/* ============================================================ */
/* Loading & No Data States */
/* ============================================================ */
.loading-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  padding: 40px 20px;
  color: #666;
  font-size: 14px;
}

.no-data {
  text-align: center;
  padding: 40px 20px;
  color: #999;
  font-size: 14px;
  font-style: italic;
  background: #f9f9f9;
  border-radius: 4px;
}

/* ============================================================ */
/* Filter Section */
/* ============================================================ */
.filter-section {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 6px;
  margin-bottom: 16px;
}

.filter-row {
  display: flex;
  gap: 16px;
  align-items: center;
  margin-bottom: 12px;
}

.filter-row:last-child {
  margin-bottom: 0;
}

.filter-row mat-form-field {
  flex: 1;
}

.small-field {
  max-width: 150px;
}

.medium-field {
  max-width: 250px;
}

.search-btn {
  height: 48px;
  min-width: 120px;
  font-size: 14px;
}

/* ============================================================ */
/* Table Common Styles */
/* ============================================================ */
.table-wrapper {
  width: 100%;
  overflow-x: auto;
  border-radius: 4px;
}

table {
  width: 100%;
  font-size: 14px;
}

.mat-header-cell {
  background: #667eea;
  color: white !important;
  font-weight: 600;
  font-size: 13px;
  padding: 12px 16px;
}

.mat-cell {
  padding: 12px 16px;
  font-size: 14px;
  color: #333;
}

.mat-row {
  transition: background-color 0.2s ease;
}

.mat-row:hover {
  background-color: #f5f7ff;
}

/* ============================================================ */
/* Proximity Table Specific Styles */
/* ============================================================ */
.proximity-table .col-emp-id {
  width: 120px;
}

.proximity-table .col-emp-name {
  width: 180px;
  font-weight: 500;
}

.proximity-table .col-cost {
  width: 100px;
  text-align: right;
}

.proximity-table .col-time {
  width: 120px;
}

.proximity-table .col-toll {
  width: 100px;
  text-align: right;
}

.proximity-table .col-phone {
  width: 140px;
}

.proximity-table .col-email {
  width: 200px;
}

.proximity-table .col-action {
  width: 130px;
  text-align: center;
}

.assign-btn {
  font-size: 13px;
  padding: 6px 16px;
}

.assign-btn mat-icon {
  font-size: 18px;
  width: 18px;
  height: 18px;
  margin-right: 4px;
}

/* ============================================================ */
/* FSR Table Specific Styles */
/* ============================================================ */
.fsr-table .col-name {
  min-width: 180px;
  font-weight: 500;
}

.fsr-table .col-address {
  min-width: 200px;
}

.fsr-table .col-assigned-hrs,
.fsr-table .col-max-hrs {
  width: 120px;
  text-align: right;
}

.fsr-table .col-cluster {
  width: 150px;
}

.fsr-table .col-contact {
  min-width: 200px;
}

.fsr-table .col-action {
  width: 130px;
  text-align: center;
}

.action-button {
  font-size: 13px;
  padding: 6px 16px;
  min-width: 100px;
}

.contact-item {
  margin: 4px 0;
  font-size: 13px;
}

.contact-link,
.email-link {
  color: #667eea;
  text-decoration: none;
  transition: color 0.2s ease;
}

.contact-link:hover,
.email-link:hover {
  color: #764ba2;
  text-decoration: underline;
}

/* ============================================================ */
/* Task Assignment Table Specific Styles */
/* ============================================================ */
.task-assignment-table {
  margin-top: 8px;
}

.task-assignment-table .col-checkbox {
  width: 60px;
  text-align: center;
  padding: 8px;
}

.task-assignment-table .col-position {
  width: 120px;
}

.task-assignment-table .col-store-number {
  width: 100px;
}

.task-assignment-table .col-store-name {
  min-width: 180px;
}

.task-assignment-table .col-address {
  min-width: 200px;
}

.task-assignment-table .col-city {
  width: 140px;
}

.task-assignment-table .col-assigned-to {
  width: 160px;
}

.task-assignment-table .col-task {
  width: 150px;
}

/* All Task Row Highlighting */
.all-task-row {
  background-color: #fff9e6 !important;
  font-weight: 600;
}

.all-task-row:hover {
  background-color: #fff4cc !important;
}

.all-task-cell {
  color: #f57c00;
  font-size: 14px;
}

/* Disabled Row Styling */
.disabled-row {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: #f5f5f5 !important;
}

.disabled-row:hover {
  background-color: #f5f5f5 !important;
}

/* Selection Info */
.selection-info {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 12px;
  padding: 10px 16px;
  background: #e3f2fd;
  border-left: 4px solid #2196f3;
  border-radius: 4px;
  font-size: 14px;
  color: #1976d2;
}

.selection-info mat-icon {
  color: #2196f3;
  font-size: 20px;
  width: 20px;
  height: 20px;
}

/* ============================================================ */
/* Dialog Actions */
/* ============================================================ */
.dialog-actions {
  padding: 16px 24px;
  border-top: 1px solid #e0e0e0;
  background: #fafafa;
}

.dialog-actions button {
  font-size: 14px;
  padding: 8px 20px;
}

.dialog-actions button mat-icon {
  margin-right: 6px;
  font-size: 18px;
  width: 18px;
  height: 18px;
}

/* ============================================================ */
/* Spinner Overlay */
/* ============================================================ */
.spinner-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  z-index: 9999;
}

.spinner-overlay p {
  color: white;
  font-size: 16px;
  font-weight: 500;
}

/* ============================================================ */
/* Material Overrides */
/* ============================================================ */
::ng-deep .mat-form-field-appearance-outline .mat-form-field-outline {
  color: #e0e0e0;
}

::ng-deep .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick {
  color: #667eea;
}

::ng-deep .mat-form-field-appearance-outline .mat-form-field-label {
  color: #666;
  font-size: 14px;
}

::ng-deep .mat-checkbox-checked.mat-accent .mat-checkbox-background {
  background-color: #667eea;
}

::ng-deep .mat-checkbox-disabled {
  opacity: 0.4;
}

/* ============================================================ */
/* Responsive Design */
/* ============================================================ */
@media (max-width: 1200px) {
  .assignment-dialog-content {
    min-width: 100%;
  }
  
  .filter-row {
    flex-wrap: wrap;
  }
  
  .medium-field {
    max-width: 100%;
  }
}

@media (max-width: 768px) {
  .filter-row {
    flex-direction: column;
  }
  
  .filter-row mat-form-field {
    width: 100%;
  }
  
  .search-btn {
    width: 100%;
  }
  
  .table-section {
    padding: 12px;
  }
  
  .mat-cell,
  .mat-header-cell {
    padding: 8px 12px;
    font-size: 13px;
  }
}

/* ============================================================ */
/* Scrollbar Styling */
/* ============================================================ */
.assignment-dialog-content::-webkit-scrollbar {
  width: 8px;
}

.assignment-dialog-content::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.assignment-dialog-content::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 4px;
}

.assignment-dialog-content::-webkit-scrollbar-thumb:hover {
  background: #a1a1a1;
}

/* ============================================================ */
/* Animations */
/* ============================================================ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.table-section {
  animation: fadeIn 0.3s ease-in-out;
}

/* ============================================================ */
/* Print Styles */
/* ============================================================ */
@media print {
  .dialog-actions,
  .search-btn,
  .assign-btn,
  .action-button {
    display: none;
  }
  
  .assignment-dialog-content {
    max-height: none;
  }
}
