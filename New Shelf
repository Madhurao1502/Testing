createWorkOrderForFSR(params: any): Observable<any> {
  const payload = {
    storeNumber: params.storeNumber,
    storeName: params.storeName,
    iriWeek: params.iriWeek,
    territoryId: params.territoryId,
    empId: params.empId,
    fsrName: params.fsrName,
    fsrEmail: params.fsrEmail,
    tasks: params.tasks || null,  // Optional - for filtering specific tasks
    userId: localStorage.getItem('loggedUserId') || ''
  };

  return this.http.post<any>(
    this.baseUrl + 'api/TaskAssinment/CreateWorkOrderForFSR',
    payload,
    { 
      headers: { 'Content-Type': 'application/json; charset=utf-8' }
    }
  ).pipe(catchError(this.handleError('createWorkOrderForFSR', {})));
}

/**
 * Send email for the work order to FSR
 * @param pdfSessionId - PDF session ID from work order creation
 */
sendWorkOrderEmailToFSR(pdfSessionId: string): Observable<any> {
  const payload = {
    pdfSessionId: pdfSessionId,
    userId: localStorage.getItem('loggedUserId') || ''
  };

  return this.http.post<any>(
    this.baseUrl + 'api/TaskAssinment/SendWorkOrderEmailToFSR',
    payload,
    { 
      headers: { 'Content-Type': 'application/json; charset=utf-8' }
    }
  ).pipe(catchError(this.handleError('sendWorkOrderEmailToFSR', {})));
}

---
// ✅ CORRECT
async createAndSendWorkOrder(element: any): Promise<void> {
  try {
    element.isProcessingWorkOrder = true;
    this.commonService.show('create-work-order');
    
    // Get FSR information
    const fsrList = this.parseAssignedTo(element.AssignedTo);
    
    if (!fsrList || fsrList.length === 0) {
      this.snackbar.openSnackBar('No FSR assigned to this store', 'error');
      element.isProcessingWorkOrder = false;
      return;
    }
    
    const currentFilters = await firstValueFrom(this.commonService.currentFilters$);
    
    // Prepare work order parameters
    const workOrderParams = {
      storeNumber: element.StoreNumber,
      storeName: element.StoreName,
      iriWeek: currentFilters.iri_week,
      territoryId: currentFilters.territory_id,
      empId: fsrList.empId,  // First FSR
      fsrName: fsrList.name,
      fsrEmail: fsrList.email
    };
    
    // ✅ CORRECT - Call createWorkOrderForFSR (camelCase)
    const workOrderResponse = await firstValueFrom(
      this.commonService.createWorkOrderForFSR(workOrderParams)
    );
    
    const sessionId = workOrderResponse.sessionId;
    
    if (!sessionId) {
      throw new Error('No session ID returned from work order creation');
    }
    
    // ✅ CORRECT - Call sendWorkOrderEmailToFSR (camelCase)
    await firstValueFrom(
      this.commonService.sendWorkOrderEmailToFSR(sessionId)
    );
    
    this.snackbar.openSnackBar('Work order created and email sent successfully!', 'success');
    this.commonService.hide('create-work-order');
    
  } catch (error) {
    console.error('Error creating work order:', error);
    this.snackbar.openSnackBar('Error: ' + error.message, 'error');
  } finally {
    element.isProcessingWorkOrder = false;
    this.cdr.detectChanges();
  }
}

.........................
import { Injectable, Inject } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { countryModel, FilterOptions, GetGridDataFilter, SelectModel, Store, StoreFilter } from './common.model';
import { BehaviorSubject, catchError, firstValueFrom, Observable, of, shareReplay } from 'rxjs';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root',
})
export class CommonService {
 
  private translations: any = {};
  private currentLang: BehaviorSubject<string> = new BehaviorSubject<string>(this.getSavedLanguage()||'English');
  private languages: BehaviorSubject<string[]> = new BehaviorSubject<string[]>([]);
  private userGroups = {
    projectManagementGroup:false,
    isgTechnologyGroup:false,
    scanScapeGroup:false
  }
  userId: string;
  domainName: string;
  private groupStatusSubject = new BehaviorSubject<{[key:string]:boolean}>(this.userGroups)
  groupsStatus$=this.groupStatusSubject.asObservable();

private sampleStores: Store[]=[];

private sidebarStateSubject = new BehaviorSubject<boolean>(true);
public sidebarState$ = this.sidebarStateSubject.asObservable();
private filtersSubject = new BehaviorSubject<GetGridDataFilter>(new GetGridDataFilter());
public filters$ = this.filtersSubject.asObservable();
private gridDataSubject = new BehaviorSubject<any[]>([]);
public gridData$ = this.gridDataSubject.asObservable();
private countrySubject = new BehaviorSubject<string>('');
public country$ = this.countrySubject.asObservable();
private currentFiltersSubject = new BehaviorSubject<any>({});
public currentFilters$ = this.currentFiltersSubject.asObservable();
private currentIRIWeekSubject = new BehaviorSubject<string>('');
public currentIRIWeek$ = this.currentIRIWeekSubject.asObservable();

 private weekTypeSubject = new BehaviorSubject<'current' | 'future' | 'previous'>('current');
  public weekType$ = this.weekTypeSubject.asObservable();

  // Separate data subjects for each week type
  private currentWeekDataSubject = new BehaviorSubject<any[]>([]);
  public currentWeekData$ = this.currentWeekDataSubject.asObservable();

  private futureWeekDataSubject = new BehaviorSubject<any[]>([]);
  public futureWeekData$ = this.futureWeekDataSubject.asObservable();

  private previousWeekDataSubject = new BehaviorSubject<any[]>([]);
  public previousWeekData$ = this.previousWeekDataSubject.asObservable();

  private spinnerSubject = new BehaviorSubject<boolean>(false);
  public spinner$ = this.spinnerSubject.asObservable();
  
  private loadingTasks = new Set<string>();

  async fetchUserGroupMemberships(){
    this.userId = localStorage.getItem("loggedUserId");
      this.domainName = localStorage.getItem("loggedDomainId");
      try{
       const groups = await firstValueFrom(
      this.http.get<string[]>(this.baseUrl + `api/Utilities/GetLogonUserGroupList?userId=`+this.userId+"&domainId="+this.domainName)); 
      this.setUserGroup(groups) 
      }catch(error){
        console.error(error)
      }
     
  }
  
  setUserGroup(groups:any[]){ 
  groups.forEach(group=>{   
    if(group.anyType_Text ==='ISG TECHNOLOGY'){   
      this.userGroups.isgTechnologyGroup = true;      
    }else if (group.anyType_Text ==='ISG PROJECT MANAGEMENT'){ 
      this.userGroups.projectManagementGroup = true; 
    }else if (group.anyType_Text ==='SCANSCAPE FIELD'){    
      this.userGroups.scanScapeGroup = true; 
    }
  });
  
  this.groupStatusSubject.next(this.userGroups);  
  }

  private isgcountryapi=
    // 'https://localhost:7140/api/Country/getcountry';
    'http://isgiiswt02.iricommercial.com/isgapi/api/Country/getcountry';
    //'https://isg.infores.com/isgapi/api/Country/getcountry';
  
  private isgemployeeapi = 
    // 'https://localhost:7140/api/Employee/getemployee';
    'http://isgiiswt02.iricommercial.com/isgapi/api/Employee/getemployee';
    //'https://isg.infores.com/isgapi/api/Employee/getemployee';
  

 

  constructor(private http: HttpClient, @Inject('BASE_URL') private baseUrl: string) {
  }

  private getSavedLanguage():string | null{
    return localStorage.getItem('language')
  }

  private saveLanguage(lang:string){
    localStorage.setItem('language',lang)
  }

 

  async getcountry():Promise<countryModel[]>{
    if(environment.production)
    return await firstValueFrom(this.http.get<countryModel[]>(this.isgcountryapi));
    else
    return await firstValueFrom(this.http.get<countryModel[]>(this.baseUrl + `api/TestEnv/GetCountryTestEnv`)); 
  }

  getEmployee(lanId:string):Observable<any[]>{
    let url = this.isgemployeeapi
    if(lanId){
      url+=`?LanID=${lanId}`
    }
    const headers = new HttpHeaders({
      'Content-Type':'application/json'
    })

    if(environment.production)
      return this.http.get<any[]>(url,{headers:headers})
      else
      return this.http.get<any[]>(this.baseUrl + `api/TestEnv/GetEmployeeTestEnv?LanID=${this.userId}`); 
  }

//Testing
// Centralized API methods
getIriWeeks(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetIriWeek`)
    .pipe(catchError(this.handleError<any[]>('getIriWeeks', [])));
}

getTerritories(): Observable<any[]> {
  return this.http.get<any[]>(`${this.baseUrl}api/TaskAssinment/GetTerritory`)
    .pipe(catchError(this.handleError<any[]>('getTerritories', [])));
}

searchStores(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetStore`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStores', [])));
}

searchStates(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetState`, payload)
    .pipe(catchError(this.handleError<any[]>('searchStates', [])));
}

searchCities(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCity`, payload)
    .pipe(catchError(this.handleError<any[]>('searchCities', [])));
}

searchClusters(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetCluster`, payload)
    .pipe(catchError(this.handleError<any[]>('searchClusters', [])));
}

searchTasks(payload: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetTask`, payload)
    .pipe(catchError(this.handleError<any[]>('searchTasks', [])));
}

// getGridData(payload: GetGridDataFilter): Observable<any[]> {
//   return this.http.post<any[]>(`${this.baseUrl}api/TaskAssinment/GetGridData`, payload)
//     .pipe(catchError(this.handleError<any[]>('getGridData', [])));
// }

// getGridData(payload: GetGridDataFilter): Observable<any[]> {
//     const currentIRIWeek = this.getCurrentIRIWeek();
//     const payloadIRIWeek = payload.iriWeek;
    
//     let apiEndpoint = '';
    
//     // Determine which API to call based on IRI week comparison
//     if (payloadIRIWeek === currentIRIWeek) {
//       // Current week
//       apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetcurrentweekGridData`;
//       console.log('Using current week API');
//     } else if (payloadIRIWeek > currentIRIWeek) {
//       // Future week
//       apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetfutureweekGridData`;
//       console.log('Using future week API');
//     } else {
//       // Previous week
//       apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetpreviousweekGridData`;
//       console.log('Using previous week API');
//     }
    
//     console.log(`API Selection: Payload(${payloadIRIWeek}) vs Current(${currentIRIWeek}) -> ${apiEndpoint}`);
    
//     return this.http.post<any[]>(apiEndpoint, payload)
//       .pipe(catchError(this.handleError<any[]>('getGridData', [])));
//   }

getGridData(payload: GetGridDataFilter): Observable<any[]> {
    const currentIRIWeek = this.getCurrentIRIWeek();
    const payloadIRIWeek = payload.iriWeek;
    
    let apiEndpoint = '';
    let weekType: 'current' | 'future' | 'previous' = 'current';
    
    // Determine which API to call
    if (payloadIRIWeek === currentIRIWeek) {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetcurrentweekGridData`;
      weekType = 'current';
    } else if (payloadIRIWeek > currentIRIWeek) {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetfutureweekGridData`;
      weekType = 'future';
    } else {
      apiEndpoint = `${this.baseUrl}api/TaskAssinment/GetpreviousweekGridData`;
      weekType = 'previous';
    }
    
    // Update week type
    this.weekTypeSubject.next(weekType);
    
    return this.http.post<any[]>(apiEndpoint, payload)
      .pipe(catchError(this.handleError<any[]>('getGridData', [])));
  }

  // UPDATED: Apply filters with specific data stream updates
  applyFilters(filters: GetGridDataFilter): void {
    this.show('apply-Filters')
    const currentCountry = this.getCurrentCountry();
    
    if (!currentCountry) {
      filters.countryId = '1';
    } else {
      filters.countryId = currentCountry;
    }

    this.filtersSubject.next(filters);
   this.currentFiltersSubject.next({
      countryId: filters.countryId,
      iri_week: filters.iriWeek,
      territory_id: filters.territoryId,
      area: filters.area,
      store_number: filters.storeNumber,
      store_name: filters.storeName,
      state: filters.state,
      city: filters.city,
      position_number: filters.positionNumber,
      task_number: filters.taskNumber,
      emp_id: filters.empId,
      fsr_hour: filters.fsrHour,
      fsr_over_25hrs: filters.fsrOver25hrs,
      fsr_over_6hrs: filters.fsrOver6hrs,
      assigned_stores: filters.assignedStores,
      unassigned_stores: filters.unassignedStores,
      sample: filters.sample,
      nonsample: filters.nonSample,
      multi_fsr_store: filters.multiFsrStore,
      vacation: filters.vacation,
      temporary: filters.temporary,
      fsr_hour_operator: filters.fsrHourOperator
    });

    this.currentWeekDataSubject.next([]);
    this.futureWeekDataSubject.next([]);
    this.previousWeekDataSubject.next([]);
    this.gridDataSubject.next([]);
    
    // Call API and update specific data stream
     this.getGridData(filters).subscribe({
      next: (data) => {
        const currentIRIWeek = this.getCurrentIRIWeek();
        const payloadIRIWeek = filters.iriWeek;
        
        // Add comment editing capability and normalize field names
        const dataWithComments = data.map(row => ({
          ...row,         
          // Normalize field names for consistent access
          StoreNumber: row.StoreNumber || row.store_number,
          StoreName: row.StoreName || row.store_name,
          City: row.CityName || row.city_name,
          State: row.StateCd || row.state_cd,
          Zip: row.ZipCd || row.zip_cd,
          AddrLine1: row.AddrLine1 || row.addr_line1,
          AssignedTo: this.getAssignedToDisplay(row),
          UserComment: row.AssignmentNotes || '',
          IsCommentEditing: false
        }));
        
        // Update appropriate data stream based on week type
        if (payloadIRIWeek === currentIRIWeek) {
          this.currentWeekDataSubject.next(dataWithComments);
         
        } else if (payloadIRIWeek > currentIRIWeek) {
          this.futureWeekDataSubject.next(dataWithComments);
        
        } else {
          this.previousWeekDataSubject.next(dataWithComments);
          
        }
        
        // Also update main grid data for backward compatibility
        this.gridDataSubject.next(dataWithComments);
        this.hide('apply-Filters')
      },
      error: (error) => {
        console.error('Error applying filters:', error);
        this.currentWeekDataSubject.next([]);
        this.futureWeekDataSubject.next([]);
        this.previousWeekDataSubject.next([]);
        this.gridDataSubject.next([]);
      }
    });
  }

   private getAssignedToDisplay(row: any): string {

    if(!row.EmployeeName){
      return 'NOT ASSIGNED'
    }else if(row.EmployeeName === 'NOT ASSIGNED'){
       return 'NOT ASSIGNED'
    }else if(row.EmployeeName == ' '){
       return 'NOT ASSIGNED'
    }else{
      return row.EmployeeName.trim()
    }

    

  // if (!row.FirstName || !row.LastName) {
  //   return 'NOT ASSIGNED';
  // }

  // const hasCommaInFirst = row.FirstName.includes(',');
  // const hasCommaInLast = row.LastName.includes(',');

  // Case 1: Not comma separated (just a single name)
  // if (!hasCommaInFirst && !hasCommaInLast) {
  //   return `${row.FirstName.trim()} ${row.LastName.trim()}`.trim();
  // }

  // Case 2: Comma separated names
  // const firstNames = row.FirstName.split(',').map(name => name.trim());
  // const lastNames = row.LastName.split(',').map(name => name.trim());

  // if (firstNames.length !== lastNames.length) {
  //   console.warn('Mismatch between first names and last names count');
  //   return `${row.FirstName} ${row.LastName}`.trim();
  // }

  // // Create full names
  // const fullNames = firstNames.map((firstName, index) => {
  //   const lastName = lastNames[index] || '';
  //   return `${firstName} ${lastName}`.trim();
  // });

  // return fullNames.join(', ');
}
  


  getCurrentWeekType(): 'current' | 'future' | 'previous' {
    return this.weekTypeSubject.value;
  }

private handleError<T>(operation = 'operation', result?: T) {
  return (error: any): Observable<T> => {
    console.error(`${operation} failed:`, error);
    return of(result as T);
  };
}


  // ADD: Save user comment for a row
  saveUserComment(storeNumber: string, comment: string): Observable<any> {
    const payload = {
      StoreNumber: storeNumber,
      Comment: comment,
      UserId: localStorage.getItem("loggedUserId") || ''
    };
     return this.http.post(`${this.baseUrl}api/TaskAssinment/SaveUserComment`, payload)
     .pipe(catchError(this.handleError('saveUserComment', {})));
  }



 clearFilters(): void {
    const defaultFilters = new GetGridDataFilter();
    this.filtersSubject.next(defaultFilters);
    this.currentWeekDataSubject.next([]);
    this.futureWeekDataSubject.next([]);
    this.previousWeekDataSubject.next([]);
    this.gridDataSubject.next([]);
  }

setCountry(countryId: string): void {
    this.countrySubject.next(countryId);
  }

 
  getCurrentCountry(): string {
    return this.countrySubject.value;
  }

  async loadCurrentIRIWeek(): Promise<void> {
    try {
      const currentWeek = await firstValueFrom(
        this.http.get<any>(`${this.baseUrl}api/TaskAssinment/GetCurrentIRIWeek`)
      );
      this.currentIRIWeekSubject.next(currentWeek.toString());
    } catch (error) {
      console.error('Error loading current IRI week:', error);
    }
  }

  getCurrentIRIWeek(): string {
    return this.currentIRIWeekSubject.value;
  }

   show(taskId: string = 'default'): void {
    this.loadingTasks.add(taskId);
    this.spinnerSubject.next(true);
  }

  hide(taskId: string = 'default'): void {
    this.loadingTasks.delete(taskId);
    if (this.loadingTasks.size === 0) {
      this.spinnerSubject.next(false);
    }
  }

  hideAll(): void {
    this.loadingTasks.clear();
    this.spinnerSubject.next(false);
  }

  isLoading(): boolean {
    return this.spinnerSubject.value;
  }

  
  createWorkOrder(params: any): Observable<any> {
    return this.http.post<any>(
      this.baseUrl + 'api/TaskAssinment/CreateWorkOrder', 
      params,
      { 
        headers: { 'Content-Type': 'application/json; charset=utf-8' }
      }
    );
  }

 
  sendWorkOrderEmail(pdfSessionId: string): Observable<any> {
    return this.http.post<any>(
      this.baseUrl + 'api/TaskAssinment/SendWorkOrderEmail',
      { pdfSessionId: pdfSessionId },
      { 
        headers: { 'Content-Type': 'application/json; charset=utf-8' }
      }
    );
  }

  CreateWorkOrderForFSR(params: any): Observable<any> {
  return this.http.post<any>(
    this.baseUrl + 'api/TaskAssinment/CreateWorkOrderForFSR', 
    {
      storeNumber: params.storeNumber,
      storeName: params.storeName,
      iriWeek: params.iriWeek,
      territoryId: params.territoryId,
      empId: params.empId,  
      fsrName: params.fsrName,
      fsrEmail: params.fsrEmail,
      tasks: params.tasks || null, 
      userId: localStorage.getItem('loggedUserId') || ''
    },
    { 
      headers: { 'Content-Type': 'application/json; charset=utf-8' }
    }
  );
}

// Send email for the work order
SendWorkOrderEmailToFSR(pdfSessionId: string): Observable<any> {
  return this.http.post<any>(
    this.baseUrl + 'api/TaskAssinment/SendWorkOrderEmailToFSR',
    { 
      pdfSessionId: pdfSessionId,
      userId: localStorage.getItem('loggedUserId') || ''
    },
    { 
      headers: { 'Content-Type': 'application/json; charset=utf-8' }
    }
  );
}

 
//end


}
