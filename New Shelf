<div class="search-paginator-bar">
  <mat-form-field appearance="standard" class="search-field">
    <mat-label>Search stores...</mat-label>
    <input matInput [formControl]="searchControl" placeholder="Search by store number, name, address, city, state, assigned to, etc.">
    <mat-icon matPrefix>search</mat-icon>
    <button mat-button *ngIf="searchControl.value" matSuffix mat-icon-button (click)="clearSearch()">
      <mat-icon>clear</mat-icon>
    </button>
  </mat-form-field>
  <mat-paginator [length]="totalRecords"
                 [pageSize]="50"
                 [pageSizeOptions]="[50,100,150,200]"
                 showFirstLastButtons="true">
  </mat-paginator>
</div>

.search-paginator-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  gap: 32px;
  width: 100%;
}
.search-field {
  flex: 1 1 320px;
  max-width: 380px;
  min-width: 220px;
  margin-right: 32px;
}
mat-paginator {
  flex-shrink: 0;
}


.........................................................
UPDATED store-table.component.html (With Sortable Columns)
xml
<mat-card-content>
  <div class="table-wrapper">
    <mat-table #table [dataSource]="dataSource" matSort class="store-table mat-elevation-2" [ngClass]="getWeekTypeTableClass()">
      
      <!-- Store Number Column - Sortable -->
      <ng-container matColumnDef="store_number" *ngIf="isColumnVisible('store_number')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="StoreNumber" class="mat-header-style">
          <button mat-icon-button 
                  [disabled]="isExpandingAll"
                  (click)="expandAllRows()" 
                  [title]="allExpanded ? 'Collapse All' : 'Expand All'"
                  class="expand-all-btn">
            <mat-icon>{{allExpanded ? 'unfold_less' : 'unfold_more'}}</mat-icon>
          </button>
          Store #
        </mat-header-cell>
        <mat-cell *matCellDef="let element" class="store-number-cell">
          <div style="width: 100%;">
            <span class="caret" [class.clicked]="isRowExpanded(element)">â–¼</span>
            <span class="store-number">{{element.StoreNumber}}</span>
          </div>
        </mat-cell>
      </ng-container>

      <!-- Territory - Sortable -->
      <ng-container matColumnDef="territory" *ngIf="isColumnVisible('territory')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="FldTerrtyNbr" class="mat-header-style" matTooltip="Territory">
          Terr
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.FldTerrtyNbr}}</mat-cell>
      </ng-container>

      <!-- Position Number - Sortable -->
      <ng-container matColumnDef="position_number" *ngIf="isColumnVisible('position_number')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="PositionName" class="mat-header-style">
          Position #
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.PositionName}}</mat-cell>
      </ng-container>

      <!-- BFD - Sortable -->
      <ng-container matColumnDef="bdf" *ngIf="isColumnVisible('bdf')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="Bfd" class="mat-header-style">
          BFD
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.Bfd}}</mat-cell>
      </ng-container>

      <!-- Outlet - Sortable -->
      <ng-container matColumnDef="outlet" *ngIf="isColumnVisible('outlet')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="OutletType" class="mat-header-style">
          Outlet
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.OutletType}}</mat-cell>
      </ng-container>

      <!-- Store Name Column - Sortable -->
      <ng-container matColumnDef="store_name" *ngIf="isColumnVisible('store_name')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="StoreName" class="mat-header-style">
          Store Name
        </mat-header-cell>
        <mat-cell *matCellDef="let element" class="store-name-cell">
          <div style="width: 100%;">
            <span class="store-name" (click)="openProximityDataDialog(element); $event.stopPropagation();">
              {{element.StoreName}}
            </span>
          </div>
        </mat-cell>
      </ng-container>

      <!-- Address Column - Sortable -->
      <ng-container matColumnDef="addr_line1" *ngIf="isColumnVisible('addr_line1')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="AddrLine1" class="mat-header-style">
          Address
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.AddrLine1}}</mat-cell>
      </ng-container>

      <!-- City Column - Sortable -->
      <ng-container matColumnDef="city" *ngIf="isColumnVisible('city')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="City" class="mat-header-style">
          City
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.City}}</mat-cell>
      </ng-container>

      <!-- State Column - Sortable -->
      <ng-container matColumnDef="state" *ngIf="isColumnVisible('state')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="State" class="mat-header-style">
          State
        </mat-header-cell>
        <mat-cell *matCellDef="let element">
          <div style="width: 100%;">
            <span class="state-badge">{{element.State}}</span>
          </div>
        </mat-cell>
      </ng-container>

      <!-- Zip Column - Sortable -->
      <ng-container matColumnDef="zip" *ngIf="isColumnVisible('zip')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="Zip" class="mat-header-style">
          Zip
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{element.Zip}}</mat-cell>
      </ng-container>

      <!-- ENHANCED: Assigned To Column - Sortable -->
      <ng-container matColumnDef="assigned_to" *ngIf="isColumnVisible('assigned_to')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="AssignedTo" class="mat-header-style">
          Assigned To
        </mat-header-cell>
        <mat-cell *matCellDef="let element" class="assigned-cell" 
                  (click)="openAssignmentDialog(element, 'StoreLevel'); $event.stopPropagation()">
          <div class="assignment-container">
            <div class="assignment-names" 
                [ngClass]="getAssignmentClass(element.AssignedTo)"
                [matTooltip]="getAssignedToTooltip(element.AssignedTo)"
                matTooltipClass="multi-line-tooltip">
              
              <!-- Single person or NOT ASSIGNED - display normally -->
              <div *ngIf="!shouldDisplayMultipleLines(element.AssignedTo)" class="single-name">
                {{element.AssignedTo || 'NOT ASSIGNED'}}
              </div>
              
              <!-- Multiple people - display line by line -->
              <div *ngIf="shouldDisplayMultipleLines(element.AssignedTo)" class="multiple-names">
                <div *ngFor="let name of getIndividualNames(element.AssignedTo); let i = index" 
                    class="name-line"
                    [class.first-name]="i === 0">
                  {{name}}
                </div>
              </div>
            </div>
          </div>
        </mat-cell>
      </ng-container>

      <!-- Task Completed Column - Sortable -->
      <ng-container matColumnDef="task_completed" *ngIf="isColumnVisible('task_completed')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="TaskCompleted" class="mat-header-style" 
                         matTooltip="Task Completed Status">
          Completed
        </mat-header-cell>
        <mat-cell *matCellDef="let element">
          <span class="status-badge" [ngClass]="getTaskCompletedClass(element.TaskCompleted)">
            {{formatTaskCompleted(element.TaskCompleted)}}
          </span>
        </mat-cell>
      </ng-container>

      <!-- Quality Column - Sortable -->
      <ng-container matColumnDef="quality" *ngIf="isColumnVisible('quality')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="Quality" class="mat-header-style" 
                         matTooltip="Quality Assessment">
          Quality
        </mat-header-cell>
        <mat-cell *matCellDef="let element">
          <span class="quality-badge" [ngClass]="getQualityClass(element.Quality)">
            {{formatQuality(element.Quality)}}
          </span>
        </mat-cell>
      </ng-container>

      <!-- Cost Over Column - Sortable -->
      <ng-container matColumnDef="cost_over" *ngIf="isColumnVisible('cost_over')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="CostOver" class="mat-header-style">
          Over Cost
        </mat-header-cell>
        <mat-cell *matCellDef="let element">
          <span class="cost-badge" [ngClass]="getCostOverClass(element.CostOver)">
            {{formatCostOver(element.CostOver)}}
          </span>
        </mat-cell>
      </ng-container>

      <!-- Guaranteed Miles Column - Sortable -->
      <ng-container matColumnDef="guaranteed_miles" *ngIf="isColumnVisible('guaranteed_miles')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="GuaranteedMiles" class="mat-header-style">
          Miles
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatGuaranteedMiles(element.GuaranteedMiles)}}</mat-cell>
      </ng-container>

      <!-- Average Cost Column - Sortable -->
      <ng-container matColumnDef="avg_cost" *ngIf="isColumnVisible('avg_cost')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="AvgCost" class="mat-header-style">
          Avg Cost
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.AvgCost)}}</mat-cell>
      </ng-container>

      <!-- WK1 Costs Column - Sortable -->
      <ng-container matColumnDef="wk1_costs" *ngIf="isColumnVisible('wk1_costs')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK1FSRProdCost" class="mat-header-style">
          WK1 Cost
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK1FSRProdCost)}}</mat-cell>
      </ng-container>

      <!-- WK1 Travel Costs Column - Sortable -->
      <ng-container matColumnDef="wk1_travel" *ngIf="isColumnVisible('wk1_travel')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK1StoreTravelCost" class="mat-header-style">
          WK1 Travel
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK1StoreTravelCost)}}</mat-cell>
      </ng-container>

      <!-- WK1 OVG Travel Column - Sortable -->
      <ng-container matColumnDef="wk1_ovg_travel" *ngIf="isColumnVisible('wk1_ovg_travel')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK1StoreTravelOvgCost" class="mat-header-style">
          WK1 OVG Travel
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK1StoreTravelOvgCost)}}</mat-cell>
      </ng-container>

      <!-- WK2 Costs Column - Sortable -->
      <ng-container matColumnDef="wk2_costs" *ngIf="isColumnVisible('wk2_costs')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK2FSRProdCost" class="mat-header-style">
          WK2 Cost
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK2FSRProdCost)}}</mat-cell>
      </ng-container>

      <!-- WK2 Travel Costs Column - Sortable -->
      <ng-container matColumnDef="wk2_travel" *ngIf="isColumnVisible('wk2_travel')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK2StoreTravelCost" class="mat-header-style">
          WK2 Travel
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK2StoreTravelCost)}}</mat-cell>
      </ng-container>

      <!-- WK2 OVG Travel Column - Sortable (Fixed header text) -->
      <ng-container matColumnDef="wk2_ovg_travel" *ngIf="isColumnVisible('wk2_ovg_travel')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="WK2StoreTravelOvgCost" class="mat-header-style">
          WK2 OVG Travel
        </mat-header-cell>
        <mat-cell *matCellDef="let element">{{formatMoney(element.WK2StoreTravelOvgCost)}}</mat-cell>
      </ng-container>

      <!-- ENHANCED: Comments Column - Sortable -->
      <ng-container matColumnDef="user_comment" *ngIf="isColumnVisible('user_comment')">
        <mat-header-cell *matHeaderCellDef mat-sort-header="UserComment" class="mat-header-style">
          Comments
        </mat-header-cell>
        <mat-cell *matCellDef="let element" class="comment-cell">
          <div class="comment-display"
               (click)="openCommentDialog(element); $event.stopPropagation();"
               [title]="element.UserComment || 'Click to add/edit comment'"
               [class.has-comment]="element.UserComment"
               [class.clickable]="canEditComments || element.UserComment">
            
            <span class="comment-text">
              {{getCommentDisplay(element.UserComment)}}
            </span>
          </div>
        </mat-cell>
      </ng-container>

      <!-- Header and Data Rows -->
      <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>
      <mat-row *matRowDef="let row; columns: displayedColumns; let i = index"
              class="table-row"
              [cdkDetailRow]="row" 
              [cdkDetailRowTpl]="tpl"
              (toggleChange)="GetSubgridData($event, row)"
              (dataLoadRequest)="onDataLoadRequest($event)"
              matRipple>
      </mat-row>
    </mat-table>
  </div>
  
  <mat-paginator [pageSizeOptions]="[50, 100, 150, 200]" 
                showFirstLastButtons
                class="table-paginator">
  </mat-paginator>
</mat-card-content>
UPDATED store-table.component.ts (Enhanced Sorting Support)
typescript
export class StoreTableComponent implements OnInit, OnDestroy, AfterViewInit {
  // ... existing properties ...

  // ADD: Sorting state properties
  currentSortColumn: string = '';
  currentSortDirection: 'asc' | 'desc' | '' = '';

  ngAfterViewInit(): void {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    
    // ENHANCED: Configure custom sorting for complex columns
    this.dataSource.sortingDataAccessor = (data: any, sortHeaderId: string) => {
      switch (sortHeaderId) {
        // Numeric sorting
        case 'StoreNumber':
          return parseInt(data.StoreNumber) || 0;
        
        case 'FldTerrtyNbr':
          return parseInt(data.FldTerrtyNbr) || 0;
        
        case 'Zip':
          return data.Zip ? data.Zip.toString() : '';
        
        // Cost columns - convert to numbers for proper sorting
        case 'AvgCost':
        case 'WK1FSRProdCost':
        case 'WK1StoreTravelCost':
        case 'WK1StoreTravelOvgCost':
        case 'WK2FSRProdCost':
        case 'WK2StoreTravelCost':
        case 'WK2StoreTravelOvgCost':
        case 'GuaranteedMiles':
          return parseFloat(data[sortHeaderId]) || 0;
        
        // String sorting (case-insensitive)
        case 'StoreName':
        case 'AddrLine1':
        case 'City':
        case 'State':
        case 'PositionName':
        case 'Bfd':
        case 'OutletType':
          return data[sortHeaderId] ? data[sortHeaderId].toString().toLowerCase() : '';
        
        // Assigned To - sort by first name for multiple assignments
        case 'AssignedTo':
          if (!data.AssignedTo || data.AssignedTo === 'NOT ASSIGNED') {
            return 'zzz'; // Put unassigned at bottom
          }
          // Get first name from comma-separated list
          const firstName = data.AssignedTo.split(',').trim();
          return firstName.toLowerCase();
        
        // Status columns - custom sort order
        case 'TaskCompleted':
          return this.getTaskCompletedSortValue(data.TaskCompleted);
        
        case 'Quality':
          return this.getQualitySortValue(data.Quality);
        
        case 'CostOver':
          return this.getCostOverSortValue(data.CostOver);
        
        // Comments - sort by existence and then alphabetically
        case 'UserComment':
          if (!data.UserComment) return 'zzz'; // Empty comments last
          return data.UserComment.toLowerCase();
        
        default:
          return data[sortHeaderId] || '';
      }
    };

    // Set initial table width
    setTimeout(() => {
      this.updateTableWidth();
    }, 100);
    
    if (this.paginator) {
      this.paginator.page
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          this.forceCollapseAllRows();
          this.resetExpansionState();
        });
    }
  }

  // ADD: Custom sort value methods
  private getTaskCompletedSortValue(status: any): number {
    if (!status) return 3;
    const statusStr = status.toString().toLowerCase();
    switch (statusStr) {
      case 'yes':
      case 'completed':
      case 'complete':
        return 1;
      case 'no':
      case 'incomplete':
      case 'pending':
        return 2;
      default:
        return 3;
    }
  }

  private getQualitySortValue(quality: any): number {
    if (!quality) return 4;
    const qualityStr = quality.toString().toLowerCase();
    switch (qualityStr) {
      case 'approved':
      case 'good':
        return 1;
      case 'average':
        return 2;
      case 'poor':
      case 'rejected':
        return 3;
      default:
        return 4;
    }
  }

  private getCostOverSortValue(costOver: any): number {
    if (!costOver) return 2;
    const costStr = costOver.toString().toLowerCase();
    switch (costStr) {
      case 'no':
      case 'false':
        return 1;
      case 'yes':
      case 'true':
        return 2;
      default:
        return 2;
    }
  }

  // ADD: Enhanced money formatting for display
  formatMoney(value: any): string {
    if (!value || value === 0 || value === '0') return '$0.00';
    
    const num = parseFloat(value);
    if (isNaN(num)) return '$0.00';
    
    return '$' + num.toLocaleString('en-US', { 
      minimumFractionDigits: 2, 
      maximumFractionDigits: 2 
    });
  }

  // ADD: Sort change handler with logging
  onSortChange(event: any): void {
    this.currentSortColumn = event.active;
    this.currentSortDirection = event.direction;
    
    console.log(`Sorting by: ${event.active} (${event.direction})`);
    
    // Collapse all expanded rows when sorting
    this.forceCollapseAllRows();
    this.resetExpansionState();
  }

  // ADD: Get current sort info for display
  getCurrentSortInfo(): { column: string, direction: string } {
    return {
      column: this.currentSortColumn || 'None',
      direction: this.currentSortDirection || 'None'
    };
  }

  // ... rest of your existing methods remain unchanged ...
}
ENHANCED store-table.component.css (Sort Styling)
css
/* ... your existing CSS ... */

/* ENHANCED: Sort header styling */
.mat-sort-header-button {
  border: none;
  background: transparent;
  color: inherit;
  cursor: pointer;
  display: flex;
  align-items: center;
  font-weight: inherit;
  font-size: inherit;
  font-family: inherit;
  text-align: left;
  width: 100%;
}

.mat-sort-header-arrow {
  opacity: 0.54;
  transition: opacity 0.3s ease;
}

.mat-sort-header-sorted .mat-sort-header-arrow {
  opacity: 1;
}

/* Sort indicator positioning */
.mat-header-cell .mat-sort-header-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
}

/* Expand button in sortable header */
.mat-header-cell .expand-all-btn {
  margin-right: 8px;
  flex-shrink: 0;
}

/* Hover effect for sortable headers */
.mat-sort-header-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.mat-sort-header-button:focus {
  outline: none;
  background-color: rgba(255, 255, 255, 0.1);
}

/* Sort arrow custom styling */
.mat-sort-header-arrow .mat-sort-header-stem {
  background-color: currentColor;
  height: 10px;
  width: 2px;
  margin: 0 auto;
  transition: opacity 0.3s ease;
}

.mat-sort-header-arrow .mat-sort-header-indicator {
  opacity: 0.54;
}

.mat-sort-header-sorted .mat-sort-header-indicator {
  opacity: 1;
}

/* Active sort column highlighting */
.mat-header-cell.mat-sort-header-sorted {
  background-color: rgba(255, 255, 255, 0.1);
}

/* Sort direction indicators */
.mat-sort-header[aria-sort="ascending"] .mat-sort-header-arrow {
  transform: rotate(0deg);
}

.mat-sort-header[aria-sort="descending"] .mat-sort-header-arrow {
  transform: rotate(180deg);
}

/* Responsive sort headers */
@media (max-width: 768px) {
  .mat-sort-header-button {
    font-size: 11px;
    padding: 4px;
  }
  
  .expand-all-btn {
    width: 24px;
    height: 24px;
    min-width: 24px;
  }
  
  .expand-all-btn mat-icon {
    font-size: 16px;
    width: 16px;
    height: 16px;
  }
}

/* Sort indicator in small columns */
.mat-column-territory .mat-sort-header-arrow,
.mat-column-bdf .mat-sort-header-arrow,
.mat-column-outlet .mat-sort-header-arrow,
.mat-column-state .mat-sort-header-arrow {
  margin-left: 4px;
}

/* Loading state during sort */
.table-sorting .mat-row {
  opacity: 0.7;
  transition: opacity 0.3s ease;
}
Summary of Sorting Features Added:
âœ… All Columns Now Sortable:
Text columns: Store Name, Address, City, State, etc.

Numeric columns: Store Number, Territory, Zip, Miles, etc.

Money columns: All cost fields with proper numeric sorting

Status columns: Task Completed, Quality, Cost Over

Complex columns: Assigned To (sorts by first name)

âœ… Smart Sorting Logic:
typescript
// Numbers sort numerically (not as strings)
case 'StoreNumber': return parseInt(data.StoreNumber) || 0;

// Money fields sort as numbers
case 'AvgCost': return parseFloat(data.AvgCost) || 0;

// Status fields have custom sort order
case 'TaskCompleted': return this.getTaskCompletedSortValue(data.TaskCompleted);
// Yes/Complete = 1, No/Incomplete = 2, Other = 3
